var tipuesearch = {"pages":[{"title":" Fortran Program ","text":"Fortran Program","tags":"home","loc":"index.html"},{"title":"SourceTermMMS.f90 – Fortran Program","text":"Contents Subroutines SourceCalc Source Code SourceTermMMS.f90 Source Code ! gam - axial wavenumber t ! ak  - reduced frequency ! kappa - ratio of specific heats ! i - imaginary number SUBROUTINE SourceCalc (& r , & S_1 , & S_2 , & S_3 , & S_4 ) REAL ( KIND = rDef ) , DIMENSION (:), INTENT ( IN ) :: r COMPLEX ( KIND = rDef ), DIMENSION (:), INTENT ( INOUT ) :: S_1 , S_2 , S_3 , S_4 ! Local variables COMPLEX ( KIND = rDef ) :: i INTEGER :: jj , numberOfGridPoints i = CMPLX ( 0.0 , 1.0 , KIND = rDef ) numberOfGridPoints = SIZE ( r ) DO jj = 1 , numberOfGridPoints S_1 ( jj ) = - i * ( 0.261177694086339d0 * ( r ( jj ) - 0.1d0 ) ** 3 - 0.352589887016558d0 * ( r ( jj ) - 0.1d0 ) & ** 2 + 0.125d0 * tanh ( 1.1111111111111112d0 * r ( jj ) - 1.1111111111111112d0 & ) + 0.0951992694944706d0 ) * ( - 0.025d0 * tanh ( 5 5.555555555555557d0 * r ( jj ) - & 5 5.555555555555557d0 ) - 0.2d0 + 1.0d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r ( jj ) - 0.033333333333333333d0 ) + 1 ) - & 3.16227766016838d0 * sqrt ( r ( jj ) * ( 0.00833333333333333d0 - & 0.00833333333333333d0 * tanh ( 0.033333333333333333d0 * r ( jj ) - & 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r ( jj ) - 0.033333333333333333d0 ) + 1 )) / r ( jj )) - & 1.05918868868323d0 * r ( jj ) - 1.17020773651844d0 * ( r ( jj ) - 0.1d0 ) ** 2 - & 1.38888888888889d0 * tanh ( 1 1.111111111111111d0 * r ( jj ) - & 1 1.111111111111111d0 ) ** 2 + 2.28739875652464d0 - & 3.16227766016838d0 * sqrt ( r ( jj ) * ( 0.00833333333333333d0 - & 0.00833333333333333d0 * tanh ( 0.033333333333333333d0 * r ( jj ) - & 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r ( jj ) - 0.033333333333333333d0 ) + 1 )) * ( 0.125d0 & * tanh ( 2 2.222222222222221d0 * r ( jj ) - 2 2.222222222222221d0 ) + 1 ) / r ( jj ) + & 1.0d0 * ( r ( jj ) * ( 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( jj ) - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r ( jj ) - 0.033333333333333333d0 ) + & 1 )) ** 1.0d0 * ( 0.792590998767432d0 * r ( jj ) - 0.390069245506146d0 * ( r ( jj ) - & 0.1d0 ) ** 3 - 0.529594344341616d0 * ( r ( jj ) - 0.1d0 ) ** 2 + 0.125d0 * tanh ( & 1 1.111111111111111d0 * r ( jj ) - 1 1.111111111111111d0 ) + & 0.920740900123257d0 ) / r ( jj ) S_2 ( jj ) = - i * ( 0.125d0 * tanh ( 2 2.222222222222221d0 * r ( jj ) - 2 2.222222222222221d0 ) + 1 ) * ( & - 0.025d0 * tanh ( 5 5.555555555555557d0 * r ( jj ) - 5 5.555555555555557d0 ) - & 0.2d0 + 1.0d0 / ( 0.125d0 * tanh ( 0.033333333333333333d0 * r ( jj ) - & 0.033333333333333333d0 ) + 1 ) - 3.16227766016838d0 * sqrt ( r ( jj ) * ( & 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( jj ) - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r ( jj ) - 0.033333333333333333d0 ) + & 1 )) / r ( jj )) + 2.0d0 * i * ( 0.792590998767432d0 * r ( jj ) - 0.390069245506146d0 * ( r ( jj ) & - 0.1d0 ) ** 3 - 0.529594344341616d0 * ( r ( jj ) - 0.1d0 ) ** 2 + 0.125d0 * tanh ( & 1 1.111111111111111d0 * r ( jj ) - 1 1.111111111111111d0 ) + & 0.920740900123257d0 ) / r ( jj ) + ( 1.58113883008419d0 * sqrt ( r ( jj ) * ( & 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( jj ) - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r ( jj ) - 0.033333333333333333d0 ) + & 1 )) / r ( jj ) + 1.58113883008419d0 * sqrt ( r ( jj ) * ( 0.00833333333333333d0 - & 0.00833333333333333d0 * tanh ( 0.033333333333333333d0 * r ( jj ) - & 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r ( jj ) - 0.033333333333333333d0 ) + 1 )) * ( 0.125d0 & * tanh ( 0.033333333333333333d0 * r ( jj ) - 0.033333333333333333d0 ) + 1 ) ** & 1.0d0 * ( 0.5d0 * r ( jj ) * ( 0.00833333333333333d0 - 0.00833333333333333d0 * & tanh ( 0.033333333333333333d0 * r ( jj ) - 0.033333333333333333d0 ) ** 2 ) * ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r ( jj ) - 0.033333333333333333d0 ) + & 1 ) ** ( - 2.0d0 ) * ( 0.00416666666666667d0 * tanh ( 0.033333333333333333d0 * r ( jj ) & - 0.033333333333333333d0 ) ** 2 - 0.00416666666666667d0 ) - & 0.00416666666666667d0 * r ( jj ) * ( 0.0666666666666667d0 - & 0.0666666666666667d0 * tanh ( 0.033333333333333333d0 * r ( jj ) - & 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r ( jj ) - 0.033333333333333333d0 ) + 1 ) * tanh ( & 0.033333333333333333d0 * r ( jj ) - 0.033333333333333333d0 ) + 0.5d0 * ( & 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( jj ) - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r ( jj ) - 0.033333333333333333d0 ) + & 1 )) / ( r ( jj ) * ( 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( jj ) - 0.033333333333333333d0 ) ** 2 )) + & 0.790569415042095d0 * ( r ( jj ) * ( 0.00833333333333333d0 - & 0.00833333333333333d0 * tanh ( 0.033333333333333333d0 * r ( jj ) - & 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r ( jj ) - 0.033333333333333333d0 ) + 1 )) ** 1.5d0 / r ( jj ) & ) * ( 0.261177694086339d0 * ( r ( jj ) - 0.1d0 ) ** 3 - 0.352589887016558d0 * ( r ( jj ) - & 0.1d0 ) ** 2 + 0.125d0 * tanh ( 1.1111111111111112d0 * r ( jj ) - & 1.1111111111111112d0 ) + 0.0951992694944706d0 ) S_3 ( jj ) = - i * ( 0.125d0 * tanh ( 2 2.222222222222221d0 * r ( jj ) - 2 2.222222222222221d0 ) + 1 ) * ( & - 0.025d0 * tanh ( 5 5.555555555555557d0 * r ( jj ) - 5 5.555555555555557d0 ) - & 0.2d0 + 1.0d0 / ( 0.125d0 * tanh ( 0.033333333333333333d0 * r ( jj ) - & 0.033333333333333333d0 ) + 1 ) - 3.16227766016838d0 * sqrt ( r ( jj ) * ( & 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( jj ) - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r ( jj ) - 0.033333333333333333d0 ) + & 1 )) / r ( jj )) + 1.0d0 * i * ( 0.792590998767432d0 * r ( jj ) - 0.390069245506146d0 * ( r ( jj ) & - 0.1d0 ) ** 3 - 0.529594344341616d0 * ( r ( jj ) - 0.1d0 ) ** 2 + 0.125d0 * tanh ( & 1 1.111111111111111d0 * r ( jj ) - 1 1.111111111111111d0 ) + & 0.920740900123257d0 ) + ( - 1.38888888888889d0 * tanh ( & 5 5.555555555555557d0 * r ( jj ) - 5 5.555555555555557d0 ) ** 2 + & 1.38888888888889d0 + 0.5d0 * ( r ( jj ) * ( 0.00833333333333333d0 - & 0.00833333333333333d0 * tanh ( 0.033333333333333333d0 * r ( jj ) - & 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r ( jj ) - 0.033333333333333333d0 ) + 1 )) ** 1.0d0 * ( & 0.025d0 * tanh ( 5 5.555555555555557d0 * r ( jj ) - 5 5.555555555555557d0 ) + & 0.2d0 ) / r ( jj )) * ( 0.261177694086339d0 * ( r ( jj ) - 0.1d0 ) ** 3 - & 0.352589887016558d0 * ( r ( jj ) - 0.1d0 ) ** 2 + 0.125d0 * tanh ( & 1.1111111111111112d0 * r ( jj ) - 1.1111111111111112d0 ) + & 0.0951992694944706d0 ) S_4 ( jj ) = 1.0d0 * i * ( 0.125d0 * tanh ( 2 2.222222222222221d0 * r ( jj ) - 2 2.222222222222221d0 ) + 1 & ) - i * ( - 0.025d0 * tanh ( 5 5.555555555555557d0 * r ( jj ) - & 5 5.555555555555557d0 ) - 0.2d0 + 1.0d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r ( jj ) - 0.033333333333333333d0 ) + 1 ) - & 3.16227766016838d0 * sqrt ( r ( jj ) * ( 0.00833333333333333d0 - & 0.00833333333333333d0 * tanh ( 0.033333333333333333d0 * r ( jj ) - & 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r ( jj ) - 0.033333333333333333d0 ) + 1 )) / r ( jj )) * ( & 0.792590998767432d0 * r ( jj ) - 0.390069245506146d0 * ( r ( jj ) - 0.1d0 ) ** 3 - & 0.529594344341616d0 * ( r ( jj ) - 0.1d0 ) ** 2 + 0.125d0 * tanh ( & 1 1.111111111111111d0 * r ( jj ) - 1 1.111111111111111d0 ) + & 0.920740900123257d0 ) + 2.0d0 * i * ( 0.125d0 * tanh ( 2 2.222222222222221d0 & * r ( jj ) - 2 2.222222222222221d0 ) + 1 ) / r ( jj ) - 0.705179774033115d0 * r ( jj ) + & 0.783533082259017d0 * ( r ( jj ) - 0.1d0 ) ** 2 + ( 3.0d0 * ( r ( jj ) * ( & 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( jj ) - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r ( jj ) - 0.033333333333333333d0 ) + & 1 )) ** 1.0d0 / r ( jj ) + 1.0d0 / r ( jj )) * ( 0.261177694086339d0 * ( r ( jj ) - 0.1d0 ) ** 3 - & 0.352589887016558d0 * ( r ( jj ) - 0.1d0 ) ** 2 + 0.125d0 * tanh ( & 1.1111111111111112d0 * r ( jj ) - 1.1111111111111112d0 ) + & 0.0951992694944706d0 ) - 0.138888888888889d0 * tanh ( & 1.1111111111111112d0 * r ( jj ) - 1.1111111111111112d0 ) ** 2 + & 0.2094068662922d0 END DO IF ( r ( 1 ). lt . 1 0e-12 ) THEN S_1 ( 1 ) = - i * ( 0.261177694086339d0 * ( r ( 1 ) - 0.1d0 ) ** 3 - 0.352589887016558d0 * ( r ( 1 ) - 0.1d0 ) & ** 2 + 0.125d0 * tanh ( 1.1111111111111112d0 * r ( 1 ) - 1.1111111111111112d0 & ) + 0.0951992694944706d0 ) * ( - 0.025d0 * tanh ( 5 5.555555555555557d0 * r ( 1 ) - & 5 5.555555555555557d0 ) - 0.2d0 + 1.0d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 1 ) - & 3.16227766016838d0 * sqrt ( r ( 1 ) * ( 0.00833333333333333d0 - & 0.00833333333333333d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 1 )) * ( 0.125d0 & * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 1 ) ** & 1.0d0 * ( 0.5d0 * r ( 1 ) * ( 0.00833333333333333d0 - 0.00833333333333333d0 * & tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ) * ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + & 1 ) ** ( - 2.0d0 ) * ( 0.00416666666666667d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) & - 0.033333333333333333d0 ) ** 2 - 0.00416666666666667d0 ) - & 0.00416666666666667d0 * r ( 1 ) * ( 0.0666666666666667d0 - & 0.0666666666666667d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 1 ) * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 0.5d0 * ( & 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + & 1 )) / ( r ( 1 ) * ( 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ))) - & 1.05918868868323d0 * r ( 1 ) - 1.17020773651844d0 * ( r ( 1 ) - 0.1d0 ) ** 2 - & 1.38888888888889d0 * tanh ( 1 1.111111111111111d0 * r ( 1 ) - & 1 1.111111111111111d0 ) ** 2 + 2.28739875652464d0 - & 3.16227766016838d0 * sqrt ( r ( 1 ) * ( 0.00833333333333333d0 - & 0.00833333333333333d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 1 )) * ( 0.125d0 & * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 1 ) ** & 1.0d0 * ( 0.125d0 * tanh ( 2 2.222222222222221d0 * r ( 1 ) - 2 2.222222222222221d0 & ) + 1 ) * ( 0.5d0 * r ( 1 ) * ( 0.00833333333333333d0 - 0.00833333333333333d0 * & tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ) * ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + & 1 ) ** ( - 2.0d0 ) * ( 0.00416666666666667d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) & - 0.033333333333333333d0 ) ** 2 - 0.00416666666666667d0 ) - & 0.00416666666666667d0 * r ( 1 ) * ( 0.0666666666666667d0 - & 0.0666666666666667d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 1 ) * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 0.5d0 * ( & 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + & 1 )) / ( r ( 1 ) * ( 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 )) + 2.0d0 * ( & r ( 1 ) * ( 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + & 1 )) ** 1.0d0 * ( 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) + 1 ) ** 1.0d0 * ( 0.5d0 * r ( 1 ) * ( & 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ) * ( 0.125d0 * & tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 1 ) ** ( & - 2.0d0 ) * ( 0.00416666666666667d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) ** 2 - 0.00416666666666667d0 ) - & 0.00416666666666667d0 * r ( 1 ) * ( 0.0666666666666667d0 - & 0.0666666666666667d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 1 ) * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 0.5d0 * ( & 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + & 1 )) * ( 0.792590998767432d0 * r ( 1 ) - 0.390069245506146d0 * ( r ( 1 ) - 0.1d0 ) ** 3 - & 0.529594344341616d0 * ( r ( 1 ) - 0.1d0 ) ** 2 + 0.125d0 * tanh ( & 1 1.111111111111111d0 * r ( 1 ) - 1 1.111111111111111d0 ) + & 0.920740900123257d0 ) / ( r ( 1 ) * ( 0.00833333333333333d0 - & 0.00833333333333333d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) ** 2 )) S_2 ( 1 ) = - i * ( 0.125d0 * tanh ( 2 2.222222222222221d0 * r ( 1 ) - 2 2.222222222222221d0 ) + 1 ) * ( & - 0.025d0 * tanh ( 5 5.555555555555557d0 * r ( 1 ) - 5 5.555555555555557d0 ) - & 0.2d0 + 1.0d0 / ( 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) + 1 ) - 3.16227766016838d0 * sqrt ( r ( 1 ) * ( & 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + & 1 )) * ( 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) + 1 ) ** 1.0d0 * ( 0.5d0 * r ( 1 ) * ( & 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ) * ( 0.125d0 * & tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 1 ) ** ( & - 2.0d0 ) * ( 0.00416666666666667d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) ** 2 - 0.00416666666666667d0 ) - & 0.00416666666666667d0 * r ( 1 ) * ( 0.0666666666666667d0 - & 0.0666666666666667d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 1 ) * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 0.5d0 * ( & 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + & 1 )) / ( r ( 1 ) * ( 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ))) + ( & 1.58113883008419d0 * sqrt ( r ( 1 ) * ( 0.00833333333333333d0 - & 0.00833333333333333d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 1 )) * ( 1.5d0 * ( & r ( 1 ) * ( 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + & 1 )) ** 1.0d0 + 1 ) * ( 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) + 1 ) ** 1.0d0 * ( 0.5d0 * r ( 1 ) * ( & 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ) * ( 0.125d0 * & tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 1 ) ** ( & - 2.0d0 ) * ( 0.00416666666666667d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) ** 2 - 0.00416666666666667d0 ) - & 0.00416666666666667d0 * r ( 1 ) * ( 0.0666666666666667d0 - & 0.0666666666666667d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 1 ) * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 0.5d0 * ( & 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + & 1 )) / ( r ( 1 ) * ( 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 )) + & 1.58113883008419d0 * sqrt ( r ( 1 ) * ( 0.00833333333333333d0 - & 0.00833333333333333d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 1 )) * ( 0.125d0 & * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 1 ) ** & 1.0d0 * ( 0.5d0 * r ( 1 ) * ( 0.00833333333333333d0 - 0.00833333333333333d0 * & tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ) * ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + & 1 ) ** ( - 2.0d0 ) * ( 0.00416666666666667d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) & - 0.033333333333333333d0 ) ** 2 - 0.00416666666666667d0 ) - & 0.00416666666666667d0 * r ( 1 ) * ( 0.0666666666666667d0 - & 0.0666666666666667d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 1 ) * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 0.5d0 * ( & 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + & 1 )) / ( r ( 1 ) * ( 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ))) * ( & 0.261177694086339d0 * ( r ( 1 ) - 0.1d0 ) ** 3 - 0.352589887016558d0 * ( r ( 1 ) - & 0.1d0 ) ** 2 + 0.125d0 * tanh ( 1.1111111111111112d0 * r ( 1 ) - & 1.1111111111111112d0 ) + 0.0951992694944706d0 ) S_3 ( 1 ) = - i * ( 0.125d0 * tanh ( 2 2.222222222222221d0 * r ( 1 ) - 2 2.222222222222221d0 ) + 1 ) * ( & - 0.025d0 * tanh ( 5 5.555555555555557d0 * r ( 1 ) - 5 5.555555555555557d0 ) - & 0.2d0 + 1.0d0 / ( 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) + 1 ) - 3.16227766016838d0 * sqrt ( r ( 1 ) * ( & 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + & 1 )) * ( 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) + 1 ) ** 1.0d0 * ( 0.5d0 * r ( 1 ) * ( & 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ) * ( 0.125d0 * & tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 1 ) ** ( & - 2.0d0 ) * ( 0.00416666666666667d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) ** 2 - 0.00416666666666667d0 ) - & 0.00416666666666667d0 * r ( 1 ) * ( 0.0666666666666667d0 - & 0.0666666666666667d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 1 ) * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 0.5d0 * ( & 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + & 1 )) / ( r ( 1 ) * ( 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ))) + 1.0d0 * & i * ( 0.792590998767432d0 * r ( 1 ) - 0.390069245506146d0 * ( r ( 1 ) - 0.1d0 ) ** 3 - & 0.529594344341616d0 * ( r ( 1 ) - 0.1d0 ) ** 2 + 0.125d0 * tanh ( & 1 1.111111111111111d0 * r ( 1 ) - 1 1.111111111111111d0 ) + & 0.920740900123257d0 ) + ( 0.316227766016838d0 * sqrt ( r ( 1 ) * ( & 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + & 1 )) * ( 1.38888888888889d0 - 1.38888888888889d0 * tanh ( & 5 5.555555555555557d0 * r ( 1 ) - 5 5.555555555555557d0 ) ** 2 ) - & 1.38888888888889d0 * tanh ( 5 5.555555555555557d0 * r ( 1 ) - & 5 5.555555555555557d0 ) ** 2 + 1.38888888888889d0 + & 0.632455532033676d0 * sqrt ( r ( 1 ) * ( 0.00833333333333333d0 - & 0.00833333333333333d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 1 )) * ( 0.125d0 & * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 1 ) ** & 1.0d0 * ( 0.025d0 * tanh ( 5 5.555555555555557d0 * r ( 1 ) - 5 5.555555555555557d0 & ) + 0.2d0 ) * ( 0.5d0 * r ( 1 ) * ( 0.00833333333333333d0 - & 0.00833333333333333d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) ** 2 ) * ( 0.125d0 * tanh ( 0.033333333333333333d0 * & r ( 1 ) - 0.033333333333333333d0 ) + 1 ) ** ( - 2.0d0 ) * ( 0.00416666666666667d0 & * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 - & 0.00416666666666667d0 ) - 0.00416666666666667d0 * r ( 1 ) * ( & 0.0666666666666667d0 - 0.0666666666666667d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + & 1 ) * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + & 0.5d0 * ( 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + & 1 )) / ( r ( 1 ) * ( 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ))) * ( & 0.261177694086339d0 * ( r ( 1 ) - 0.1d0 ) ** 3 - 0.352589887016558d0 * ( r ( 1 ) - & 0.1d0 ) ** 2 + 0.125d0 * tanh ( 1.1111111111111112d0 * r ( 1 ) - & 1.1111111111111112d0 ) + 0.0951992694944706d0 ) S_4 ( 1 ) = - i * ( 0.125d0 * tanh ( 2 2.222222222222221d0 * r ( 1 ) - 2 2.222222222222221d0 ) + 1 ) * ( & - 0.025d0 * tanh ( 5 5.555555555555557d0 * r ( 1 ) - 5 5.555555555555557d0 ) - & 0.2d0 + 1.0d0 / ( 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) + 1 ) - 3.16227766016838d0 * sqrt ( r ( 1 ) * ( & 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + & 1 )) * ( 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) + 1 ) ** 1.0d0 * ( 0.5d0 * r ( 1 ) * ( & 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ) * ( 0.125d0 * & tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 1 ) ** ( & - 2.0d0 ) * ( 0.00416666666666667d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) ** 2 - 0.00416666666666667d0 ) - & 0.00416666666666667d0 * r ( 1 ) * ( 0.0666666666666667d0 - & 0.0666666666666667d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 1 ) * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 0.5d0 * ( & 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + & 1 )) / ( r ( 1 ) * ( 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ))) + 1.0d0 * & i * ( 0.792590998767432d0 * r ( 1 ) - 0.390069245506146d0 * ( r ( 1 ) - 0.1d0 ) ** 3 - & 0.529594344341616d0 * ( r ( 1 ) - 0.1d0 ) ** 2 + 0.125d0 * tanh ( & 1 1.111111111111111d0 * r ( 1 ) - 1 1.111111111111111d0 ) + & 0.920740900123257d0 ) + ( 0.316227766016838d0 * sqrt ( r ( 1 ) * ( & 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + & 1 )) * ( 1.38888888888889d0 - 1.38888888888889d0 * tanh ( & 5 5.555555555555557d0 * r ( 1 ) - 5 5.555555555555557d0 ) ** 2 ) - & 1.38888888888889d0 * tanh ( 5 5.555555555555557d0 * r ( 1 ) - & 5 5.555555555555557d0 ) ** 2 + 1.38888888888889d0 + & 0.632455532033676d0 * sqrt ( r ( 1 ) * ( 0.00833333333333333d0 - & 0.00833333333333333d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 1 )) * ( 0.125d0 & * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + 1 ) ** & 1.0d0 * ( 0.025d0 * tanh ( 5 5.555555555555557d0 * r ( 1 ) - 5 5.555555555555557d0 & ) + 0.2d0 ) * ( 0.5d0 * r ( 1 ) * ( 0.00833333333333333d0 - & 0.00833333333333333d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - & 0.033333333333333333d0 ) ** 2 ) * ( 0.125d0 * tanh ( 0.033333333333333333d0 * & r ( 1 ) - 0.033333333333333333d0 ) + 1 ) ** ( - 2.0d0 ) * ( 0.00416666666666667d0 & * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 - & 0.00416666666666667d0 ) - 0.00416666666666667d0 * r ( 1 ) * ( & 0.0666666666666667d0 - 0.0666666666666667d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + & 1 ) * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + & 0.5d0 * ( 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) + & 1 )) / ( r ( 1 ) * ( 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r ( 1 ) - 0.033333333333333333d0 ) ** 2 ))) * ( & 0.261177694086339d0 * ( r ( 1 ) - 0.1d0 ) ** 3 - 0.352589887016558d0 * ( r ( 1 ) - & 0.1d0 ) ** 2 + 0.125d0 * tanh ( 1.1111111111111112d0 * r ( 1 ) - & 1.1111111111111112d0 ) + 0.0951992694944706d0 ) WRITE ( 0 , * ) 'rad is 0' ELSE ENDIF END SUBROUTINE SourceCalc","tags":"","loc":"sourcefile/sourcetermmms.f90.html"},{"title":"analysisModule.f90 – Fortran Program","text":"Contents Modules analysisModule Source Code analysisModule.f90 Source Code MODULE analysisModule USE , INTRINSIC :: ISO_FORTRAN_ENV USE F90_ZGGEV IMPLICIT NONE PRIVATE PUBLIC :: analysis INTERFACE analysis MODULE PROCEDURE analysis1 END INTERFACE INTEGER , PARAMETER :: rDef = REAL64 CONTAINS subroutine analysis1 (& np ,& np4 , & ak , & rr , & snd , & rmx , & rmt , & aa , & bb , & alpha , & beta , & vl , & vr , & work , & rwork , & gam , & jobvl , & jobvr , & mm , & ir , & is , & vphi , & akap ) INTEGER , INTENT ( IN ) :: & np , & np4 , & mm , & ir , & is REAL ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: & rr , & snd , & rmx , & rmt , & rwork REAL ( KIND = rDef ), DIMENSION (:), INTENT ( OUT ) :: & akap COMPLEX ( KIND = rDef ), INTENT ( IN ) :: & ak ! axial wavenumber COMPLEX ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: & alpha , & beta , & work COMPLEX ( KIND = rDef ), DIMENSION (:), INTENT ( OUT ) :: & gam , & vphi COMPLEX ( KIND = rDef ), DIMENSION (:,:), INTENT ( IN ) :: & aa , & bb , & VL , & VR CHARACTER , INTENT ( IN ) :: & jobvl , & jobvr ! define local variables LOGICAL :: & badcol , & badrow LOGICAL , DIMENSION ( np4 ) :: & col , & row COMPLEX ( KIND = rDef ) :: & c0 , & ci COMPLEX ( KIND = rDef ), DIMENSION ( np4 ) :: & cvct COMPLEX ( KIND = rDef ), DIMENSION ( np4 , np4 ) :: aa_before , bb_before INTEGER :: & i , & j , & k , & info , & nmax4 REAL ( KIND = rDef ) :: & as , & eps , & ! gamco, & r , & rm , & rs LOGICAL :: debug = . FALSE . ! !        INTEGER  :: & !            UNIT , & !            UNIT2 , & !            UNIT3 ! CHARACTER ( 10 ) :: & file_id CHARACTER ( 26 ) :: & file_name ci = CMPLX ( 0.0_rDef , 1.0_rDef , rDef ) eps = 1 0.e-4 !JS: is this sufficient ! Compute convected wavenumbers.  Store them in a file. do j = 1 , np ! get mean flow, i.e. . . rm = rmx ( j ) !axial ,. . . rs = rmt ( j ) !and tangential mach numbers +  ... as = snd ( j ) ! the speed of sound. r = rr ( j ) ! Don't forget, we need this data at each radial point! IF ( debug . eqv .. TRUE .) THEN WRITE ( 0 , * ) 'ak = ' , ak , ' Mt = ' , as , ' Mx = ' , rm ELSE ENDIF ! Check Convective wave number calculation ! what is 'as' is zero??? - JS IF ( ( rm . ne . 0.0_rDef ) . and .( r . gt . 0.0_rDef ) ) THEN cvct ( j ) = (& ak / CMPLX ( as , KIND = rDef ) & - CMPLX ( mm , KIND = rDef ) * CMPLX ( rs , KIND = rDef ) / CMPLX ( r , KIND = rDef )& )& / CMPLX ( rm , KIND = rDef ) ENDIF ENDDO file_name = '04-EVanalysis/cv.waves.dat' ! OPEN(NEWUNIT=UNIT,FILE=file_name) ! WRITE(UNIT,*) 'REAL ' , 'IMAG' DO j = 1 , np ! WRITE(UNIT,*) REAL(cvct(j),KIND=rDef), AIMAG(cvct(j)) IF ( debug ) THEN !                WRITE(0,19) cvct(j) ELSE ENDIF ENDDO IF ( debug ) THEN !WRITE(0,17) (cvct(j), j=1,np) ELSE ENDIF !17      FORMAT(1x,'Convected wavenumbers: ',/,8(f10.5)) !19      FORMAT(1x,2e15.5) ! CLOSE(UNIT) ! Check for zero rows and columns in A. badcol = . FALSE . DO j = 1 , np4 col ( j ) = . TRUE . DO k = 1 , np4 IF ( abs ( aa ( k , j )). gt . eps ) THEN col ( j ) = . false . ENDIF ENDDO ENDDO DO j = 1 , np4 IF ( col ( j )) THEN WRITE ( 0 , * ) j !WRITE(0,20) j badcol = . true . ENDIF ENDDO badrow = . false . DO k = 1 , np4 row ( k ) = . true . DO j = 1 , np4 IF ( abs ( aa ( k , j )). gt . eps ) then row ( j ) = . false . ENDIF ENDDO ENDDO do k = 1 , np4 if ( row ( k )) then ! WRITE(0,25) k WRITE ( 0 , * ) k badrow = . true . endif enddo ! if ( badrow . or . badcol ) return !20      format(1x,'Column ',i4,' contains all zeros.') !25      format(1x,'Row    ',i4,' contains all zeros.') nmax4 = np4 aa_before = aa bb_before = bb CALL USE_EIGENSOLVER (& JOBVL = JOBVL , & ! JOBVL JOBVR = JOBVR , & ! JOBVR N = np4 , & ! N A = aa , & ! A LDA = NMAX4 , & ! LDA B = bb , & ! B LDB = NMAX4 , & ! LDB ALPHA = ALPHA , & ! ALPHA BETA = BETA , & ! BETA VL = VL , & ! VL LDVL = NMAX4 , & ! LDVL VR = VR , & ! VR LDVR = NMAX4 , & ! LDVR WORK = WORK , & ! WORK LWORK = 2 * NMAX4 , & ! LWORK RWORK = RWORK , & ! RWORK INFO = INFO ) ! INFO IF (( INFO . EQ . 0 ). and .( debug . eqv .. TRUE .)) THEN WRITE ( 0 , * ) 'INFO = ' , INFO WRITE ( 0 , * ) 'EIGENSOLVER PASSED' ELSEIF (( INFO . EQ . 1 . or . INFO . LT . np4 ). and .( debug . eqv .. TRUE .)) THEN WRITE ( 0 , * ) 'EIGENSOLVER FAILED' WRITE ( 0 , * ) 'The QZ iteration. No eigenvectors are calculated' WRITE ( 0 , * ) 'But ALPHA(j) and BETA(j) should be correct for  ' WRITE ( 0 , * ) 'j = INFO + 1,...,N' ELSEIF (( INFO . LT . 0 ). and .( debug . eqv .. TRUE .)) THEN WRITE ( 0 , * ) 'INFO = ' , INFO WRITE ( 0 , * ) 'EIGENSOLVER FAILED' WRITE ( 0 , * ) 'if INFO = -i, the i-th argument had an illegal value.' ENDIF c0 = CMPLX ( 0.0_rDef , 0.0_rDef , rDef ) ! ! Compute cut-off wavenumber for uniform flow. ! getting -Werror=compare-reals error with the if statements ! if there is only axial flow, no shear or swirl, then... JS !  if ((ir.eq.1) .and. (slp.eq.0.0_rDef) .and. (is.eq.0)) then !      rm = rmx(1) !      gamco = REAL(ak,rDef)*rm/(rm*rm -1.0_rDef) !      WRITE(0,30) gamco !  endif ! 30      format(/,1x,'Cut-off wavenumber: ',e15.5,/) ! ! Print the gammas to the display. !        WRITE(0,500) !500     format(1x) ! !        WRITE(0,50) WRITE ( file_id , '(i0.4)' ) np !WRITE(0,50) ! OPEN(NEWUNIT=UNIT,FILE='04-EVanalysis/' //'gammas'//TRIM(ADJUSTL(file_id)) // '.dat') ! OPEN(NEWUNIT=UNIT2,FILE='04-EVanalysis/' //'gam'//TRIM(ADJUSTL(file_id)) // '.acc') ! OPEN(NEWUNIT=UNIT3,FILE='04-EVanalysis/' //'gammasOnly'//TRIM(ADJUSTL(file_id)) // '.dat') ! WRITE(UNIT2,50) ! WRITE(UNIT,55) do j = 1 , np4 !            WRITE(0,*) alpha(j),beta(j) if ( beta ( j ). ne . c0 ) then gam ( j ) = ci * alpha ( j ) / beta ( j ) if ( abs ( AIMAG ( gam ( j ))). lt . eps ) then gam ( j ) = CMPLX ( REAL ( gam ( j )), 0.0d0 , rDef ) elseif ( abs ( REAL ( gam ( j ))). lt . eps ) then gam ( j ) = CMPLX ( 0.0_rDef , AIMAG ( gam ( j )), KIND = rDef ) endif vphi ( j ) = ak / gam ( j ) ! WRITE(0,10) j,gam(j),gam(j)/ak,vphi(j) ! WRITE(UNIT ,12) j,gam(j),gam(j)/ak, vphi(j) ! WRITE(UNIT2,10) j,gam(j),gam(j)/ak,vphi(j) ! WRITE(UNIT3,*) REAL(gam(j)),AIMAG(gam(j)) endif enddo ! CLOSE(UNIT) ! CLOSE(UNIT2) ! CLOSE(UNIT3) ! !        iO j=1,np4 ! !            IF ( ((ABS(REAL(alpha(j))).LT.ABS(eps)) .or. & !                (ABS(AIMAG(alpha(j))).LT.ABS(eps)) ).and.& !                (debug.eqv..TRUE.)) THEN !                WRITE(0,*) 'Eigenvalue (',j,')',' is numerically infinite or undetermined' !                WRITE(0,*) 'ALPHA(',j,') = ', alpha(j) !                WRITE(0,*) 'BETA (',j,') = ', beta(j) !                !alpha(j) = CMPLX(0.0_rDef,0.0_rDef,KIND=rDef) !                ELSE IF ( ((ABS(REAL(beta(j))).LT.ABS(eps)) .or. & !                (ABS(AIMAG(beta(j))).LT.ABS(eps)) ).and.& !                    (debug.eqv..TRUE.)) THEN !                WRITE(0,*) 'Eigenvalue (',j,')',' is numerically infinite or undetermined' !                WRITE(0,*) 'ALPHA(',j,') = ', alpha(j) !                WRITE(0,*) 'BETA (',j,') = ', beta(j) !                !beta(j) = CMPLX(0.0_rDef,0.0_rDef,KIND=rDef) !                ELSE !                !WRITE(UNIT,*) j,alpha(j),beta(j) !                !  When imaginary part of complex number is zero then it is real number. !                ! thats why we can look at the real part of beta !                IF ( (REAL(beta(j),KIND=rDef).gt.0.0_rDef) .or. & !                    (REAL(beta(j),KIND=rDef).lt.0.0_rDef)) THEN !                    gam(j) = ci*alpha(j)/beta(j) ! ! !                    IF (abs(AIMAG(gam(j))).lt.eps) THEN ! !                        gam(j) = CMPLX(REAL(gam(j)),0.0d0,rDef) ! !                    ELSE ! !                        IF (debug) THEN !                            WRITE(0,*) 'Bad Eigenvalue at' , j !                        ELSE !                        ENDIF ! !                    ENDIF !                    vphi(j)  = ak/gam(j) ! !                    WRITE(UNIT,*) j,gam(j),gam(j)/ak,vphi(j) !                    IF (debug) THEN !                        WRITE(0,10) j,gam(j),gam(j)/ak,vphi(j) !                    ELSE !                    ENDIF !                ELSE ! !                    IF (debug) THEN !                        WRITE(0,*) 'Bad Eigenvalue at' , j !                    ELSE !                    ENDIF !                ENDIF !            ENDIF !        ENDDO !CLOSE(UNIT) !970  format(1x,i4,4e13.4) ! ! Print all the gammas to a file. !        rewind UNIT !        rewind UNIT2 !        rewind UNIT3 ! OPEN(NEWUNIT=UNIT2,FILE='04-EVanalysis/' //'gam'//TRIM(ADJUSTL(file_id)) // '.acc') ! WRITE(UNIT2,50) ! 50      format('#',3x,'j',7x,'Re{gam}',7x,'Im{gam}',6x,'Re{gam}/k', & !             6x,'Im{gam}/k',6x,'kappa') ! 55      format('#',3x,'j',10x,'Re{gam}',13x,'Im{gam}',11x,'Re{gam/ak}', & !             10x,'Im{gam/ak}',5x,'nz') DO i = 1 , np4 ! JS: if there is (linear shear) and (no slope) and (no swirl then) ... ! Note: this will never happen because we removed the swrl.input functionality if (( rmx ( 1 ). gt . 0.0_rDef ) . and . ( rmt ( 1 ). eq . 0.0_rDef )) then !if ((ir.eq.1) .and.  (is.eq.0)) then rm = rmx ( 1 ) !       akap(i) = (rm*rm -1.)*gam(i)*gam(i) & !          -2.*real(ak)*rm*gam(i) +real(ak)*real(ak) akap ( i ) = ( rm * rm - 1.0_rDef ) * REAL ( gam ( i ) * gam ( i ), rDef ) & - 2.0_rDef * REAL ( ak , rDef ) * rm * REAL ( gam ( i ), rDef ) & + REAL ( ak , rDef ) * REAL ( ak , rDef ) IF ( akap ( i ). gt . 0.0_rDef ) then akap ( i ) = SQRT ( akap ( i )) ! WRITE(UNIT2,10) i,gam(i),gam(i)/ak,vphi(i),akap(i) ELSE ! WRITE(UNIT2,10) i,gam(i),gam(i)/ak,vphi(i) ENDIF ! JS: if there is not linear shear and there is no swirl flag then proceed ENDIF ! because gam has blank entries (gives 1e-310 because previous loop omitted some entries) !WRITE(0 ,*) i!,gam(i),gam(i)/ak!, vphi(i) ENDDO ! 10      format(1x,i4,9e20.12) ! 12      format(1x,i4,6e20.12) ! CLOSE(UNIT2) !return end END MODULE analysisModule","tags":"","loc":"sourcefile/analysismodule.f90.html"},{"title":"fdrivsModule.f90 – Fortran Program","text":"Contents Modules fdrivsModule Source Code fdrivsModule.f90 Source Code MODULE fdrivsModule USE , INTRINSIC :: ISO_FORTRAN_ENV IMPLICIT NONE PRIVATE PUBLIC :: fdrivs INTERFACE fdrivs MODULE PROCEDURE fdrivs1 END INTERFACE fdrivs INTEGER , PARAMETER :: rDef = REAL64 CONTAINS subroutine fdrivs1 ( np , sig , dl1 , iorder , ed2 , ed4 ) INTEGER , INTENT ( IN ) :: np , & iorder REAL ( KIND = rDef ), INTENT ( IN ) :: sig , & ed2 , & ed4 REAL ( KIND = rDef ), DIMENSION (:,:), INTENT ( INOUT ) :: dl1 ! ! local variables ! INTEGER :: i , & j , & k REAL ( KIND = rDef ) :: coeff , & dr , & dx , & tot REAL ( KIND = rDef ), DIMENSION ( np , np ) :: dl2 , & dl4 ! !     implicit real*8 (a-h,o-z) !     parameter (NMAX = 128, NMAX4 = NMAX*4) !     dimension dl1(NMAX,NMAX),dl2(NMAX,NMAX),dl4(NMAX,NMAX) ! ! Compute array for finite differences. ! !JS: Zero out matricies do i = 1 , np do j = 1 , np dl1 ( i , j ) = 0.0_rDef enddo enddo if ( iorder . eq . 2 ) then dl1 ( 1 , 1 ) = - 2 5.0_rDef dl1 ( 1 , 2 ) = 4 8.0_rDef dl1 ( 1 , 3 ) = - 3 6.0_rDef dl1 ( 1 , 4 ) = 1 6.0_rDef dl1 ( 1 , 5 ) = - 3.0_rDef dl1 ( 2 , 1 ) = - 3.0_rDef dl1 ( 2 , 2 ) = - 1 0.0_rDef dl1 ( 2 , 3 ) = 1 8.0_rDef dl1 ( 2 , 4 ) = - 6.0_rDef dl1 ( 2 , 5 ) = 1.0_rDef do i = 3 , np - 2 dl1 ( i , i - 2 ) = 1.0_rDef dl1 ( i , i - 1 ) = - 8.0_rDef dl1 ( i , i ) = 0.0_rDef dl1 ( i , i + 1 ) = 8.0_rDef dl1 ( i , i + 2 ) = - 1.0_rDef enddo dl1 ( np - 1 , np - 4 ) = - 1.0_rDef dl1 ( np - 1 , np - 3 ) = 6.0_rDef dl1 ( np - 1 , np - 2 ) = - 1 8.0_rDef dl1 ( np - 1 , np - 1 ) = 1 0.0_rDef dl1 ( np - 1 , np ) = 3.0_rDef dl1 ( np , np - 4 ) = 3.0_rDef dl1 ( np , np - 3 ) = - 1 6.0_rDef dl1 ( np , np - 2 ) = 3 6.0_rDef dl1 ( np , np - 1 ) = - 4 8.0_rDef dl1 ( np , np ) = 2 5.0_rDef else dl1 ( 1 , 1 ) = - 3.0_rDef dl1 ( 1 , 2 ) = 4.0_rDef dl1 ( 1 , 3 ) = - 1.0_rDef dl1 ( np , np - 2 ) = 1.0_rDef dl1 ( np , np - 1 ) = - 4.0_rDef dl1 ( np , np ) = 3.0_rDef do i = 2 , np - 1 dl1 ( i , i - 1 ) = - 1.0_rDef dl1 ( i , i ) = 0.0_rDef dl1 ( i , i + 1 ) = 1.0_rDef ENDDO endif ! endif !     dl1(i,i-2) =  1.0_rDef !     dl1(i,i-1) = -8.0_rDef !     dl1(i,i)   =  0.0_rDef !     dl1(i,i+1) =  8.0_rDef !     dl1(i,i+2) = -1.0_rDef ! if (i.eq.1) then !     dl1(i,1) = -25.0_rDef !     dl1(i,2) =  48.0_rDef !     dl1(i,3) = -36.0_rDef !     dl1(i,4) =  16.0_rDef !     dl1(i,5) =  -3.0_rDef ! elseif (i.eq.2) then !     dl1(i,1) =  -3.0_rDef !     dl1(i,2) = -10.0_rDef !     dl1(i,3) =  18.0_rDef !     dl1(i,4) =  -6.0_rDef !     dl1(i,5) =   1.0_rDef ! elseif (i.eq.np-1) then !     dl1(i,np-4) =  -1.0_rDef !     dl1(i,np-3) =   6.0_rDef !     dl1(i,np-2) = -18.0_rDef !     dl1(i,np-1) =  10.0_rDef !     dl1(i,np)   =   3.0_rDef ! elseif (i.eq.np) then !     dl1(i,np-4) =   3.0_rDef !     dl1(i,np-3) = -16.0_rDef !     dl1(i,np-2) =  36.0_rDef !     dl1(i,np-1) = -48.0_rDef !     dl1(i,np)   =  25.0_rDef ! else !     dl1(i,i-2) =  1.0_rDef !     dl1(i,i-1) = -8.0_rDef !     dl1(i,i)   =  0.0_rDef !     dl1(i,i+1) =  8.0_rDef !     dl1(i,i+2) = -1.0_rDef ! endif ! else ! if (i.eq.1) then !     dl1(i,1) =  -3.0_rDef !     dl1(i,2) =   4.0_rDef !     dl1(i,3) =  -1.0_rDef ! elseif (i.eq.np) then !     dl1(i,np-2) =  1.0_rDef !     dl1(i,np-1) = -4.0_rDef !     dl1(i,np)   =  3.0_rDef ! else !     dl1(i,i-1) = -1.0_rDef !     dl1(i,i)   =  0.0_rDef !     dl1(i,i+1) =  1.0_rDef ! endif ! endif ! open(unit=15,file='deriv.matrix',status='unknown') ! rewind 15 ! do i = 1,np !     write(15,10) (dl1(i,j), j=1,np) ! enddo ! 10      format(1x,16f7.1) ! close(15) ! coeff = 0.50_rDef * ( 1.0_rDef - sig ) dx = 2.0_rDef / REAL ( np - 1 , rDef ) do j = 1 , np do i = 1 , np dr = coeff * dx if ( iorder . eq . 2 ) then dl1 ( i , j ) = dl1 ( i , j ) / ( 1 2.0_rDef * dr ) else dl1 ( i , j ) = dl1 ( i , j ) / ( 2.0_rDef * dr ) endif enddo enddo ! ! Compute 2nd and 4th derivative matrices. do k = 1 , np do j = 1 , np tot = 0.0_rDef do i = 1 , np tot = tot + dl1 ( k , i ) * dl1 ( i , j ) enddo dl2 ( k , j ) = tot enddo enddo do k = 1 , np do j = 1 , np tot = 0.0_rDef do i = 1 , np tot = tot + dl2 ( k , i ) * dl2 ( i , j ) enddo dl4 ( k , j ) = tot enddo enddo ! ! Correct 1st derivative matrix using 2nd and 4th order smoothing. do k = 1 , np do j = 1 , np dl1 ( k , j ) = dl1 ( k , j ) + ed2 * dl2 ( k , j ) + ed4 * dl4 ( k , j ) enddo enddo ! return end END MODULE fdrivsModule","tags":"","loc":"sourcefile/fdrivsmodule.f90.html"},{"title":"indexxModule.f90 – Fortran Program","text":"Contents Modules indexxModule Source Code indexxModule.f90 Source Code MODULE indexxModule USE , INTRINSIC :: ISO_FORTRAN_ENV IMPLICIT NONE PRIVATE PUBLIC :: indexx INTERFACE indexx MODULE PROCEDURE indexx1 END INTERFACE indexx INTEGER , PARAMETER :: rDef = REAL64 CONTAINS SUBROUTINE INDEXX1 ( N , ARRIN , INDX ) INTEGER , INTENT ( IN ) :: n REAL ( KIND = rDef ), DIMENSION (:), INTENT ( INOUT ) :: arrin INTEGER , DIMENSION (:), INTENT ( OUT ) :: indx ! local variables INTEGER :: j , & indxt , & l , & ir , & i REAL ( KIND = rDef ) :: q !     DIMENSION ARRIN(N),INDX(N) DO 11 J = 1 , N INDX ( J ) = J 11 CONTINUE IF ( N . EQ . 1 ) RETURN L = N / 2 + 1 IR = N 10 CONTINUE IF ( L . GT . 1 ) THEN L = L - 1 INDXT = INDX ( L ) Q = ARRIN ( INDXT ) ELSE INDXT = INDX ( IR ) Q = ARRIN ( INDXT ) INDX ( IR ) = INDX ( 1 ) IR = IR - 1 IF ( IR . EQ . 1 ) THEN INDX ( 1 ) = INDXT RETURN ENDIF ENDIF I = L J = L + L 20 IF ( J . LE . IR ) THEN IF ( J . LT . IR ) THEN IF ( ARRIN ( INDX ( J )). LT . ARRIN ( INDX ( J + 1 ))) J = J + 1 ENDIF IF ( Q . LT . ARRIN ( INDX ( J ))) THEN INDX ( I ) = INDX ( J ) I = J J = J + J ELSE J = IR + 1 ENDIF GO TO 20 ENDIF INDX ( I ) = INDXT GO TO 10 END END MODULE indexxModule","tags":"","loc":"sourcefile/indexxmodule.f90.html"},{"title":"swirlDataExport.f90 – Fortran Program","text":"Contents Source Code swirlDataExport.f90 Source Code ! used to export data for swirl WRITE ( file_id , '(i0.4)' ) numberOfGridPoints dir_name = '01-mean-flow/' file_name = TRIM ( dir_name ) // 'mean-flow-' // TRIM ( ADJUSTL ( file_id )) // '.dat' OPEN ( NEWUNIT = UNIT , FILE = TRIM ( file_name ) ) ! Write the resulting mean flow WRITE ( UNIT , * ) & 'radius' , 'M_x' , 'M_theta' , 'A_expected' , 'A_actual' DO i = 1 , numberOfGridPoints WRITE ( UNIT , * ) & rOut ( i ) , & axialMachDataMMSOut ( i ) , & thetaMachDataMMSOut ( i ) , & speedOfSoundMMS ( i ) , & SoundSpeedOut ( i ) IF ( debug ) THEN WRITE ( 0 , * ) & !FORMAT_MEAN_FLOW) & rOut ( i ) , & axialMachDataMMSOut ( i ) , & thetaMachDataMMSOut ( i ) , & speedOfSoundMMS ( i ) , & SoundSpeedOut ( i ) ELSE ENDIF ENDDO CLOSE ( UNIT ); dir_name = '02-linearized-perturbation-equations' file_name = TRIM ( dir_name ) // 'PerturbationVariables.dat' OPEN ( NEWUNIT = UNIT , FILE = TRIM ( file_name )) WRITE ( UNIT , * ) 'Radius' , 'vR' , 'vTh' , 'vX' , 'Pr' DO i = 1 , numberOfGridPoints WRITE ( UNIT , * ) r ( i ) , vR ( i ) , vTh ( i ) , vX ( i ), Pr ( i ) END DO CLOSE ( UNIT ); dir_name = '03-method-of-manufactured-solutions' file_name = TRIM ( dir_name ) // 'SoundSpeedError.dat' OPEN ( NEWUNIT = UNIT , FILE = TRIM ( file_name )) WRITE ( UNIT , * ) 'Grid Points' , 'Speed of Sound Error' DO i = 1 , numberOfGridPoints WRITE ( UNIT , * ) r ( i ) , SoundSpeedError ( i ) END DO CLOSE ( UNIT ); file_name = TRIM ( dir_name ) // 'SourceTermData1.dat' OPEN ( NEWUNIT = UNIT , FILE = TRIM ( file_name )) WRITE ( UNIT , * ) 'Grid Points' , 'S_Actual' , 'S_actual' , 'Source Term Error' DO i = 1 , numberOfGridPoints WRITE ( UNIT , * ) & i , & REAL ( S_MMS ( i ), KIND = rDef ), & REAL ( S_actual ( i ), KIND = rDef ) , & REAL ( S_error ( i ), KIND = rDef ) END DO CLOSE ( UNIT ); file_name = TRIM ( dir_name ) // 'SourceTermData2.dat' OPEN ( NEWUNIT = UNIT , FILE = TRIM ( file_name )) WRITE ( UNIT , * ) 'Grid Points' , 'S_Actual' , 'S_actual' , 'Source Term Error' DO i = numberOfGridPoints , numberOfGridPoints * 2 WRITE ( UNIT , * ) & i , & REAL ( S_MMS ( i ), KIND = rDef ), & REAL ( S_actual ( i ), KIND = rDef ) , & REAL ( S_error ( i ), KIND = rDef ) END DO CLOSE ( UNIT ); file_name = TRIM ( dir_name ) // 'SourceTermData3.dat' OPEN ( NEWUNIT = UNIT , FILE = TRIM ( file_name )) WRITE ( UNIT , * ) 'Grid Points' , 'S_Actual' , 'S_actual' , 'Source Term Error' DO i = numberOfGridPoints * 2 , numberOfGridPoints * 3 WRITE ( UNIT , * ) & i , & REAL ( S_MMS ( i ), KIND = rDef ), & REAL ( S_actual ( i ), KIND = rDef ) , & REAL ( S_error ( i ), KIND = rDef ) END DO CLOSE ( UNIT ); file_name = TRIM ( dir_name ) // 'SourceTermData4.dat' OPEN ( NEWUNIT = UNIT , FILE = TRIM ( file_name )) WRITE ( UNIT , * ) 'Grid Points' , 'S_Actual' , 'S_actual' , 'Source Term Error' DO i = numberOfGridPoints * 3 , numberOfGridPoints * 4 WRITE ( UNIT , * ) & i , & REAL ( S_MMS ( i ), KIND = rDef ), & REAL ( S_actual ( i ), KIND = rDef ) , & REAL ( S_error ( i ), KIND = rDef ) END DO CLOSE ( UNIT );","tags":"","loc":"sourcefile/swirldataexport.f90.html"},{"title":"SoundSpeedMMS.f90 – Fortran Program","text":"Contents Subroutines CalcSoundSpeed Source Code SoundSpeedMMS.f90 Source Code ! Returns M_theta and the corresponding sound speed as defined in ! SourceTermSymbolicSolver.ipynb SUBROUTINE CalcSoundSpeed (& r , & SoundSpeedExpected , & thetaMachData , & axialMachData ) REAL ( KIND = rDef ) , DIMENSION (:), INTENT ( INOUT ) :: & SoundSpeedExpected , thetaMachData , axialMachData REAL ( KIND = rDef ) , DIMENSION (:), INTENT ( IN ) :: & r ! Local variables INTEGER :: & numberOfGridPoints , i !, j numberOfGridPoints = SIZE ( SoundSpeedExpected ) DO i = 1 , numberOfGridPoints SoundSpeedExpected ( i ) = 0.125d0 * tanh ( 0.033333333333333333d0 * r ( i ) - 0.033333333333333333d0 ) + 1 thetaMachData ( i ) = 1.58113883008419d0 * sqrt ( r ( i ) * ( 0.00833333333333333d0 - 0.00833333333333333d0 & * tanh ( 0.033333333333333333d0 * r ( i ) - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / & ( 0.125d0 * tanh ( 0.033333333333333333d0 * r ( i ) - 0.033333333333333333d0 ) & + 1 )) axialMachData ( i ) = 0.025d0 * tanh ( 5 5.555555555555557d0 * r ( i ) - 5 5.555555555555557d0 ) + 0.2d0 END DO END SUBROUTINE CalcSoundSpeed","tags":"","loc":"sourcefile/soundspeedmms.f90.html"},{"title":"outputModule.f90 – Fortran Program","text":"Contents Modules outputModule Source Code outputModule.f90 Source Code MODULE outputModule USE , INTRINSIC :: ISO_FORTRAN_ENV USE indexxModule USE egvModule USE kapsubModule IMPLICIT NONE PRIVATE PUBLIC :: output INTERFACE output MODULE PROCEDURE output1 END INTERFACE INTEGER , PARAMETER :: rDef = REAL64 CONTAINS subroutine output1 ( np , np4 , mode , rho , omega , & egv , attenh , attend , rmx , drm , rmt , drt , snd , rr , wvn , vrm , vphi , is ) INTEGER , INTENT ( IN ) :: & ! myunit1, & ! myunit2, & np , & np4 , & mode , & is !, & icomp REAL ( KIND = rDef ), INTENT ( IN ) :: & rho !, & !ang!, & gam!swirl magn JS REAL ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: rmx , & drm , & rmt , & drt , & snd , & rr COMPLEX ( KIND = rDef ), INTENT ( IN ) :: omega , & attenh , & attend COMPLEX ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: wvn , & vphi COMPLEX ( KIND = rDef ), DIMENSION (:,:), INTENT ( IN ) :: vrm CHARACTER , INTENT ( IN ) :: egv CHARACTER ( 10 ) :: file_id ! ! local variables ! INTEGER :: & i , & ! icomp ,& j , & ! jj, & jtmp , & ! kk, & mumax !,& !, & UNIT12,UNIT14,UNIT16!, & n ! INTEGER, DIMENSION(np) :: mu INTEGER , DIMENSION ( np4 ) :: izeros , & indx REAL ( KIND = rDef ) :: eps , & pi , & cvcmin , & cvcmax , & r , & rx , & rt , & akx , & aim , & are , & val , & vold , & gam1a , & gam2a , & ! aki, & alm1 , & alm2 , & ! disc, & fac , & ! fn, & ! fn1, & gim1 , & gim2 , & ! rm, & ! rmav, & ! term, & ! tot, & as REAL ( KIND = rDef ), DIMENSION ( np4 ) :: phi , & azeros ! REAL(KIND=rDef), DIMENSION(np) :: akappa COMPLEX ( KIND = rDef ) :: ci , & cv , & gamma1 ! COMPLEX(KIND=rDef), DIMENSION(np) :: gam1, & !     gam2 ! ! !     implicit real*8 (a-h,o-z) !     parameter (NMAX = 128, NMAX4 = NMAX*4) ! !     parameter    (PI = 3.14159265358979324) !     dimension    rr(NMAX),izeros(1024),index(1024) !     dimension    rmx(NMAX),drm(NMAX),rmt(NMAX),drt(NMAX),snd(NMAX) !     dimension    nfile(32),mfile(32),akappa(NMAX) !     dimension    mu(NMAX),phi(NMAX) !     real*4       azeros(1024) !     complex*16   vrm(NMAX4,NMAX4),wvn(NMAX4),gamma,omega,cv,ci !     complex*16   vphi(NMAX4),attenh,attend,gam1(NMAX),gam2(NMAX) !     character    egv !     character*2  ff !     character*15 basen,basem ! ! Output files: !               output.dat : has everything. !               gam.nonconv: nonconvecting mode data. !               gam.non.acc: nonconvecting mode data with more digits of accuracy. !               gam.compare: compares the result from spectral and q3d methods. ! pi = 4.0_rDef * ATAN ( 1.0_rDef ) ci = CMPLX ( 0.0_rDef , 1.0_rDef , rDef ) eps = 1.e-8_rDef alm1 = - 10000 alm2 = - 10000 ! ! Output everything to an unformatted file. !        WRITE(0,*) 'omega = ',omega !         open(unit=12,             & !             file='04-EVanalysis/output.dat',  & !             form='unformatted') !         rewind(12) !         write(12) np,np4,mode,rho,omega,attenh,attend!ang,gam !         write(12) (wvn(i), i=1,np4) !         write(12) (rr(i), i=1,np) !         write(12) ((vrm(i,j), i=1,np4), j=1,np4) ! !      write(12) wvn ! !      write(12) vrm !         close(12) ! ! Compute range of convected wavenumbers. ! !drh: np == number of radial points ! cvcmin = 1.e+4_rDef cvcmax = - 1.e+4_rDef do i = 1 , np r = rr ( i ) rx = rmx ( i ) rt = rmt ( i ) as = snd ( i ) if ( r . lt . 1 0e-12_rDef ) then cv = ( omega / as - mode * rt ) / rx else ! WRITE(0,*) rx, r cv = ( omega / as - mode / r * rt ) / rx endif !            WRITE(0,*) cv if ( abs ( cv ). gt . cvcmax ) cvcmax = abs ( cv ) if ( abs ( cv ). lt . cvcmin ) cvcmin = abs ( cv ) enddo if ( cvcmin . ge . 0.0_rDef ) then cvcmin = cvcmin - eps else cvcmin = cvcmin + eps endif if ( cvcmax . ge . 0.0_rDef ) then cvcmax = cvcmax + eps else cvcmax = cvcmax - eps endif !WRITE(0,*) 'convection speed: ',cvcmin,cvcmax ! ! Compute number of zero crossings for nonconvected modes. do i = 1 , np4 !WRITE(0,*) i, wvn(i) gamma1 = wvn ( i ) akx = real ( gamma1 ) if ( akx . le . cvcmin . or . akx . ge . cvcmax ) then izeros ( i ) = 0 ! Calculate phase of the mode i aim = aimag ( vrm ( 3 * np + 1 , i )) are = real ( vrm ( 3 * np + 1 , i )) phi ( i ) = atan2 ( aim , are ) vold = real ( vrm ( 3 * np + 1 , i ) * exp ( - ci * phi ( i ))) do j = 3 * np + 2 , np4 val = real ( vrm ( j , i ) * exp ( - ci * phi ( i ))) if ( val * vold . lt . 0.0_rDef ) then izeros ( i ) = izeros ( i ) + 1 endif vold = val enddo elseif ( akx . eq . 0.0_rDef ) then izeros ( i ) = 100 else izeros ( i ) = 200 endif enddo ! ! Sort modes by number of zero crossings. do i = 1 , np4 azeros ( i ) = REAL ( izeros ( i ), rDef ) enddo CALL indexx ( n = np4 , & arrin = azeros , & indx = indx ) ! ! Sort nonconvected modes into upstream and downstream. eps = 1.e-3_rDef !     do j=1,np4 do j = 1 , np4 - 1 if ( izeros ( indx ( j )). eq . izeros ( indx ( j + 1 ))) then gam1a = real ( wvn ( indx ( j ))) gam2a = real ( wvn ( indx ( j + 1 ))) if ( gam2a . eq . 0.0_rDef ) then goto 1000 endif if ( abs ( gam1a / gam2a - 1.0_rDef ). lt . eps ) then gim1 = aimag ( wvn ( indx ( j ))) gim2 = aimag ( wvn ( indx ( j + 1 ))) if ( gim1 . lt . gim2 ) then jtmp = indx ( j ) indx ( j ) = indx ( j + 1 ) indx ( j + 1 ) = jtmp endif else if ( gam1a . eq . 0.0_rDef . or . gam2a . eq . 0.0_rDef ) then !print*, 'gam1a = ',gam1a,'  gam2a = ',gam2a IF ( gam1a == 0.0_rDef ) THEN alm1 = 0.0_rDef alm2 = 2.0_rDef * PI / gam2a END IF IF ( gam2a == 0.0_rDef ) THEN alm1 = 2.0_rDef * PI / gam1a alm2 = 0.0_rDef END IF else alm1 = 2.0_rDef * PI / gam1a alm2 = 2.0_rDef * PI / gam2a endif ! WRITE(6,*) 'alm1\\2 :' ,alm1, alm2 if ( abs ( alm1 ). lt . abs ( alm2 )) then jtmp = indx ( j ) indx ( j ) = indx ( j + 1 ) indx ( j + 1 ) = jtmp endif endif endif enddo 1000 continue CALL saveEGV (& np = np ,& vrm = vrm ,& rr = rr ) ! ! Eigenvector output. !$      ncols = np4/15 !$      do n = 1,ncols+1 !$       write(ff,'(i2.2)') n !$       nfile(n) = 25 +n !$       mfile(n) = 55 +n !$       basen    = 'postplot/egvre.' !$       basem    = 'postplot/egvim.' !$       open(unit=nfile(n),file=basen//ff,status='unknown') !$       open(unit=mfile(n),file=basem//ff,status='unknown') !$       rewind nfile(n) !$       rewind mfile(n) !$       write(nfile(n),5) np,mode,rho,omega,rmax,slp,ang,gam, !$     &    attenh,attend !$      enddo !$ 5    format('#',2i4,9e12.5) !$      if (egv .eq. 'V') then !$       do j=1,np !$        do n = 1,ncols+1 !$         nf  = nfile(n) !$         mf  = mfile(n) !$         mn  = (n -1)*15 +1 !$         mx  = n*15 !$         if (n.eq.ncols+1) then !$          mx = min(mx,np4) !$         endif !$         write(nf,500) rr(j),(real(vrm(j+3*np,k)), k=mn,mx) !$         write(mf,500) rr(j),(imag(vrm(j+3*np,k)), k=mn,mx) !$        enddo !$       enddo !$      endif !$ 500  format(16e12.3) !$      do n = 1,ncols !$       close(nfile(n)) !$       close(mfile(n)) !$      enddo ! WRITE ( file_id , '(i0.4)' ) np open ( unit = 14 , & file = '04-EVanalysis/gam.nonconv.' // TRIM ( ADJUSTL ( file_id )) ) open ( unit = 16 , & file = '04-EVanalysis/gam.nonconv_acc.' // TRIM ( ADJUSTL ( file_id )) ) rewind 14 rewind 16 write ( 14 , 40 ) write ( 16 , 42 ) 40 format ( '#' , 2 x , 'Re{gam}' , 6 x , 'Im{gam}' , 4 x , 'Re{gam/ak}' , & 3 x , 'Im{gam/ak}' , 2 x , 'nz' ) 42 format ( '#' , 2 x , 'Re{gam}' , 13 x , 'Im{gam}' , 11 x , 'Re{gam/ak}' , & 10 x , 'Im{gam/ak}' , 5 x , 'nz' ) do j = 1 , np4 gamma1 = wvn ( indx ( j )) fac = ( 1.0_rDef + rho ) / 2.0_rDef if ( izeros ( indx ( j )). lt . np - 4 ) then write ( 14 , 10 ) indx ( j ), gamma1 , gamma1 / omega , izeros ( indx ( j )) write ( 16 , 12 ) indx ( j ), gamma1 , gamma1 / omega , izeros ( indx ( j )) endif enddo 10 format ( 1 x , i4 , 4e13 . 5 , i4 ) 12 format ( 1 x , i4 , 4e20 . 12 , i4 ) close ( 14 ) close ( 16 ) ! mumax = int ( REAL ( np , rDef ) / PI ) ! took out gamma comparison JS ! icomp = 0 !if (icomp .eq. 1) then ! !           open(unit=15,            & !               file='gam.compare', & !               status='unknown') !           rewind 15 !           write(15,35) !5          format(4x,'i',18x,'gam_spec',32x,'gam_q3d',17x,'mu') ! ! Compute kappas. ! !      mumax = int(REAL(np,rDef)/PI) ! ! test -- don't we already have the kappas? !! !       CALL kappa(mm    = mode,  & !                  mumax = mumax, & !                  sig   = rho,   & !                  mu    = mu,    & !                  akap  = akappa) ! ! !! Compute average axial Mach number. !            tot = 0.0_rDef !            do n = 2,np !                fn1 = rmx(n-1) !                fn  = rmx(n) !                tot = tot +(fn1 +fn)*(rr(n) -rr(n-1)) !            enddo !            rmav = tot/(1.0_rDef -rho)/2.0_rDef !            rm   = rmav !            write(6,*) rmav !            do i = 1,mumax !                aki  = akappa(i) !        term = real(omega) -mode*ang !        disc = term*term +(rm*rm -1.0_rDef)*aki*aki !        if (disc .ge. 0.0_rDef) then !         gam1(i) = (rm*term +sqrt(disc))/(rm*rm -1.0_rDef) !         gam2(i) = (rm*term -sqrt(disc))/(rm*rm -1.0_rDef) !            else !         gam1(i) = (rm*term +ci*sqrt(-disc))/(rm*rm -1.0_rDef) !         gam2(i) = (rm*term -ci*sqrt(-disc))/(rm*rm -1.0_rDef) !            endif !            enddo !        endif !25  format(1x,i4,4e20.12,i4) ! !    do i = 1,2*np !        if (izeros(indx(i)).lt.mumax) then !            jj = (i +1)/2 !            kk = i/2 !            if (mod(i,2) .eq. 1) then !!                write(0,*) izeros(indx(i)),wvn(indx(i))!,gam2(jj) !                write(15,*) izeros(indx(i)),wvn(indx(i))!,gam2(jj) !            else !                write(15,*) izeros(indx(i)),wvn(indx(i)),mu(kk)! ,gam1(kk) !            endif !        endif !    enddo ! return WRITE ( 6 , * ) drm , drt , egv , is , vphi end subroutine END MODULE outputModule","tags":"","loc":"sourcefile/outputmodule.f90.html"},{"title":"boundaryModule.f90 – Fortran Program","text":"Contents Modules boundaryModule Source Code boundaryModule.f90 Source Code MODULE boundaryModule USE , INTRINSIC :: ISO_FORTRAN_ENV IMPLICIT NONE PRIVATE PUBLIC :: boundary INTERFACE boundary MODULE PROCEDURE boundary1 END INTERFACE INTEGER , PARAMETER :: rDef = REAL64 CONTAINS subroutine boundary1 ( np , sig , ak , etah , etad , rmx , rmt , dd , aa , bb ) INTEGER , INTENT ( IN ) :: np REAL ( KIND = rDef ), INTENT ( IN ) :: sig COMPLEX ( KIND = rDef ), INTENT ( IN ) :: ak , & etah , & etad REAL ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: rmx , & rmt REAL ( KIND = rDef ), DIMENSION (:,:), INTENT ( IN ) :: dd COMPLEX ( KIND = rDef ), DIMENSION (:,:), INTENT ( INOUT ) :: aa , & bb ! local variables INTEGER :: j REAL ( KIND = rDef ) :: eps , & etamag , & rmh , & rmd COMPLEX ( KIND = rDef ) :: ci ! !     implicit real*8 (a-h,o-z) !     parameter (NMAX = 128) ! !     real*8     dd(NMAX,NMAX),rmx(NMAX),rmt(NMAX) !     complex*16 aa(4*NMAX,4*NMAX),bb(4*NMAX,4*NMAX),etah,etad,ci,ak ! Boundary conditions. ci = CMPLX ( 0.0_rDef , 1.0_rDef , rDef ) eps = 1.e-4_rDef ! etamag = abs ( etah ) + abs ( etad ) ! is there a liner? ! go through these later. if ( etamag . gt . eps ) then rmh = sqrt ( rmx ( 1 ) * rmx ( 1 ) + rmt ( 1 ) * rmt ( 1 )) rmd = sqrt ( rmx ( np ) * rmx ( np ) + rmt ( np ) * rmt ( np )) aa ( np , np ) = ci * ak aa ( np , 2 * np ) = CMPLX ( 0.0_rDef , KIND = rDef ) do j = 1 , np aa ( np , 3 * np + j ) = CMPLX ( 0.0_rDef , KIND = rDef ) enddo aa ( np , 4 * np ) = - ci * ak * etad bb ( np , np ) = CMPLX ( 0.0_rDef , KIND = rDef ) bb ( np , 4 * np ) = etad * CMPLX ( rmd , KIND = rDef ) ! sig can only be greater than 0 if ( sig . gt . 0.0_rDef ) then aa ( 1 , 1 ) = - ci * ak aa ( 1 , np + 1 ) = CMPLX ( 0.0_rDef , KIND = rDef ) do j = 1 , np aa ( 1 , 3 * np + j ) = CMPLX ( 0.0_rDef , KIND = rDef ) enddo aa ( 1 , 3 * np + 1 ) = - ci * ak * etah bb ( 1 , 1 ) = CMPLX ( 0.0_rDef , KIND = rDef ) bb ( 1 , 3 * np + 1 ) = etah * CMPLX ( rmh , KIND = rDef ) endif else ! no liner; hard wall conditions !dp/dr = 0 at wall if ( sig . gt . 0.0_rDef ) then ! there is an inner wall : BC: v_r = 0 do j = 1 , np aa ( 1 , np + j ) = CMPLX ( 0.0_rDef , KIND = rDef ) ! v_r eqn at inner wall, v_th entries aa ( 1 , 3 * np + j ) = CMPLX ( 0.0_rDef , KIND = rDef ) ! v_r eqn at inner wall, p entries bb ( 1 , j ) = CMPLX ( 0.0_rDef , KIND = rDef ) ! v_r eqn at inner wall, v_r entries enddo endif do j = 1 , np ! outer wall : BC: v_r = 0 aa ( np , np + j ) = CMPLX ( 0.0_rDef , KIND = rDef ) ! v_r eqn at outer wall, v_th entries aa ( np , 3 * np + j ) = CMPLX ( 0.0_rDef , KIND = rDef ) ! v_r eqn at outer wall, p entries bb ( np , j ) = CMPLX ( 0.0_rDef , KIND = rDef ) ! v_r eqn at outer wall, v_r entries enddo endif ! return IF ( MAXVAL ( dd ) > 0.0_rDef ) CONTINUE end END MODULE boundaryModule","tags":"","loc":"sourcefile/boundarymodule.f90.html"},{"title":"inputModule.f90 – Fortran Program","text":"Contents Modules inputModule Source Code inputModule.f90 Source Code MODULE inputModule USE , INTRINSIC :: ISO_FORTRAN_ENV IMPLICIT NONE PRIVATE PUBLIC :: input INTERFACE input MODULE PROCEDURE input1 END INTERFACE input INTEGER , PARAMETER :: rDef = REAL64 CONTAINS subroutine input1 ( mode , np , np4 , rho , freq , ixp , nxp , irr , rxmax , slp , & iss , ang , gm , vlchar , vrchar , itst , etah , etad , irpt , ifdff , & eps2 , eps4 , icomp ) ! !     implicit real*8 (a-h,o-z) !     parameter (NMAX = 128, NMAX4 = NMAX*4) !     complex*16 etah,etad,freq !     character  vlchar,vrchar ! INTEGER , INTENT ( OUT ) :: mode , & np , & np4 , & ixp , & nxp , & irr , & iss , & itst , & irpt , & ifdff , & icomp REAL ( KIND = rDef ), INTENT ( OUT ) :: rho , & rxmax , & slp , & ang , & gm , & eps2 , & eps4 COMPLEX ( KIND = rDef ), INTENT ( OUT ) :: etah , & etad , & freq CHARACTER , INTENT ( OUT ) :: vlchar , & vrchar ! ! local variables ! INTEGER :: mm = 0 , & npts = 0 , & ix = 0 , & nx = 0 , & ir = 0 , & is = 0 , & itest = 0 , & irepeat = 0 , & ifd = 0 , & icmpr = 0 , & ichange = 0 REAL ( KIND = rDef ) :: sig = 0.0_rDef , & akre = 0.0_rDef , & akim = 0.0_rDef , & rmax = 0.0_rDef , & slope = 0.0_rDef , & angom = 0.0_rDef , & gam = 0.0_rDef , & etahr = 0.0_rDef , & etahi = 0.0_rDef , & etadr = 0.0_rDef , & etadi = 0.0_rDef , & ed2 = 0.0_rDef , & ed4 = 0.0_rDef , & etar = 0.0_rDef , & etai = 0.0_rDef ! ! define the NAMELIST for input (keeping from the original SWIRL code) ! ! adding a zero initialization in, which was NOT in the original ! NAMELIST / inputs / mm , & ! circumferential mode number npts , & ! number of radial mesh points sig , & ! hub-to-duct radius ratio akre , & ! real part of frequency akim , & ! imag part of frequency ix , & ! ? not in paper, and not actually used. nx , & ! ? not in paper, and not actually used. ir , & ! axial Mach number distribution flag rmax , & ! max axial Mach number slope , & ! slope of linear Mach distribution is , & ! swirl Mach number distribution flag angom , & ! magnitude of solid body swirl gam , & ! magnitude of free vortex swirl itest , & ! perform consistency test on selected modes? etahr , & ! real part of hub liner admittance etahi , & ! imag part of hub liner admittance etadr , & ! real part of duct liner admittance etadi , & ! imag part of duct liner admittance irepeat , & ! ? not in paper, and is not actually used. ifd , & ! use finite differences for derivatives flag ed2 , & ! second order smoothing for derivatives ed4 , & ! fourth order smoothing for derivatives icmpr ! compares result using another method (which doesn't work). ! OPEN ( UNIT = 16 , & FILE = 'input.data' , & FORM = 'FORMATTED' , & STATUS = 'UNKNOWN' ) read ( 16 , NML = INPUTS ) ! mode = mm np = npts rho = sig freq = CMPLX ( akre , akim , rDef ) ixp = ix nxp = nx irr = ir rxmax = rmax slp = slope iss = is ang = angom gm = gam itst = itest irpt = irepeat ifdff = ifd etah = CMPLX ( etahr , etahi , rDef ) etad = CMPLX ( etadr , etadi , rDef ) eps2 = ed2 eps4 = ed4 icomp = icmpr ! close ( 16 ) ! vlchar = 'N' vrchar = 'V' np4 = 4 * np ! goto 1000 ! write ( 6 , 10 ) 10 format ( 1 x , 'Please input mode, number of points, hub/duct,' , & ' and red. freq.' ) read ( 5 , * ) mode , np , rho , freq vlchar = 'N' vrchar = 'V' np4 = 4 * np write ( 6 , 20 ) 20 format ( 1 x , 'Please input ir.' / , 5 x , 'ir = 0: uniform' , / , 5 x , & 'ir = 1: linear shear' , / , 5 x , & 'ir = 2: read from mach.input' , / , 5 x , & 'ir = 3: uniform core + bl. of thickness delta' , / , 5 x , & 'ir = 4: uniform + linear b.l.s' , / , 5 x , & 'ir = 5: uniform + 1/7th power law b.l.s' , / , 5 x , & 'ir = 6: hyperbolic secant' , / , 5 x , & 'ir = 7: laminar mean flow, M(r) = M_0 (1-r&#94;2)' , / , 5 x , & 'ir = 8: wavy sinusoid; input M_max and M_min.' ) read ( 5 , * ) ir if ( ir . eq . 0 ) then write ( 6 , 35 ) read ( 5 , * ) rxmax slope = 0. elseif ( ir . eq . 1 ) then write ( 6 , 40 ) read ( 5 , * ) rxmax , slope elseif ( ir . eq . 3 ) then write ( 6 , 45 ) read ( 5 , * ) rxmax , slope elseif ( ir . eq . 4 ) then write ( 6 , 45 ) read ( 5 , * ) rxmax , slope elseif ( ir . eq . 5 ) then write ( 6 , 45 ) read ( 5 , * ) rxmax elseif ( ir . eq . 6 ) then write ( 6 , 55 ) read ( 5 , * ) rxmax , slope elseif ( ir . eq . 7 ) then write ( 6 , 50 ) read ( 5 , * ) rxmax elseif ( ir . eq . 8 ) then write ( 6 , 60 ) read ( 5 , * ) rxmax , slope endif write ( 6 , 100 ) 100 format ( 1 x , 'Please input is.' / , 5 x , 'is = 0: none' , / , 5 x , & 'is = 1: solid body swirl only' , / , 5 x , & 'is = 2: free vortex swirl only' , / , 5 x , & 'is = 3: both solid body and free vortex' , / , 5 x , & 'is = 4: read from swrl.input' ) read ( 5 , * ) is if ( is . eq . 1 ) then write ( 6 , 110 ) read ( 5 , * ) angom elseif ( is . eq . 2 ) then write ( 6 , 120 ) read ( 5 , * ) gam elseif ( is . eq . 3 ) then write ( 6 , 130 ) read ( 5 , * ) angom , gam endif write ( 6 , 25 ) 25 format ( 1 x , 'Please input real and imag parts of admittance.' ) read ( 5 , * ) etar , etai 35 format ( 1 x , 'Please input the axial Mach number.' ) 40 format ( 1 x , 'Please input max M and slope.' ) 45 format ( 1 x , 'Please input core M.' ) 50 format ( 1 x , 'Please input max axial M.' ) 55 format ( 1 x , 'Please input max M and half-width.' ) 60 format ( 1 x , 'Please input max M and min M.' ) 110 format ( 1 x , 'Please input angular velocity.' ) 120 format ( 1 x , 'Please input free vortex strength.' ) 130 format ( 1 x , 'Please input ang.vel. and vortex strength.' ) 1000 continue ! ! Echo input. write ( 6 , 30 ) np , mode , rho , freq , ir , rxmax , slope , is , angom , gam , & itest , etah , irepeat , etad , ifd , eps2 , eps4 , ixp , nxp , icomp 30 format ( / , 1 x , 'npts  = ' , i4 , / & , 1 x , 'mm    = ' , i4 , 3 x , 'r_H/r_D = ' , f10 . 6 , 3 x , 'k     = ' , & 2 f10 . 6 , / , 1 x , 'ir    = ' , i4 , 3 x , 'rmax    = ' , & f10 . 6 , 3 x , 'slope = ' , f10 . 6 , / , 1 x , 'is    = ' , i4 , 3 x , 'angom   = ' , & f10 . 6 , 3 x , 'gam   = ' , f10 . 6 , / , 1 x , 'it    = ' , i4 , 3 x , 'etah    =  (' , & f8 . 6 , ',' , f8 . 6 , ')' , / , 1 x , 'irpt  = ' , i4 , 3 x , & 'etad    =  (' , f8 . 6 , ',' , f8 . 6 , ')' , / , 1 x , 'ifdff = ' , i4 , 3 x , & 'ed2     = ' , f10 . 6 , 3 x , 'ed4   = ' , f10 . 6 , / , 1 x , 'ix    = ' , i4 , 3 x , & 'nx      = ' , i4 , 3 x , 'icmpr = ' , i4 ) ! ! the user _was_ able to change things; no more. ichange = 0 !     write(6,140) !140  format(1x,'Input 0 to continue,',/,               & !        1x,'      1 to change namelist entries, or',/, & !        1x,'      2 to show namelist entries.') 150 format ( 1 x , 'Input via &inputs &end.' ) ! the user _was_ able to change things; no more. !     read(5,*) ichange if ( ichange . eq . 0 ) then write ( 6 , 200 ) elseif ( ichange . eq . 2 ) then write ( 6 , NML = inputs ) goto 1000 elseif ( ichange . eq . 1 ) then write ( 6 , 150 ) read ( 5 , NML = inputs ) mode = mm np = npts rho = sig freq = CMPLX ( akre , akim , rDef ) ixp = ix nxp = nx irr = ir rxmax = rmax slp = slope iss = is ang = angom gm = gam itst = itest irpt = irepeat ifdff = ifd etah = CMPLX ( etahr , etahi , rDef ) etad = CMPLX ( etadr , etadi , rDef ) eps2 = ed2 eps4 = ed4 icomp = icmpr vlchar = 'N' vrchar = 'V' np4 = 4 * np goto 1000 endif 200 format ( 1 x , 'Continuing ...' ) ! return end END MODULE inputModule","tags":"","loc":"sourcefile/inputmodule.f90.html"},{"title":"Akima1D.f90 – Fortran Program","text":"Contents Modules Akima1D Source Code Akima1D.f90 Source Code MODULE Akima1D USE , INTRINSIC :: ISO_FORTRAN_ENV IMPLICIT NONE PRIVATE PUBLIC :: Akima433Interpolation , & Akima433CurveFit INTERFACE Akima433Interpolation MODULE PROCEDURE Akima433InterpolationSP MODULE PROCEDURE Akima433InterpolationDP END INTERFACE Akima433Interpolation INTERFACE Akima433CurveFit MODULE PROCEDURE Akima433CurveFitSP MODULE PROCEDURE Akima433CurveFitDP END INTERFACE Akima433CurveFit CONTAINS SUBROUTINE Akima433InterpolationDP ( inputDataLength , & xInputData , & yInputData , & outputDataLength , & xOutputData , & yOutputData ) INTEGER , INTENT ( IN ) :: inputDataLength , & outputDataLength REAL ( KIND = REAL64 ), DIMENSION (:), INTENT ( IN ) :: xInputData , & yInputData , & xOutputData REAL ( KIND = REAL64 ), DIMENSION (:), INTENT ( OUT ) :: yOutputData ! local variables INTEGER , PARAMETER :: stdOutput = 6 CALL INTRPLD ( stdOutput , & ! IU inputDataLength , & ! L xInputData , & ! X yInputData , & ! Y outputDataLength , & ! N xOutputData , & ! U yOutputData ) ! V RETURN END SUBROUTINE Akima433InterpolationDP SUBROUTINE Akima433InterpolationSP ( inputDataLength , & xInputData , & yInputData , & outputDataLength , & xOutputData , & yOutputData ) INTEGER , INTENT ( IN ) :: inputDataLength , & outputDataLength REAL ( KIND = REAL32 ), DIMENSION (:), INTENT ( IN ) :: xInputData , & yInputData , & xOutputData REAL ( KIND = REAL32 ), DIMENSION (:), INTENT ( OUT ) :: yOutputData ! local variables INTEGER , PARAMETER :: stdOutput = 6 CALL INTRPLS ( stdOutput , & ! IU inputDataLength , & ! L xInputData , & ! X yInputData , & ! Y outputDataLength , & ! N xOutputData , & ! U yOutputData ) ! V RETURN END SUBROUTINE Akima433InterpolationSP SUBROUTINE Akima433CurveFitDP ( inputDataLength , & functionHasMultipleValues , & xInputData , & yInputData , & numberOfSubintervals , & outputDataLength , & xOutputData , & yOutputData ) INTEGER , INTENT ( IN ) :: inputDataLength , & numberOfSubintervals , & outputDataLength LOGICAL , INTENT ( IN ) :: functionHasMultipleValues REAL ( KIND = REAL64 ), DIMENSION (:), INTENT ( IN ) :: xInputData , & yInputData , & xOutputData REAL ( KIND = REAL64 ), DIMENSION (:), INTENT ( OUT ) :: yOutputData ! local variables INTEGER , PARAMETER :: stdOutput = 6 INTEGER :: curveMode , expectedOutputDataLength IF ( functionHasMultipleValues ) THEN curveMode = 2 ELSE curveMode = 1 END IF ! error check expectedOutputDataLength = (( inputDataLength - 1 ) * numberOfSubintervals ) + 1 IF ( outputDataLength /= expectedOutputDataLength ) THEN WRITE ( stdOutput , * ) 'Error in Akima433CurveFit: ' WRITE ( stdOutput , * ) ' inputDataLength          = ' , inputDataLength WRITE ( stdOutput , * ) ' numberOfSubintervals     = ' , numberOfSubintervals WRITE ( stdOutput , * ) ' expectedOutputDataLength = ' , expectedOutputDataLength WRITE ( stdOutput , * ) ' actualOutputDataLength   = ' , outputDataLength STOP END IF CALL CRVFITD ( stdOutput , & ! IU curveMode , & ! MD inputDataLength , & ! L xInputData , & ! X yInputData , & ! Y numberOfSubintervals , & ! M outputDataLength , & ! N xOutputData , & ! U yOutputData ) ! V RETURN END SUBROUTINE Akima433CurveFitDP SUBROUTINE Akima433CurveFitSP ( inputDataLength , & functionHasMultipleValues , & xInputData , & yInputData , & numberOfSubintervals , & outputDataLength , & xOutputData , & yOutputData ) INTEGER , INTENT ( IN ) :: inputDataLength , & numberOfSubintervals , & outputDataLength LOGICAL , INTENT ( IN ) :: functionHasMultipleValues REAL ( KIND = REAL32 ), DIMENSION (:), INTENT ( IN ) :: xInputData , & yInputData , & xOutputData REAL ( KIND = REAL32 ), DIMENSION (:), INTENT ( OUT ) :: yOutputData ! local variables INTEGER , PARAMETER :: stdOutput = 6 INTEGER :: curveMode , expectedOutputDataLength IF ( functionHasMultipleValues ) THEN curveMode = 2 ELSE curveMode = 1 END IF ! error check expectedOutputDataLength = (( inputDataLength - 1 ) * numberOfSubintervals ) + 1 IF ( outputDataLength /= expectedOutputDataLength ) THEN WRITE ( stdOutput , * ) 'Error in Akima433CurveFit: ' WRITE ( stdOutput , * ) ' inputDataLength          = ' , inputDataLength WRITE ( stdOutput , * ) ' numberOfSubintervals     = ' , numberOfSubintervals WRITE ( stdOutput , * ) ' expectedOutputDataLength = ' , expectedOutputDataLength WRITE ( stdOutput , * ) ' actualOutputDataLength   = ' , outputDataLength STOP END IF CALL CRVFITS ( stdOutput , & ! IU curveMode , & ! MD inputDataLength , & ! L xInputData , & ! X yInputData , & ! Y numberOfSubintervals , & ! M outputDataLength , & ! N xOutputData , & ! U yOutputData ) ! V RETURN END SUBROUTINE Akima433CurveFitSP END MODULE Akima1D","tags":"","loc":"sourcefile/akima1d.f90.html"},{"title":"mmsClassObject.f90 – Fortran Program","text":"Contents Modules mmsClassObject Source Code mmsClassObject.f90 Source Code MODULE mmsClassObject USE , INTRINSIC :: ISO_FORTRAN_ENV IMPLICIT NONE PRIVATE PUBLIC :: getRateOfConvergence , getL2Norm , mmsClassType INTERFACE getL2Norm MODULE PROCEDURE L2N MODULE PROCEDURE L2N_One_Dataset MODULE PROCEDURE L2N_One_Dataset_Complex MODULE PROCEDURE L2N_COMPLEX MODULE PROCEDURE L2N_2D END INTERFACE INTERFACE getLMax MODULE PROCEDURE LMax END INTERFACE getLMax INTERFACE getRateOfConvergence MODULE PROCEDURE getROC MODULE PROCEDURE getROC_Complex END INTERFACE getRateOfConvergence !    INTERFACE getLMax !        MODULE PROCEDURE LMax !    END INTERFACE getLMax INTEGER , PARAMETER :: rDef = REAL64 INTEGER :: i REAL ( KIND = rDef ) :: tolerance = 1 0e-11_rDef TYPE mmsClassType PRIVATE LOGICAL :: & isInitialized = . FALSE . ! flag to identify if object exists REAL ( KIND = rDef ) :: & L2 REAL ( KIND = rDef ), DIMENSION (:) , ALLOCATABLE :: & dataSet , & dataSet1 ,& dataSet2 ,& RateOfConvergence , L2Array REAL ( KIND = rDef ), DIMENSION (:,:) , ALLOCATABLE :: & TwoDdataSet1 , & TwoDdataSet2 END TYPE mmsClassType CONTAINS SUBROUTINE L2N (& object ,& L2 ,& dataSet1 ,& dataSet2 ) TYPE ( mmsClassType ) , INTENT ( INOUT ) :: & object REAL ( KIND = rDef ), INTENT ( INOUT ) :: L2 REAL ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: dataSet1 ,& dataSet2 ! INTEGER, INTENT(INOUT) :: numPoints !Local variables within submodule only INTEGER :: numPoints REAL ( KIND = rDef ) :: dataSum REAL ( KIND = rDef ), DIMENSION (:), ALLOCATABLE :: & dataError ,& dataErrorSquared ! Sending INTENT(IN)'s to Derived Data TYPE . . . object % dataSet1 = dataSet1 object % dataSet2 = dataSet2 numPoints = SIZE ( object % dataSet1 ) ALLOCATE ( dataError ( numPoints ), & dataErrorSquared ( numPoints )) dataSum = 0.0_rDef DO i = 1 , numPoints dataError ( i ) = ABS ( object % dataSet1 ( i ) - object % dataSet2 ( i )) dataErrorSquared ( i ) = dataError ( i ) ** 2 dataSum = dataSum + dataErrorSquared ( i ) ENDDO object % L2 = SQRT ( dataSum / REAL ( numPoints , rDef )) L2 = object % L2 DEALLOCATE ( dataError , dataErrorSquared ) !WRITE(6,*) L2 END SUBROUTINE L2N SUBROUTINE L2N_One_Dataset ( & object ,& L2 ,& dataSet ) TYPE ( mmsClassType ) , INTENT ( INOUT ) :: & object REAL ( KIND = rDef ), INTENT ( INOUT ) :: & L2 REAL ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: & dataSet !Local variables within submodule only INTEGER :: & numPoints REAL ( KIND = rDef ) :: & dataSum REAL ( KIND = rDef ), DIMENSION (:), ALLOCATABLE :: & dataError ,& dataErrorSquared object % dataSet = dataSet numPoints = SIZE ( object % dataSet ) ALLOCATE (& dataError ( numPoints ), & dataErrorSquared ( numPoints )) dataSum = 0.0_rDef DO i = 1 , numPoints dataError ( i ) = ABS ( object % dataSet ( i ) ) dataErrorSquared ( i ) = dataError ( i ) ** 2 dataSum = dataSum + dataErrorSquared ( i ) ENDDO object % L2 = SQRT ( dataSum / REAL ( numPoints , rDef )) L2 = object % L2 DEALLOCATE ( dataError , dataErrorSquared ) !WRITE(6,*) L2 END SUBROUTINE L2N_One_Dataset SUBROUTINE L2N_One_Dataset_Complex (& object ,& L2 ,& dataSet ) !lenDataSet = SIZE(dataSet) TYPE ( mmsClassType ) , INTENT ( INOUT ) :: & object ! INTEGER, INTENT(INOUT) :: numPoints COMPLEX ( KIND = rDef ), INTENT ( INOUT ) :: & L2 COMPLEX ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: & dataSet !Local variables within submodule only INTEGER :: & numPoints COMPLEX ( KIND = rDef ) :: & dataSum COMPLEX ( KIND = rDef ), DIMENSION (:), ALLOCATABLE :: & dataError ,& dataErrorSquared object % dataSet = dataSet numPoints = SIZE ( object % dataSet ) ALLOCATE (& dataError ( numPoints ), & dataErrorSquared ( numPoints )) dataSum = CMPLX ( 0.0_rDef , 0.0_rDef , rDef ) DO i = 1 , numPoints dataError ( i ) = ( CMPLX ( object % dataSet ( i ) , KIND = rDef )) dataErrorSquared ( i ) = dataError ( i ) ** 2 dataSum = dataSum + dataErrorSquared ( i ) ENDDO object % L2 = SQRT ( dataSum / CMPLX ( numPoints , KIND = rDef )) L2 = object % L2 DEALLOCATE ( dataError , dataErrorSquared ) !WRITE(6,*) L2 END SUBROUTINE L2N_One_Dataset_Complex SUBROUTINE L2N_COMPLEX ( & object ,& L2 ,& dataSet1 ,& dataSet2 ) !,& numPoints) TYPE ( mmsClassType ) , INTENT ( INOUT ) :: & object INTEGER :: & numPoints COMPLEX ( KIND = rDef ), INTENT ( INOUT ) :: L2 COMPLEX ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: dataSet1 ,& dataSet2 !Local variables within submodule only COMPLEX ( KIND = rDef ) :: dataSum COMPLEX ( KIND = rDef ), DIMENSION (:), ALLOCATABLE :: dataError ,& dataErrorSquared object % dataSet1 = dataSet1 object % dataSet2 = dataSet2 numPoints = SIZE ( object % dataSet1 ) ALLOCATE (& dataError ( numPoints ) , & dataErrorSquared ( numPoints )) dataSum = CMPLX ( 0.0 , 0.0 , rDef ) DO i = 1 , numPoints dataError ( i ) = CMPLX ( ABS ( object % dataSet1 ( i ) - object % dataSet2 ( i )), KIND = rDef ) dataErrorSquared ( i ) = dataError ( i ) ** 2 dataSum = dataSum + dataErrorSquared ( i ) ENDDO L2 = SQRT ( dataSum / CMPLX ( numPoints , KIND = rDef )) object % L2 = L2 DEALLOCATE ( dataError , dataErrorSquared ) END SUBROUTINE L2N_COMPLEX SUBROUTINE L2N_2D ( & object ,& L2 ,& dataSet1 ,& dataSet2 ,& numPoints ) ! This will calculare the L2 Norm of a 2D array that ! has (numPoints,numPoints) dimension TYPE ( mmsClassType ) , INTENT ( INOUT ) :: & object INTEGER :: j ! Index for the second dimension INTEGER , INTENT ( INOUT ) :: numPoints COMPLEX ( KIND = rDef ), INTENT ( INOUT ) :: & L2 COMPLEX ( KIND = rDef ), DIMENSION (:,:), INTENT ( IN ) :: & dataSet1 ,& dataSet2 !Local variables within submodule only REAL ( KIND = rDef ) :: dataSum REAL ( KIND = rDef ), DIMENSION ( numPoints , numPoints ) :: dataError ,& dataErrorSquared object % TwoDdataSet1 = dataSet1 object % TwoDdataSet2 = dataSet2 dataSum = 0.0_rDef DO i = 1 , numPoints DO j = 1 , numPoints dataError ( i , j ) = ABS ( object % TwoDdataSet1 ( i , j ) - object % TwoDdataSet2 ( i , j )) dataErrorSquared ( i , j ) = dataError ( i , j ) ** 2 dataSum = dataSum + dataErrorSquared ( i , j ) ENDDO ENDDO L2 = SQRT ( CMPLX ( dataSum , KIND = rDef ) & / CMPLX ( numPoints , KIND = rDef )) object % L2 = L2 ! WRITE(6,*) L2 END SUBROUTINE L2N_2D SUBROUTINE LMax ( & object , & LM , & dataSet ) TYPE ( mmsClassType ) , INTENT ( INOUT ) :: & object REAL ( KIND = rDef ), INTENT ( INOUT ) :: LM REAL ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: dataSet object % dataSet = dataSet LM = MAXVAL ( dataSet ) END SUBROUTINE LMax SUBROUTINE getROC (& object ,& ExpectedRateOfConvergence ,& RateOfConvergence ,& L2Array ) TYPE ( mmsClassType ) , INTENT ( INOUT ) :: & object REAL ( KIND = rDef ), INTENT ( IN ) :: & ExpectedRateOfConvergence REAL ( KIND = rDef ), DIMENSION (:), INTENT ( OUT ) :: & RateOfConvergence REAL ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: & L2Array INTEGER :: numberOfIterations , i numberOfIterations = SIZE ( RateOfConvergence ) object % L2Array = L2Array object % RateOfConvergence = RateOfConvergence DO i = 1 , numberOfIterations IF ( REAL ( L2Array ( i ), KIND = rDef ) < tolerance ) THEN ! WRITE(6,*) L2Array(i) WRITE ( 0 , * ) 'A numerical solution has converged, the L2 norm < 10e-11 on the ' , i + 1 , 'iteration' object % RateOfConvergence ( i ) = ExpectedRateOfConvergence object % L2Array ( i ) = 1 0e-10_rDef object % L2Array ( i + 1 ) = 1 0e-10_rDef ELSE object % RateOfConvergence ( i ) = & (& LOG (( object % L2Array ( i + 1 ))) - & LOG (( object % L2Array ( i )))& )& / & LOG ( 0.50_rDef ) ! change 0.5 so that way the grid spacing doesnt have to half as big between iterations JS ENDIF ENDDO RateOfConvergence = object % RateOfConvergence END SUBROUTINE getROC SUBROUTINE getROC_Complex (& object ,& RateOfConvergence ,& L2Array ) TYPE ( mmsClassType ) , INTENT ( INOUT ) :: & object REAL ( KIND = rDef ), DIMENSION (:), INTENT ( OUT ) :: & RateOfConvergence COMPLEX ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: & L2Array INTEGER :: numberOfIterations , i numberOfIterations = SIZE ( RateOfConvergence ) object % L2Array = L2Array object % RateOfConvergence = RateOfConvergence DO i = 1 , numberOfIterations IF ( REAL ( L2Array ( i ), KIND = rDef ) < tolerance ) THEN WRITE ( 0 , * ) 'The numerical solution is converged, the L2 norm has reached machine precision on the ' , i , 'iteration' ELSE ENDIF object % RateOfConvergence ( i ) = & (& LOG (( object % L2Array ( i + 1 ))) - & LOG (( object % L2Array ( i )))& )& / & LOG ( 0.50_rDef ) ! change 0.5 so that way the grid spacing doesnt have to half as big between iterations JS ENDDO RateOfConvergence = object % RateOfConvergence END SUBROUTINE getROC_Complex END MODULE mmsClassObject","tags":"","loc":"sourcefile/mmsclassobject.f90.html"},{"title":"SourceTermComponentsMMS.f90 – Fortran Program","text":"Contents Subroutines SourceCalcComponents Source Code SourceTermComponentsMMS.f90 Source Code ! gam - axial wavenumber t ! ak  - reduced frequency ! i - imaginary number SUBROUTINE SourceCalcComponents (& gam , & i , & ak , & m , & r , & S_1 , & S_2 , & S_3 , & S_4 , & S_A11 , & S_A12 , & S_A13 , & S_A14 , & S_A21 , & S_A22 , & S_A23 , & S_A24 , & S_A31 , & S_A32 , & S_A33 , & S_A34 , & S_A41 , & S_A42 , & S_A43 , & S_A44 , & S_B11 , & S_B12 , & S_B13 , & S_B14 , & S_B21 , & S_B22 , & S_B23 , & S_B24 , & S_B31 , & S_B32 , & S_B33 , & S_B34 , & S_B41 , & S_B42 , & S_B43 , & S_B44 ) INTEGER , INTENT ( IN ) :: m REAL ( KIND = rDef ) , INTENT ( IN ) :: r !REAL(KIND=rDef)   , DIMENSION(:), INTENT(IN) :: r_loc COMPLEX ( KIND = rDef ), INTENT ( IN ) :: i , gam , ak COMPLEX ( KIND = rDef ), INTENT ( INOUT ) :: & S_1 , S_2 , S_3 , S_4 , & S_A11 , & S_A12 , & S_A13 , & S_A14 , & S_A21 , & S_A22 , & S_A23 , & S_A24 , & S_A31 , & S_A32 , & S_A33 , & S_A34 , & S_A41 , & S_A42 , & S_A43 , & S_A44 , & S_B11 , & S_B12 , & S_B13 , & S_B14 , & S_B21 , & S_B22 , & S_B23 , & S_B24 , & S_B31 , & S_B32 , & S_B33 , & S_B34 , & S_B41 , & S_B42 , & S_B43 , & S_B44 ! Local variables S_A11 =- i * ( 1.0d0 / ( 0.125d0 * tanh ( 0.033333333333333333d0 * r - & 0.033333333333333333d0 ) + 1 ) - 3.16227766016838d0 * sqrt ( r * ( & 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r - 0.033333333333333333d0 ) + & 1 )) / r ) * ( 0.261177694086339d0 * ( r - 0.1d0 ) ** 3 - 0.352589887016558d0 * & ( r - 0.1d0 ) ** 2 + 0.125d0 * tanh ( 1.1111111111111112d0 * r - & 1.1111111111111112d0 ) + 0.0951992694944706d0 ) S_A12 =- 3.16227766016838d0 * sqrt ( r * ( 0.00833333333333333d0 - & 0.00833333333333333d0 * tanh ( 0.033333333333333333d0 * r - & 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r - 0.033333333333333333d0 ) + 1 )) * ( 0.125d0 & * tanh ( 2 2.222222222222221d0 * r - 2 2.222222222222221d0 ) + 1 ) / r S_A13 = 0 S_A14 = ( 1.0d0 * ( - 1.05918868868323d0 * r - 1.17020773651844d0 * ( r - 0.1d0 ) ** 2 - & 1.38888888888889d0 * tanh ( 1 1.111111111111111d0 * r - & 1 1.111111111111111d0 ) ** 2 + 2.28739875652464d0 ) / ( & 0.792590998767432d0 * r - 0.390069245506146d0 * ( r - 0.1d0 ) ** 3 - & 0.529594344341616d0 * ( r - 0.1d0 ) ** 2 + 0.125d0 * tanh ( & 1 1.111111111111111d0 * r - 1 1.111111111111111d0 ) + & 0.920740900123257d0 ) + 1.0d0 * ( r * ( 0.00833333333333333d0 - & 0.00833333333333333d0 * tanh ( 0.033333333333333333d0 * r - & 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r - 0.033333333333333333d0 ) + 1 )) ** 1.0d0 / r & ) * ( 0.792590998767432d0 * r - 0.390069245506146d0 * ( r - 0.1d0 ) ** 3 - & 0.529594344341616d0 * ( r - 0.1d0 ) ** 2 + 0.125d0 * tanh ( & 1 1.111111111111111d0 * r - 1 1.111111111111111d0 ) + & 0.920740900123257d0 ) S_A21 = ( 1.58113883008419d0 * sqrt ( r * ( 0.00833333333333333d0 - & 0.00833333333333333d0 * tanh ( 0.033333333333333333d0 * r - & 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r - 0.033333333333333333d0 ) + 1 )) / r + & 1.58113883008419d0 * sqrt ( r * ( 0.00833333333333333d0 - & 0.00833333333333333d0 * tanh ( 0.033333333333333333d0 * r - & 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r - 0.033333333333333333d0 ) + 1 )) * ( 0.125d0 & * tanh ( 0.033333333333333333d0 * r - 0.033333333333333333d0 ) + 1 ) ** & 1.0d0 * ( 0.5d0 * r * ( 0.00833333333333333d0 - 0.00833333333333333d0 * & tanh ( 0.033333333333333333d0 * r - 0.033333333333333333d0 ) ** 2 ) * ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r - 0.033333333333333333d0 ) + & 1 ) ** ( - 2.0d0 ) * ( 0.00416666666666667d0 * tanh ( 0.033333333333333333d0 * r & - 0.033333333333333333d0 ) ** 2 - 0.00416666666666667d0 ) - & 0.00416666666666667d0 * r * ( 0.0666666666666667d0 - & 0.0666666666666667d0 * tanh ( 0.033333333333333333d0 * r - & 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r - 0.033333333333333333d0 ) + 1 ) * tanh ( & 0.033333333333333333d0 * r - 0.033333333333333333d0 ) + 0.5d0 * ( & 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r - 0.033333333333333333d0 ) + & 1 )) / ( r * ( 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r - 0.033333333333333333d0 ) ** 2 )) + & 0.790569415042095d0 * ( r * ( 0.00833333333333333d0 - & 0.00833333333333333d0 * tanh ( 0.033333333333333333d0 * r - & 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r - 0.033333333333333333d0 ) + 1 )) ** 1.5d0 / r & ) * ( 0.261177694086339d0 * ( r - 0.1d0 ) ** 3 - 0.352589887016558d0 * ( r - & 0.1d0 ) ** 2 + 0.125d0 * tanh ( 1.1111111111111112d0 * r - & 1.1111111111111112d0 ) + 0.0951992694944706d0 ) S_A22 =- i * ( 1.0d0 / ( 0.125d0 * tanh ( 0.033333333333333333d0 * r - & 0.033333333333333333d0 ) + 1 ) - 3.16227766016838d0 * sqrt ( r * ( & 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r - 0.033333333333333333d0 ) + & 1 )) / r ) * ( 0.125d0 * tanh ( 2 2.222222222222221d0 * r - & 2 2.222222222222221d0 ) + 1 ) S_A23 = 0 S_A24 = 2.0d0 * i * ( 0.792590998767432d0 * r - 0.390069245506146d0 * ( r - 0.1d0 ) ** 3 - & 0.529594344341616d0 * ( r - 0.1d0 ) ** 2 + 0.125d0 * tanh ( & 1 1.111111111111111d0 * r - 1 1.111111111111111d0 ) + & 0.920740900123257d0 ) / r S_A31 = ( - 1.38888888888889d0 * tanh ( 5 5.555555555555557d0 * r - 5 5.555555555555557d0 ) & ** 2 + 1.38888888888889d0 + 0.5d0 * ( r * ( 0.00833333333333333d0 - & 0.00833333333333333d0 * tanh ( 0.033333333333333333d0 * r - & 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( 0.125d0 * tanh ( & 0.033333333333333333d0 * r - 0.033333333333333333d0 ) + 1 )) ** 1.0d0 * ( & 0.025d0 * tanh ( 5 5.555555555555557d0 * r - 5 5.555555555555557d0 ) + & 0.2d0 ) / r ) * ( 0.261177694086339d0 * ( r - 0.1d0 ) ** 3 - & 0.352589887016558d0 * ( r - 0.1d0 ) ** 2 + 0.125d0 * tanh ( & 1.1111111111111112d0 * r - 1.1111111111111112d0 ) + & 0.0951992694944706d0 ) S_A32 = 0 S_A33 =- i * ( 1.0d0 / ( 0.125d0 * tanh ( 0.033333333333333333d0 * r - & 0.033333333333333333d0 ) + 1 ) - 3.16227766016838d0 * sqrt ( r * ( & 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r - 0.033333333333333333d0 ) + & 1 )) / r ) * ( 0.125d0 * tanh ( 2 2.222222222222221d0 * r - & 2 2.222222222222221d0 ) + 1 ) S_A34 = 0 S_A41 = ( 1.0d0 * ( - 0.705179774033115d0 * r + 0.783533082259017d0 * ( r - 0.1d0 ) ** 2 - & 0.138888888888889d0 * tanh ( 1.1111111111111112d0 * r - & 1.1111111111111112d0 ) ** 2 + 0.2094068662922d0 ) / ( & 0.261177694086339d0 * ( r - 0.1d0 ) ** 3 - 0.352589887016558d0 * ( r - & 0.1d0 ) ** 2 + 0.125d0 * tanh ( 1.1111111111111112d0 * r - & 1.1111111111111112d0 ) + 0.0951992694944706d0 ) + 3.0d0 * ( r * ( & 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r - 0.033333333333333333d0 ) + & 1 )) ** 1.0d0 / r + 1.0d0 / r ) * ( 0.261177694086339d0 * ( r - 0.1d0 ) ** 3 - & 0.352589887016558d0 * ( r - 0.1d0 ) ** 2 + 0.125d0 * tanh ( & 1.1111111111111112d0 * r - 1.1111111111111112d0 ) + & 0.0951992694944706d0 ) S_A42 = 2.0d0 * i * ( 0.125d0 * tanh ( 2 2.222222222222221d0 * r - 2 2.222222222222221d0 ) + 1 & ) / r S_A43 = 0 S_A44 =- i * ( 1.0d0 / ( 0.125d0 * tanh ( 0.033333333333333333d0 * r - & 0.033333333333333333d0 ) + 1 ) - 3.16227766016838d0 * sqrt ( r * ( & 0.00833333333333333d0 - 0.00833333333333333d0 * tanh ( & 0.033333333333333333d0 * r - 0.033333333333333333d0 ) ** 2 ) * 1 d0 / ( & 0.125d0 * tanh ( 0.033333333333333333d0 * r - 0.033333333333333333d0 ) + & 1 )) / r ) * ( 0.792590998767432d0 * r - 0.390069245506146d0 * ( r - 0.1d0 ) ** & 3 - 0.529594344341616d0 * ( r - 0.1d0 ) ** 2 + 0.125d0 * tanh ( & 1 1.111111111111111d0 * r - 1 1.111111111111111d0 ) + & 0.920740900123257d0 ) S_B11 =- 1.0d0 * i * ( 0.025d0 * tanh ( 5 5.555555555555557d0 * r - 5 5.555555555555557d0 ) + & 0.2d0 ) * ( 0.261177694086339d0 * ( r - 0.1d0 ) ** 3 - 0.352589887016558d0 * & ( r - 0.1d0 ) ** 2 + 0.125d0 * tanh ( 1.1111111111111112d0 * r - & 1.1111111111111112d0 ) + 0.0951992694944706d0 ) S_B12 = 0 S_B13 = 0 S_B14 = 0 S_B21 = 0 S_B22 =- 1.0d0 * i * ( 0.125d0 * tanh ( 2 2.222222222222221d0 * r - 2 2.222222222222221d0 ) + & 1 ) * ( 0.025d0 * tanh ( 5 5.555555555555557d0 * r - 5 5.555555555555557d0 ) + & 0.2d0 ) S_B23 = 0 S_B24 = 0 S_B31 = 0 S_B32 = 0 S_B33 =- 1.0d0 * i * ( 0.125d0 * tanh ( 2 2.222222222222221d0 * r - 2 2.222222222222221d0 ) + & 1 ) * ( 0.025d0 * tanh ( 5 5.555555555555557d0 * r - 5 5.555555555555557d0 ) + & 0.2d0 ) S_B34 =- 1.0d0 * i * ( 0.792590998767432d0 * r - 0.390069245506146d0 * ( r - 0.1d0 ) ** 3 - & 0.529594344341616d0 * ( r - 0.1d0 ) ** 2 + 0.125d0 * tanh ( & 1 1.111111111111111d0 * r - 1 1.111111111111111d0 ) + & 0.920740900123257d0 ) S_B41 = 0 S_B42 = 0 S_B43 =- 1.0d0 * i * ( 0.125d0 * tanh ( 2 2.222222222222221d0 * r - 2 2.222222222222221d0 ) + & 1 ) S_B44 =- 1.0d0 * i * ( 0.025d0 * tanh ( 5 5.555555555555557d0 * r - 5 5.555555555555557d0 ) + & 0.2d0 ) * ( 0.792590998767432d0 * r - 0.390069245506146d0 * ( r - 0.1d0 ) ** & 3 - 0.529594344341616d0 * ( r - 0.1d0 ) ** 2 + 0.125d0 * tanh ( & 1 1.111111111111111d0 * r - 1 1.111111111111111d0 ) + & 0.920740900123257d0 ) S_1 = & S_A11 + & S_A12 + & S_A13 + & S_A14 - (& S_B11 + & S_B12 + & S_B13 + & S_B14 ) S_2 = & S_A21 + & S_A22 + & S_A23 + & S_A24 - (& S_B21 + & S_B22 + & S_B23 + & S_B24 ) S_3 = & S_A31 + & S_A32 + & S_A33 + & S_A34 - (& S_B31 + & S_B32 + & S_B33 + & S_B34 ) S_4 = & S_A41 + & S_A42 + & S_A43 + & S_A44 - (& S_B41 + & S_B42 + & S_B43 + & S_B44 ) END SUBROUTINE SourceCalcComponents","tags":"","loc":"sourcefile/sourcetermcomponentsmms.f90.html"},{"title":"smachAndSndspdModule.f90 – Fortran Program","text":"Contents Modules smachAndSndspdModule Source Code smachAndSndspdModule.f90 Source Code MODULE smachAndSndspdModule USE , INTRINSIC :: ISO_FORTRAN_ENV ! USE Akima1D IMPLICIT NONE PRIVATE PUBLIC :: smachAndSndspd INTERFACE smachAndSndspd MODULE PROCEDURE smachAndSndspd1 END INTERFACE smachAndSndspd INTEGER , PARAMETER :: rDef = REAL64 CONTAINS SUBROUTINE smachAndSndspd1 ( npts , rr , rmsw , rmswp , snd , dsn , dd ) INTEGER , INTENT ( IN ) :: & npts REAL ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: & rr REAL ( KIND = rDef ), DIMENSION (:,:), INTENT ( IN ) :: & dd REAL ( KIND = rDef ), DIMENSION (:), INTENT ( OUT ) :: & rmsw , & rmswp , & dsn REAL ( KIND = rDef ), DIMENSION (:), INTENT ( INOUT ) :: & snd ! local variables INTEGER :: i , & j , & k REAL ( KIND = rDef ) :: & tot , & gm , & gm1 , & rsw1 , & rswi , & x1 , & xi gm = 1.4_rDef gm1 = gm - 1.0_rDef ! Spectral computation of M_theta'. DO k = 1 , npts tot = 0.0_rDef DO j = 1 , npts tot = tot + dd ( k , j ) * rmsw ( j ) ENDDO rmswp ( k ) = tot ENDDO DO k = 1 , npts snd ( k ) = 0.0_rDef ENDDO ! calculate the speed of sound by integration (Eq. (2.6) in paper) ! put in some fixes -- need to check this. DO k = 1 , npts DO i = npts - 1 , k , - 1 IF ( rr ( i ). gt . 0.0_rDef ) then rswi = rmsw ( i ) * rmsw ( i ) / rr ( i ) rsw1 = rmsw ( i + 1 ) * rmsw ( i + 1 ) / rr ( i + 1 ) xi = rr ( i ) x1 = rr ( i + 1 ) snd ( i ) = snd ( i + 1 ) + 0.5_rDef * ( rswi + rsw1 ) * ( x1 - xi ) ELSE snd ( i ) = 2.0_rDef * rmsw ( i ) * ( rmsw ( i + 1 ) - rmsw ( i )) / rr ( i + 1 ) ENDIF ENDDO snd ( k ) = exp ( - 0.5_rDef * gm1 * snd ( k )) END DO ! get the radial derivative of the speed of sound do k = 1 , npts tot = 0.0_rDef do j = 1 , npts tot = tot + dd ( k , j ) * snd ( j ) enddo dsn ( k ) = tot enddo END SUBROUTINE smachAndSndspd1 END MODULE smachAndSndspdModule","tags":"","loc":"sourcefile/smachandsndspdmodule.f90.html"},{"title":"main.f90 – Fortran Program","text":"Contents Programs MAIN Source Code main.f90 Source Code PROGRAM MAIN USE , INTRINSIC :: ISO_FORTRAN_ENV USE swirlClassObject ! Runs SWIRL for a given set of parameters USE mmsClassObject ! Calculates L2Norm, L2Max, and Rate Of Convergence USE SourceTermModule ! Calculated the symbolic terms needed for MMS (used Python) IMPLICIT NONE ! 2) Start defining the variables CHARACTER ( 50 ) :: & dir_name ,& file_id , & !FDfac_id, & FORMAT_MEAN_FLOW , & FORMAT_PERTURB_VARS , & FORMAT_PERTURB_HEADER , & FORMAT_MEAN_FLOW_HEADER , & FORMAT_SOURCE_TERMS , & FORMAT_SOURCE_TERMS_HEADER , & FORMAT_L2 , & FORMAT_L2_HEADER , & FORMAT_ERROR , & FORMAT_ERROR_HEADER , & FORMAT_ROC , & FORMAT_ROC_HEADER LOGICAL :: & debug = . TRUE . INTEGER , PARAMETER :: & rDef = REAL64 , & numberOfIterations = 9 INTEGER :: & UNIT , & ! for NEWUNIT finiteDiffFlag ,& ! finite difference flag numericalIntegrationFlag ,& !  numerical integration flag numberOfGridPoints ,& ! number of points azimuthalModeNumber ,& ! mode order i ,& ! indexer for do loops fac ,& ! variable used for doubling grid points ! FDfac                    ,& facCount ! counts the outermost do loop INTEGER , DIMENSION (:), ALLOCATABLE :: & numberOfGridPointsArray REAL ( KIND = rDef ), DIMENSION (:), ALLOCATABLE :: & r ,& !radial grid locations rOut , & vR , vX , vTh , Pr , & speedOfSoundMMS , & SoundSpeedError , & axialMachDataMMS ,& !M_x thetaMachDataMMS ,& !M_th axialMachDataMMSOut ,& !M_x thetaMachDataMMSOut ,& !M_th axialMach_drMMSOut , & thetaMach_drMMSOut , & SoundSpeedOut , & SoundSpeedL2Array , & SoundSpeed_drOut , & axialMachData ,& !M_x thetaMachData ,& !M_th totalMachData ,& !M_total = sqrt(M_x&#94;2+M_th&#94;2) RateOfConvergence1 ,& RateOfConvergence2 ,& S_error REAL ( KIND = REAL64 ) :: & gam , & SoundSpeedErrorL2 , & ExpectedRateOfConvergenceSoundSpeed , & ExpectedRateOfConvergenceSourceTerm , & r_min ,& !radial grid locations r_max ,& !radial grid locations secondOrderSmoother ,& !2nd order smoothing coefficient fourthOrderSmoother ,& !4th order smoothing coefficient dr ,& hubToTipRatio COMPLEX ( KIND = rDef ) :: & S_L2 ,& eigenValueMMS ,& hubAdmittance ,& ductAdmittance ,& frequency COMPLEX ( KIND = rDef ) , DIMENSION (:), ALLOCATABLE :: & S_1 , & S_2 , & S_3 , & S_4 , & S_MMS , & S_actual , & S_L2Array , & eigenVectorMMS TYPE ( SwirlClassType ) , DIMENSION ( numberOfIterations ) :: & ! swirlClassObj, & swirlClassObjMMS TYPE ( mmsClassType ) :: SoundSpeedMMS_ClassObj , SourceTermMMS_ClassObj !                  ! ! Code Starts Here ! !                  ! CONTINUE FORMAT_MEAN_FLOW = \"(F15.12,F15.12,F15.12,F15.12,F15.12)\" FORMAT_MEAN_FLOW_HEADER = \"(A15,A15,A15,A15,A15)\" FORMAT_PERTURB_VARS = \"(F16.12,F16.12,F16.12,F16.12,F16.12)\" FORMAT_PERTURB_HEADER = \"(A12,A12,A12,A12,A12)\" FORMAT_SOURCE_TERMS = \"( F16.12, F16.12, F16.12,F16.12)\" FORMAT_SOURCE_TERMS_HEADER = \"( A6, A17, A17,A17)\" FORMAT_L2 = \"(I10,F20.12)\" FORMAT_L2_HEADER = \"(A10,A20)\" FORMAT_ERROR = \"(F20.12,F20.12,F20.12,F20.12)\" FORMAT_ERROR_HEADER = \"(A20, A20, A20,A20)\" FORMAT_ROC = \"(I10,F20.12)\" FORMAT_ROC_HEADER = ( \"(A10,A20)\" ) ! inputs needed for SwirlClassType include 'InputVariables.f90' eigenValueMMS = CMPLX ( 0 , 0 , KIND = rDef ) facCount = 0 ! initializer for far count IF ( numericalIntegrationFlag . eq . 1 ) THEN ExpectedRateOfConvergenceSoundSpeed = 2.0_rDef ELSEIF ( numericalIntegrationFlag . eq . 2 ) THEN ExpectedRateOfConvergenceSoundSpeed = 4.0_rDef ENDIF IF ( finiteDiffFlag . eq . 1 ) THEN ExpectedRateOfConvergenceSourceTerm = 2.0_rDef ELSEIF ( finiteDiffFlag . eq . 2 ) THEN ExpectedRateOfConvergenceSourceTerm = 4.0_rDef ENDIF ALLOCATE ( & RateOfConvergence1 ( numberOfIterations - 1 ) , & RateOfConvergence2 ( numberOfIterations - 1 ) , & S_L2Array ( numberOfIterations ) , & SoundSpeedL2Array ( numberOfIterations ) , & numberOfGridPointsArray ( numberOfIterations )) DO fac = 1 , numberOfIterations facCount = facCount + 1 ! numberOfGridPoints           = 256 numberOfGridPoints = 5 + ( 2 ** fac ) numberOfGridPointsArray ( fac ) = numberOfGridPoints dr = ( r_max - r_min ) / REAL ( numberOfGridPoints - 1 , rDef ) ALLOCATE (& axialMachDataMMSOut ( numberOfGridPoints ) ,& !M_x thetaMachDataMMSOut ( numberOfGridPoints ) ,& !M_Th axialMach_drMMSOut ( numberOfGridPoints ), & thetaMach_drMMSOut ( numberOfGridPoints ), & SoundSpeedOut ( numberOfGridPoints ) , & SoundSpeed_drOut ( numberOfGridPoints ), & r ( numberOfGridPoints ) , & rOut ( numberOfGridPoints ) , & thetaMachDataMMS ( numberOfGridPoints ) , & axialMachDataMMS ( numberOfGridPoints ) , & speedOfSoundMMS ( numberOfGridPoints ), & SoundSpeedError ( numberOfGridPoints ) , & vR ( numberOfGridPoints ), & vX ( numberOfGridPoints ), & vTh ( numberOfGridPoints ), & Pr ( numberOfGridPoints ), & S_1 ( numberOfGridPoints ), & S_2 ( numberOfGridPoints ), & S_3 ( numberOfGridPoints ), & S_4 ( numberOfGridPoints ), & S_MMS ( numberOfGridPoints * 4 ) , & S_error ( numberOfGridPoints * 4 ) , & S_actual ( numberOfGridPoints * 4 ) , & eigenVectorMMS ( numberOfGridPoints * 4 ),& thetaMachData ( numberOfGridPoints ) , & axialMachData ( numberOfGridPoints ) , & totalMachData ( numberOfGridPoints )) DO i = 1 , numberOfGridPoints r ( i ) = ( r_min + REAL ( i - 1 , rDef ) * dr ) / r_max ! Plug flow for T4.1 axialMachData ( i ) = 0.3_rDef thetaMachData ( i ) = 0.0_rDef ! T.4.5 profile (sheared flow !                axialMachData(i) = 0.3_rDef*(1.0_rDef - 2.0_rDef*ABS(& !                    (r_min - r(i))/(1.0_rDef/7.0_rDef) + 0.5_rDef))**(1.0_rDef/7.0_rDef) !                thetaMachData(i) = 0.0_rDef END DO ! CALL getSoundSpeed (& r = r , & SoundSpeedExpected = speedOfSoundMMS , & thetaMachData = thetaMachDataMMS , & axialMachData = axialMachDataMMS ) CALL getPerturbationVariables (& r = r , & vR = vR , & vTh = vTh , & vX = vX , & Pr = Pr ) DO i = 1 , numberOfGridPoints eigenVectorMMS ( i ) = & CMPLX ( vR ( i ), KIND = rDef ) eigenVectorMMS ( i + numberOfGridPoints ) = & CMPLX ( vTh ( i ), KIND = rDef ) eigenVectorMMS ( i + 2 * numberOfGridPoints ) = & CMPLX ( vX ( i ), KIND = rDef ) eigenVectorMMS ( i + 3 * numberOfGridPoints ) = & CMPLX ( Pr ( i ), KIND = rDef ) ENDDO CALL getMMSSourceTerms ( & r = r ,& S_1 = S_1 ,& S_2 = S_2 ,& S_3 = S_3 ,& S_4 = S_4 ) DO i = 1 , numberOfGridPoints S_MMS ( i ) = S_1 ( i ) S_MMS ( i + numberOfGridPoints ) = S_2 ( i ) S_MMS ( i + 2 * numberOfGridPoints ) = S_3 ( i ) S_MMS ( i + 3 * numberOfGridPoints ) = S_4 ( i ) ENDDO !Create a swirl Class Obj for a given flow ! CALL CreateObject(& !     object        = swirlClassObj(fac)  ,& !     azimuthalMode = azimuthalModeNumber  ,& !     np            = numberOfGridPoints   ,& !     sig           = hubToTipRatio        ,& !     axialMachData = axialMachData        ,& !     tangentialMachData = thetaMachData        ,& !     ak            = frequency            ,& !     etah          = hubAdmittance        ,& !     etad          = ductAdmittance       ,& !     ifdff         = finiteDiffFlag       ) ! CALL runSwirlClassMethods(& !     object = swirlClassObj(fac)) CALL CreateObject (& object = swirlClassObjMMS ( fac ) ,& azimuthalMode = azimuthalModeNumber ,& np = numberOfGridPoints ,& sig = hubToTipRatio ,& axialMachData = axialMachDataMMS ,& tangentialMachData = thetaMachDataMMS ,& ak = frequency ,& etah = hubAdmittance ,& etad = ductAdmittance ,& ifdff = finiteDiffFlag ) CALL runSwirlClassMethods (& object = swirlClassObjMMS ( fac )) CALL GetMeanFlowData (& object = swirlClassObjMMS ( fac ),& axialMach = axialMachDataMMSOut , & thetaMach = thetaMachDataMMSOut , & axialMach_dr = axialMach_drMMSOut , & thetaMach_dr = thetaMach_drMMSOut , & SoundSpeed = SoundSpeedOut , & SoundSpeed_dr = SoundSpeed_drOut , & radialData = rOut ) CALL FindResidualData (& object = swirlClassObjMMS ( fac ),& eigenVector = eigenVectorMMS , & eigenValue = eigenValueMMS , & S = S_actual ) DO i = 1 , numberOfGridPoints SoundSpeedError ( i ) = & speedOfSoundMMS ( i ) - SoundSpeedOut ( i ) S_error ( i ) = & ABS ( S_actual ( i ) - S_MMS ( i )) S_error ( i + numberOfGridPoints ) = & ABS ( S_actual ( i + numberOfGridPoints ) - S_MMS ( i + numberOfGridPoints )) S_error ( i + 2 * numberOfGridPoints ) = & ABS ( S_actual ( i + 2 * numberOfGridPoints ) - S_MMS ( i + 2 * numberOfGridPoints )) S_error ( i + 3 * numberOfGridPoints ) = & ABS ( S_actual ( i + 3 * numberOfGridPoints ) - S_MMS ( i + 3 * numberOfGridPoints )) ENDDO CALL getL2Norm (& object = SoundSpeedMMS_ClassObj , & L2 = SoundSpeedErrorL2 , & dataSet1 = speedOfSoundMMS , & dataSet2 = SoundSpeedOut ) CALL getL2Norm (& object = SourceTermMMS_ClassObj , & L2 = S_L2 , & dataSet1 = S_MMS , & dataSet2 = S_actual ) S_L2Array ( fac ) = S_L2 SoundSpeedL2Array ( fac ) = SoundSpeedErrorL2 include 'main-scripts/swirl-data-export-per-grid-MMS.f90' include 'main-scripts/swirl-data-export-per-grid.f90' CALL DestroyObject ( object = swirlClassObjMMS ( fac )) ! CALL DestroyObject(object = swirlClassObj(fac)) DEALLOCATE (& axialMachDataMMSOut , & thetaMachDataMMSOut , & r ,& rOut ,& thetaMachData ,& axialMachData ,& thetaMachDataMMS ,& axialMach_drMMSOut ,& thetaMach_drMMSOut ,& SoundSpeedOut ,& SoundSpeedError , & speedOfSoundMMS , & SoundSpeed_drOut ,& axialMachDataMMS ,& vR , vTh , vX , Pr , & eigenVectorMMS , & totalMachData , & S_MMS , S_actual , S_error , S_1 , S_2 , S_3 , S_4 ) END DO !    END DO include 'main-scripts/calculating-rate-of-convergence.f90' include 'main-scripts/swirl-data-export-MMS.f90' DEALLOCATE (& RateOfConvergence1 , & RateOfConvergence2 , & S_L2Array ) END PROGRAM MAIN","tags":"","loc":"sourcefile/main.f90.html"},{"title":"rmachModule.f90 – Fortran Program","text":"Contents Modules rmachModule Source Code rmachModule.f90 Source Code MODULE rmachModule USE , INTRINSIC :: ISO_FORTRAN_ENV ! USE Akima1D IMPLICIT NONE PRIVATE PUBLIC :: rmach INTERFACE rmach MODULE PROCEDURE rmach1 END INTERFACE INTEGER , PARAMETER :: rDef = REAL64 CONTAINS SUBROUTINE rmach1 ( npts , rmch , drm , dd ) INTEGER , INTENT ( IN ) :: & npts REAL ( KIND = rDef ), DIMENSION (:), INTENT ( OUT ) :: & drm , & rmch REAL ( KIND = rDef ), DIMENSION (:,:), INTENT ( IN ) :: & dd ! local variables INTEGER :: & j , & k REAL ( KIND = rDef ) :: & tot ! ! drh mod:  read in data and use akima spline ! ! open(unit=22,file='mach.input',status='unknown') ! READ(22,*) nptsIn ! ALLOCATE(rIn(nptsIn), & !       rmchIn(nptsIn)) ! DO i=1,nptsIn !  READ(22,*) rIn(i),rmchIn(i) ! END DO ! CLOSE(22) ! ! spline data onto grid ! ! JS: removed read from file capability, now it is input from main ! CALL Akima433Interpolation(inputDataLength  = nptsIn, & !                            xInputData       = rIn,    & !                            yInputData       = rmchIn, & !                            outputDataLength = npts,   & !                            xOutputData      = rr,     & !                            yOutputData      = rmch) ! DEALLOCATE(rIn, rmchIn) !      read (22,*) (rmch(i), i = 1,npts) !      close(22) ! ! Spectral computation of M'. do k = 1 , npts tot = 0.0_rDef do j = 1 , npts tot = tot + dd ( k , j ) * rmch ( j ) enddo drm ( k ) = tot enddo END SUBROUTINE rmach1 END MODULE rmachModule","tags":"","loc":"sourcefile/rmachmodule.f90.html"},{"title":"globalModule.f90 – Fortran Program","text":"Contents Modules globalModule Source Code globalModule.f90 Source Code MODULE globalModule USE , INTRINSIC :: ISO_FORTRAN_ENV IMPLICIT NONE PRIVATE PUBLIC :: globalM INTERFACE globalM MODULE PROCEDURE globalM1 END INTERFACE globalM INTEGER , PARAMETER :: rDef = REAL64 CONTAINS subroutine globalM1 ( np , np4 , sig , mode , om , snd , dd , & rr , rx , dr , rt , dt , aa , bb , S_aa , S_bb , row , col ) INTEGER , INTENT ( IN ) :: & row , & col , & np , & np4 , & mode REAL ( KIND = rDef ), INTENT ( IN ) :: & sig REAL ( KIND = rDef ), DIMENSION (:,:), INTENT ( IN ) :: & dd REAL ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: & snd , & rr , & rx , & dr , & dt COMPLEX ( KIND = rDef ), INTENT ( IN ) :: & om COMPLEX ( KIND = rDef ), DIMENSION (:,:), INTENT ( OUT ) :: & aa , & bb , & S_aa ,& S_bb ! define local variables REAL ( KIND = rDef ), PARAMETER :: & gm = 1.4_rDef , & tolerance = 1 0e-11_rDef INTEGER :: & j , & j1 , & j2 , & j3 , & k , & k1 , & k2 , & k3 REAL ( KIND = rDef ) :: & r REAL ( KIND = rDef ), DIMENSION ( np ) :: & rt COMPLEX ( KIND = rDef ) :: ci ! zero out the matrices do j = 1 , np4 do k = 1 , np4 aa ( k , j ) = CMPLX ( 0.0_rDef , 0.0_rDef , rDef ) bb ( k , j ) = CMPLX ( 0.0_rDef , 0.0_rDef , rDef ) S_aa ( k , j ) = CMPLX ( 0.0_rDef , 0.0_rDef , rDef ) S_bb ( k , j ) = CMPLX ( 0.0_rDef , 0.0_rDef , rDef ) enddo enddo ci = CMPLX ( 0.0_rDef , 1.0_rDef , rDef ) ! Global matrices. ! np x np matrix, with 4x4 blocks in each entry ! ! In this one, the matrix is (4*np)x(4*np). ! do k = 1 , np ! k  == v_r k1 = np + k ! k1 == v_{\\theta} k2 = 2 * np + k ! k2 == v_x k3 = 3 * np + k ! k3 == p r = rr ( k ) do j = 1 , np ! j  == v_r j1 = np + j ! j1 == v_{\\theta} j2 = 2 * np + j ! j2 == v_x j3 = 3 * np + j ! j3 == p ! dd is the derivative matrix for the radial direction ! derivatives appear in two locations in the [A] block matrix: !       (1,4) and (4,1) aa ( k , j3 ) = CMPLX ( dd ( k , j ), KIND = rDef ) ! (1,4) : v_r eqn, p entry     d/dr aa ( k3 , j ) = CMPLX ( dd ( k , j ), KIND = rDef ) ! (4,1) : p   eqn, v_r entry   d/dr if ( k . eq . j ) then aa ( k , j ) = - ci * om / CMPLX ( snd ( k ), KIND = rDef ) ! (1,1) : v_r eqn, v_r entry:         -i k/A aa ( k1 , j1 ) = - ci * om / CMPLX ( snd ( k ), KIND = rDef ) ! (2,2) : v_theta eqn, v_theta entry: -i k/A aa ( k2 , j2 ) = - ci * om / CMPLX ( snd ( k ), KIND = rDef ) ! (3,3) : v_x eqn, v_x entry:         -i k/A aa ( k3 , j3 ) = - ci * om / CMPLX ( snd ( k ), KIND = rDef ) ! (4,4) : p eqn, p entry:             -i k/A aa ( k1 , j ) = CMPLX ( dt ( j ), KIND = rDef ) ! (2,1) : v_theta eqn, v_r entry: dM_th/dr aa ( k2 , j ) = CMPLX ( dr ( j ), KIND = rDef ) ! (3,1) : v_x eqn, v_r entry: dM_x/dr if ( r . gt . 0.0_rDef ) then aa ( k1 , j3 ) = ci * CMPLX ( mode , KIND = rDef ) / CMPLX ( r , KIND = rDef ) ! (2,4): v_theta eqn, p entry: i m/r aa ( k3 , j1 ) = ci * CMPLX ( mode , KIND = rDef ) / CMPLX ( r , KIND = rDef ) ! (4,2): p eqn, v_theta entry: i m/r aa ( k3 , j ) = aa ( k3 , j ) & ! (4,1): p eqn, v_r entry: + & CMPLX ( 1.0_rDef , KIND = rDef ) / & CMPLX ( r , KIND = rDef ) & !                          +1/r + & CMPLX ( gm + 1.0_rDef , KIND = rDef ) * & CMPLX ( rt ( j ), KIND = rDef ) * & CMPLX ( rt ( j ), KIND = rDef ) / & (& CMPLX ( 2.0_rDef , KIND = rDef ) * & CMPLX ( r , KIND = rDef )& ) !  + ((gam+1)M_th&#94;2)/(2r) ! (1,1): v_r eqn, v_r entry: aa ( k , j ) = aa ( k , j ) & + ci * & CMPLX ( mode , KIND = rDef ) * & CMPLX ( rt ( j ), KIND = rDef ) / & CMPLX ( r , KIND = rDef ) !    +(i m M_th)/r aa ( k1 , j1 ) = aa ( k1 , j1 ) & ! (2,2): v_th eqn, v_th entry: + ci * & CMPLX ( mode , KIND = rDef ) * & CMPLX ( rt ( j ), KIND = rDef ) / & CMPLX ( r , KIND = rDef ) !    +(i m M_th)/r aa ( k2 , j2 ) = aa ( k2 , j2 ) & ! (3,3): v_x eqn, v_x entry: + ci * & CMPLX ( mode , KIND = rDef ) * & CMPLX ( rt ( j ), KIND = rDef ) / & CMPLX ( r , KIND = rDef ) !    +(i m M_th)/r aa ( k3 , j3 ) = aa ( k3 , j3 ) & ! (4,4): p eqn, p entry: + ci * CMPLX ( mode , KIND = rDef ) * & CMPLX ( rt ( j ), KIND = rDef ) / & CMPLX ( r , KIND = rDef ) !    +(i m M_th)/r aa ( k , j1 ) = CMPLX ( - 2.0_rDef , KIND = rDef ) * & CMPLX ( rt ( j ) , KIND = rDef ) / & CMPLX ( r , KIND = rDef ) ! (1,2): v_r eqn, v_th entry:  -(2 M_th)/r aa ( k , j3 ) = aa ( k , j3 ) & ! (1,4): v_r eqn, p entry: + CMPLX (( gm - 1.0_rDef ), KIND = rDef ) * CMPLX ( rt ( j ), KIND = rDef ) * CMPLX ( rt ( j ), KIND = rDef ) / CMPLX ( r , KIND = rDef ) !  + (gam-1)*(M_th&#94;2)/r aa ( k1 , j ) = aa ( k1 , j ) & ! (2,1): v_th eqn, v_r entry: + & CMPLX ( rt ( j ), KIND = rDef ) / & CMPLX ( r , KIND = rDef ) & !                   +(M_th)/r + & CMPLX (( gm - 1.0_rDef ), KIND = rDef ) * & ( CMPLX ( rt ( j ), KIND = rDef ) ** 3 ) / & ( CMPLX ( 2.0_rDef , KIND = rDef ) * & CMPLX ( r , KIND = rDef )) !       +((gam-1)*M_th&#94;3)/(2 r) aa ( k2 , j ) = aa ( k2 , j ) & ! (3,1): v_x eqn, v_r entry: + & CMPLX (( gm - 1.0_rDef ), KIND = rDef ) * & CMPLX ( rx ( j ), KIND = rDef ) * & CMPLX ( rt ( j ), KIND = rDef ) * & CMPLX ( rt ( j ), KIND = rDef ) / & (& CMPLX ( 2.0_rDef , KIND = rDef ) * & CMPLX ( r , KIND = rDef )& ) ! +((gam-1)*M_x*M_th&#94;2)/(2 r) ! elseif ( r . lt . tolerance ) THEN ! r == 0 aa ( k1 , j3 ) = CMPLX ( 0.0_rDef , 0.0_rDef , rDef ) ! (2,4): v_th eqn, p entry: 0 aa ( k3 , j1 ) = CMPLX ( 0.0_rDef , 0.0_rDef , rDef ) ! (4,2): p eqn, v_th entry: 0 aa ( k , j ) = aa ( k , j ) & ! (1,1): v_r eqn, v_r entry: + ci * CMPLX ( mode , KIND = rDef ) * CMPLX ( dt ( j ), KIND = rDef ) !    + i m M_th aa ( k1 , j1 ) = aa ( k1 , j1 ) & ! (2,2): v_th eqn, v_th entry: + ci * CMPLX ( mode , KIND = rDef ) * CMPLX ( dt ( j ), KIND = rDef ) !    + i m M_th aa ( k2 , j2 ) = aa ( k2 , j2 ) & ! (3,3): v_x eqn, v_x entry: + ci * CMPLX ( mode , KIND = rDef ) * CMPLX ( dt ( j ), KIND = rDef ) !    + i m M_th aa ( k3 , j3 ) = aa ( k3 , j3 ) & ! (4,4): p eqn, p entry: + ci * & CMPLX ( mode , KIND = rDef ) * & CMPLX ( dt ( j ), KIND = rDef ) !    + i m M_th aa ( k , j1 ) = CMPLX ( - 2.0_rDef , KIND = rDef ) * CMPLX ( dt ( j ), KIND = rDef ) ! (1,2): v_r eqn, v_th entry: - 2 M_th aa ( k , j3 ) = aa ( k , j3 ) & ! (1,4): v_r eqn, p entry: + CMPLX ( 2.0_rDef , KIND = rDef ) * CMPLX (( gm - 1.0_rDef ), KIND = rDef ) * CMPLX ( rt ( j ), KIND = rDef ) * CMPLX ( dt ( j ), KIND = rDef ) ! + 2 (gam-1)*M_th*dM_th/dr aa ( k1 , j ) = aa ( k1 , j ) & ! (2,1): v_th eqn, v_r entry: + (& CMPLX ( 1.0_rDef , KIND = rDef ) + & CMPLX ( 3.0_rDef , KIND = rDef ) * & CMPLX (( gm - 1.0_rDef ), KIND = rDef ) * & CMPLX ( rt ( j ), KIND = rDef ) * & CMPLX ( rt ( j ), KIND = rDef ) / CMPLX ( 2.0_rDef , KIND = rDef )) * & CMPLX ( dt ( j ), KIND = rDef ) !        +(1+3*((gam-1)/2)*Mth&#94;2)*dM_th/dr aa ( k2 , j ) = aa ( k2 , j ) & ! (3,1): v_x eqn, v_r entry: + & CMPLX (( gm - 1.0_rDef ), KIND = rDef ) / & CMPLX ( 2.0_rDef , KIND = rDef ) * & CMPLX ( rt ( j ), KIND = rDef ) * (& CMPLX ( dr ( j ), KIND = rDef ) * & CMPLX ( rt ( j ), KIND = rDef ) + & CMPLX ( 2.0_rDef , KIND = rDef ) * & CMPLX ( rx ( j ), KIND = rDef ) * & CMPLX ( dt ( j ), KIND = rDef )) !  +((gam-1)/2)*Mth*(Mth*dMx/dr + 2*Mx*dMth/dr) aa ( k3 , j ) = aa ( k3 , j ) & ! (4,1): p eqn, v_r entry: + & CMPLX (( gm + 1.0_rDef ), KIND = rDef ) * & CMPLX ( rt ( j ), KIND = rDef ) * & CMPLX ( dt ( j ), KIND = rDef ) !    + (gam+1)*M_th*dMth/dr else ! r == 0 aa ( k1 , j3 ) = CMPLX ( 0.0_rDef , 0.0_rDef , rDef ) ! (2,4): v_th eqn, p entry: 0 aa ( k3 , j1 ) = CMPLX ( 0.0_rDef , 0.0_rDef , rDef ) ! (4,2): p eqn, v_th entry: 0 aa ( k , j ) = aa ( k , j ) & ! (1,1): v_r eqn, v_r entry: + ci * CMPLX ( mode , KIND = rDef ) * CMPLX ( dt ( j ), KIND = rDef ) !    + i m M_th aa ( k1 , j1 ) = aa ( k1 , j1 ) & ! (2,2): v_th eqn, v_th entry: + ci * CMPLX ( mode , KIND = rDef ) * CMPLX ( dt ( j ), KIND = rDef ) !    + i m M_th aa ( k2 , j2 ) = aa ( k2 , j2 ) & ! (3,3): v_x eqn, v_x entry: + ci * CMPLX ( mode , KIND = rDef ) * CMPLX ( dt ( j ), KIND = rDef ) !    + i m M_th aa ( k3 , j3 ) = aa ( k3 , j3 ) & ! (4,4): p eqn, p entry: + ci * & CMPLX ( mode , KIND = rDef ) * & CMPLX ( dt ( j ), KIND = rDef ) !    + i m M_th aa ( k , j1 ) = CMPLX ( - 2.0_rDef , KIND = rDef ) * CMPLX ( dt ( j ), KIND = rDef ) ! (1,2): v_r eqn, v_th entry: - 2 M_th aa ( k , j3 ) = aa ( k , j3 ) & ! (1,4): v_r eqn, p entry: + CMPLX ( 2.0_rDef , KIND = rDef ) * CMPLX (( gm - 1.0_rDef ), KIND = rDef ) * CMPLX ( rt ( j ), KIND = rDef ) * CMPLX ( dt ( j ), KIND = rDef ) ! + 2 (gam-1)*M_th*dM_th/dr aa ( k1 , j ) = aa ( k1 , j ) & ! (2,1): v_th eqn, v_r entry: + (& CMPLX ( 1.0_rDef , KIND = rDef ) + & CMPLX ( 3.0_rDef , KIND = rDef ) * & CMPLX (( gm - 1.0_rDef ), KIND = rDef ) * & CMPLX ( rt ( j ), KIND = rDef ) * & CMPLX ( rt ( j ), KIND = rDef ) / CMPLX ( 2.0_rDef , KIND = rDef )) * & CMPLX ( dt ( j ), KIND = rDef ) !        +(1+3*((gam-1)/2)*Mth&#94;2)*dM_th/dr aa ( k2 , j ) = aa ( k2 , j ) & ! (3,1): v_x eqn, v_r entry: + & CMPLX (( gm - 1.0_rDef ), KIND = rDef ) / & CMPLX ( 2.0_rDef , KIND = rDef ) * & CMPLX ( rt ( j ), KIND = rDef ) * (& CMPLX ( dr ( j ), KIND = rDef ) * & CMPLX ( rt ( j ), KIND = rDef ) + & CMPLX ( 2.0_rDef , KIND = rDef ) * & CMPLX ( rx ( j ), KIND = rDef ) * & CMPLX ( dt ( j ), KIND = rDef )) !  +((gam-1)/2)*Mth*(Mth*dMx/dr + 2*Mx*dMth/dr) aa ( k3 , j ) = aa ( k3 , j ) & ! (4,1): p eqn, v_r entry: + & CMPLX (( gm + 1.0_rDef ), KIND = rDef ) * & CMPLX ( rt ( j ), KIND = rDef ) * & CMPLX ( dt ( j ), KIND = rDef ) !    + (gam+1)*M_th*dMth/dr endif bb ( k , j ) = CMPLX ( rx ( j ), KIND = rDef ) ! (1,1): v_r eqn, v_r entry: M_x bb ( k1 , j1 ) = CMPLX ( rx ( j ), KIND = rDef ) ! (2,2): v_th eqn, v_th entry: M_x bb ( k2 , j2 ) = CMPLX ( rx ( j ), KIND = rDef ) ! (3,3): v_x eqn, v_x entry: M_x bb ( k3 , j3 ) = CMPLX ( rx ( j ), KIND = rDef ) ! (4,4): p eqn, p entry: M_x bb ( k2 , j3 ) = CMPLX ( 1.0_rDef , 0.0_rDef , rDef ) ! (3,4): v_x eqn, p entry: 1.0 bb ( k3 , j2 ) = CMPLX ( 1.0_rDef , 0.0_rDef , rDef ) ! (4,3): p eqn, v_x entry: 1.0 endif enddo enddo ! ! row = 2 ! col = 2 do k = 1 , np ! k  == v_r k1 = np + k ! k1 == v_{\\theta} k2 = 2 * np + k ! k2 == v_x k3 = 3 * np + k ! k3 == p r = rr ( k ) do j = 1 , np ! j  == v_r j1 = np + j ! j1 == v_{\\theta} j2 = 2 * np + j ! j2 == v_x j3 = 3 * np + j ! j3 == p !v_r if ( row . eq . 1 . AND . col . eq . 1 ) then S_aa ( k , j ) = aa ( k , j ) elseif ( row . eq . 2 . AND . col . eq . 1 ) then S_aa ( k1 , j ) = aa ( k1 , j ) elseif ( row . eq . 3 . AND . col . eq . 1 ) then S_aa ( k2 , j ) = aa ( k2 , j ) elseif ( row . eq . 4 . AND . col . eq . 1 ) then S_aa ( k3 , j ) = aa ( k3 , j ) !v_theta elseif ( row . eq . 1 . AND . col . eq . 2 ) then S_aa ( k , j1 ) = aa ( k , j1 ) elseif ( row . eq . 2 . AND . col . eq . 2 ) then S_aa ( k1 , j1 ) = aa ( k1 , j1 ) elseif ( row . eq . 3 . AND . col . eq . 2 ) then S_aa ( k2 , j1 ) = aa ( k2 , j1 ) elseif ( row . eq . 4 . AND . col . eq . 2 ) then S_aa ( k3 , j1 ) = aa ( k3 , j1 ) !v_x elseif ( row . eq . 1 . AND . col . eq . 3 ) then S_aa ( k , j2 ) = aa ( k , j2 ) elseif ( row . eq . 2 . AND . col . eq . 3 ) then S_aa ( k1 , j2 ) = aa ( k1 , j2 ) elseif ( row . eq . 3 . AND . col . eq . 3 ) then S_aa ( k2 , j2 ) = aa ( k2 , j2 ) elseif ( row . eq . 4 . AND . col . eq . 3 ) then S_aa ( k3 , j2 ) = aa ( k3 , j2 ) !pressure elseif ( row . eq . 1 . AND . col . eq . 4 ) then S_aa ( k , j3 ) = aa ( k , j3 ) elseif ( row . eq . 2 . AND . col . eq . 4 ) then S_aa ( k1 , j3 ) = aa ( k1 , j3 ) elseif ( row . eq . 3 . AND . col . eq . 4 ) then S_aa ( k2 , j3 ) = aa ( k2 , j3 ) elseif ( row . eq . 4 . AND . col . eq . 4 ) then S_aa ( k3 , j3 ) = aa ( k3 , j3 ) else endif ! S_aa(k2,j2) = aa(k2,j2) ! S_aa(k3,j3) = aa(k3,j3) ! S_bb(k,j)   = bb(k,j) ! S_bb(k1,j1) = bb(k1,j1) ! S_bb(k2,j2) = bb(k2,j2) ! S_bb(k3,j3) = bb(k3,j3) enddo enddo ! WRITE(0,*) 'S_aa(k,j)', S_aa(k,j) !cc = with aa element that i want and Zeros else where return IF ( sig > 0.0_rDef ) CONTINUE ! sig is not actually used in this routine end END MODULE globalModule","tags":"","loc":"sourcefile/globalmodule.f90.html"},{"title":"swirlClassObject.f90 – Fortran Program","text":"Contents Modules swirlClassObject Source Code swirlClassObject.f90 Source Code modulE swirlClassObject ! USE , INTRINSIC :: ISO_FORTRAN_ENV USE analysisModule USE boundaryModule USE derivsModule USE fdgridModule USE fdrivsModule USE globalModule USE gridModule USE rmachModule USE smachAndSndspdModule USE outputModule USE FindResidualVectorModule USE SourceTermModule USE mmsClassObject IMPLICIT NONE PRIVATE PUBLIC :: & runSwirlClassMethods , & CreateMMSObject , & CreateObject ,& DestroyObject ,& SwirlClassType ,& GetMeanFlowData , & FindResidualData , & GetModeData ! Creates a derived data type containing SWIRL's essential modules INTERFACE CreateObject MODULE PROCEDURE CreateSwirlClassObject END INTERFACE CreateObject INTERFACE runSwirlClassMethods MODULE PROCEDURE runSWIRL END INTERFACE runSwirlClassMethods INTERFACE CreateMMSObject MODULE PROCEDURE CreateSwirlClassObjectMMS END INTERFACE CreateMMSObject ! Finds S = [A]{x} - i*eigVal*[B]{x}, x \\equiv eigen vector INTERFACE FindResidualData MODULE PROCEDURE GetResidualVector END INTERFACE FindResidualData INTERFACE GetModeData MODULE PROCEDURE GetRadialModeData END INTERFACE GetModeData INTERFACE GetMeanFlowData MODULE PROCEDURE GetMeanData END INTERFACE GetMeanFlowData INTERFACE GetSortedModeData MODULE PROCEDURE SortModeData END INTERFACE GetSortedModeData INTERFACE DestroyObject MODULE PROCEDURE DestroySwirlClassObject END INTERFACE DestroyObject INTEGER , PARAMETER :: rDef = REAL64 TYPE SwirlClassType PRIVATE ! prevents user from accessing any of the following variables LOGICAL :: & isInitialized = . FALSE . ! flag to identify if object exists INTEGER :: & azimuthalMode ,& ! m, Circumfirential mode number numberOfRadialPoints ,& ! npts, number of radial mesh points numberOfPropagatingModes , & ! number of modes that the user wants FiniteDifferenceFlag !,&    ! Use central FD for derivatives, ! 1 = 2nd Order, 2 = 4th Order PrintToggle                    ! Turns on print to screen REAL ( KIND = REAL64 ) :: & hubTipRatio ,& dr , & kappa , & !ratio of speCific heats secondOrderSmoother , & !derivative \"smoothers\" fourthOrderSmoother !\"          \" REAL ( KIND = REAL64 ), DIMENSION (:), ALLOCATABLE :: & soundSpeed_L2array , & vRad , & vT , & vX , & Pr , & y , & ! used to map grid on a-1 to 1 scale rwork , & ! needed for ZGGEV r , & ! radial locations rmx , & ! axial mach number drm , & ! derivative of the axial mach number rmt , & ! theta mach number drt , & ! derivative of the theta mach number snd , & ! speed of sound SoundSpeedExpected , & dsn , & ! derivative of the speed of sound, back calculated from mach data rho , & ! flow densityas a function of snd akap REAL ( KIND = REAL64 ), DIMENSION (:,:), ALLOCATABLE :: & dl1 COMPLEX ( KIND = REAL64 ) :: & frequency , & hubLinerAdmittance , & ductLinerAdmittance COMPLEX ( KIND = REAL64 ), DIMENSION (:,:), ALLOCATABLE :: & aa , bb , S_aa , S_bb !These are needed before trivial elements are removed COMPLEX ( KIND = REAL64 ), DIMENSION (:,:), ALLOCATABLE :: & aa_before , bb_before COMPLEX ( KIND = REAL64 ), DIMENSION (:), ALLOCATABLE :: & alpha , & beta , & work , & vph , & S_MMS ,& S_Expected , & S_actual , & S_1 ,& S_2 ,& S_3 ,& S_4 ,& eigenVectorMMS , & wvn COMPLEX ( KIND = REAL64 ), DIMENSION (:,:), ALLOCATABLE :: & vl , & vr END TYPE SwirlClassType ! Local Variable Declaration LOGICAL :: debug = . FALSE . ! turns on/off printing to console CHARACTER :: & jobvl = 'N' ,& ! needed for zggev jobvr = 'V' ! ! additional variables, implicitly defined in the original code INTEGER :: & ir = 2 , & ! axial mach number \"knob\" to switch between analytical solutions is = 5 ! tangential mach number CONTAINS SUBROUTINE CreateSwirlClassObject (& object , & azimuthalMode , & np , & sig , & axialMachData , & tangentialMachData , & ak , & etah , & etad , & ifdff ) TYPE ( SwirlClassType ), INTENT ( INOUT ) :: & object INTEGER , INTENT ( INOUT ) :: & ifdff , & azimuthalMode , & np REAL ( KIND = REAL64 ), INTENT ( INOUT ) :: & sig REAL ( KIND = REAL64 ), DIMENSION (:), INTENT ( INOUT ) :: & axialMachData , & tangentialMachData ! Local variables INTEGER :: & np4 REAL ( KIND = REAL64 ) :: & ed2 , & ed4 COMPLEX ( KIND = REAL64 ), INTENT ( IN ) :: & etah , etad , ak object % isInitialized = . TRUE . ! Set user input to the object 'properties'; ed2 = 0.0_rDef ed4 = 0.0_rDef object % azimuthalMode = azimuthalMode object % numberOfRadialPoints = np object % hubTipRatio = sig object % frequency = ak object % hubLinerAdmittance = etah object % ductLinerAdmittance = etad object % FiniteDifferenceFlag = ifdff object % secondOrderSmoother = ed2 object % fourthOrderSmoother = ed4 object % rmx = axialMachData object % rmt = tangentialMachData np4 = object % numberOfRadialPoints * 4 object % dr = & ( 1.0_rDef - object % hubTipRatio ) / REAL ( object % numberOfRadialPoints - 1 , rDef ) ALLOCATE (& object % eigenVectorMMS ( object % numberOfRadialPoints * 4 ) , & object % S_actual ( object % numberOfRadialPoints * 4 ) , & object % S_Expected ( object % numberOfRadialPoints * 4 ) , & object % S_1 ( object % numberOfRadialPoints ) , & object % S_2 ( object % numberOfRadialPoints ) , & object % S_3 ( object % numberOfRadialPoints ) , & object % S_4 ( object % numberOfRadialPoints ) , & object % snd ( object % numberOfRadialPoints ),& object % SoundSpeedExpected ( object % numberOfRadialPoints ) , & object % soundSpeed_L2array ( object % numberOfRadialPoints ) , & object % vRad ( object % numberOfRadialPoints ),& object % vT ( object % numberOfRadialPoints ),& object % vX ( object % numberOfRadialPoints ),& object % Pr ( object % numberOfRadialPoints )) ALLOCATE (& object % dl1 ( object % numberOfRadialPoints , object % numberOfRadialPoints ), & object % y ( object % numberOfRadialPoints ), & object % rwork ( 8 * np4 ), & object % r ( object % numberOfRadialPoints ), & object % drm ( object % numberOfRadialPoints ), & object % drt ( object % numberOfRadialPoints ), & object % dsn ( object % numberOfRadialPoints ), & object % rho ( object % numberOfRadialPoints ), & object % akap ( np4 ), & ! was np in code, but may go to np4 in analysisModule object % alpha ( np4 ), & object % beta ( np4 ), & object % work ( 2 * np4 ), & object % S_MMS ( np4 ) ,& object % vph ( np4 ), & object % wvn ( np4 ), & object % aa ( np4 , np4 ), & object % S_aa ( np4 , np4 ), & object % aa_before ( np4 , np4 ), & object % bb ( np4 , np4 ), & object % S_bb ( np4 , np4 ), & object % bb_before ( np4 , np4 ), & object % vl ( np4 , np4 ), & object % vr ( np4 , np4 )) END SUBROUTINE CreateSwirlClassObject SUBROUTINE runSWIRL (& object ) TYPE ( SwirlClassType ) , INTENT ( INOUT ) :: & object IF ( object % isInitialized ) THEN ! Set up Gauss-Lobatto grid and compute Chebyshev derivative matrix. ! if (is .ne. -1) then if ( object % FiniteDifferenceFlag . eq . 0 ) then CALL grid (& np = object % numberOfRadialPoints , & sig = object % hubTipRatio , & x = object % y , & r = object % r ) CALL derivs (& np = object % numberOfRadialPoints , & sig = object % hubTipRatio , & dl1 = object % dl1 , & ed2 = object % secondOrderSmoother , & ed4 = object % fourthOrderSmoother ) else IF ( debug ) THEN WRITE ( 0 , * ) 'Entering fdgrid CALL' ELSE ENDIF ! Finite Difference grid CALL fdgrid (& np = object % numberOfRadialPoints , & sig = object % hubTipRatio , & x = object % y , & r = object % r ) IF ( debug ) THEN WRITE ( 0 , * ) 'Leaving fdgrid CALL' ELSE ENDIF IF ( debug ) THEN WRITE ( 0 , * ) 'Entering fdrivs CALL' ELSE ENDIF CALL fdrivs (& np = object % numberOfRadialPoints , & sig = object % hubTipRatio , & dl1 = object % dl1 , & iorder = object % FiniteDifferenceFlag , & ed2 = object % secondOrderSmoother , & ed4 = object % fourthOrderSmoother ) IF ( debug ) THEN WRITE ( 0 , * ) 'Leaving fdrivs CALL' ELSE ENDIF ENDIF IF ( debug ) THEN WRITE ( 0 , * ) 'Entering smachAndSndspd CALL' ELSE ENDIF CALL smachAndSndspd (& npts = object % numberOfRadialPoints , & rr = object % r , & rmsw = object % rmt , & rmswp = object % drt , & snd = object % snd , & dsn = object % dsn , & dd = object % dl1 ) IF ( debug ) THEN WRITE ( 0 , * ) 'Leaving smachAndSndspd CALL' ELSE ENDIF IF ( debug ) THEN WRITE ( 0 , * ) 'Entering rmach CALL' ELSE ENDIF CALL rmach (& npts = object % numberOfRadialPoints , & rmch = object % rmx , & drm = object % drm , & dd = object % dl1 & ) IF ( debug ) THEN WRITE ( 0 , * ) 'Leaving rmach CALL' ELSE ENDIF ! Set up global matrices. IF ( debug ) THEN WRITE ( 0 , * ) 'Entering globalM CALL' ELSE ENDIF CALL globalM (& np = object % numberOfRadialPoints , & np4 = object % numberOfRadialPoints * 4 , & sig = object % hubTipRatio , & mode = object % azimuthalMode , & om = object % frequency , & snd = object % snd , & dd = object % dl1 , & rr = object % r , & rx = object % rmx , & dr = object % drm , & rt = object % rmt , & dt = object % drt , & aa = object % aa , & bb = object % bb , & S_aa = object % S_aa , & S_bb = object % S_bb , & row = 1 ,& col = 4 ) IF ( debug ) THEN WRITE ( 0 , * ) 'Leaving globalM CALL' ELSE ENDIF IF ( debug ) THEN WRITE ( 0 , * ) 'Entering boundary CALL' ELSE ENDIF CALL boundary (& np = object % numberOfRadialPoints , & sig = object % hubTipRatio , & ak = object % frequency , & etah = object % hubLinerAdmittance , & etad = object % ductLinerAdmittance , & rmx = object % rmx , & rmt = object % rmt , & dd = object % dl1 , & aa = object % aa , & bb = object % bb ) IF ( debug ) THEN WRITE ( 0 , * ) 'Leaving boundary CALL' ELSE ENDIF object % aa_before = object % aa object % bb_before = object % bb IF ( debug ) THEN WRITE ( 0 , * ) 'Entering analysis CALL' ELSE ENDIF CALL analysis (& np = object % numberOfRadialPoints , & np4 = object % numberOfRadialPoints * 4 , & ak = object % frequency , & rr = object % r , & snd = object % snd , & rmx = object % rmx , & rmt = object % rmt , & aa = object % aa , & bb = object % bb , & alpha = object % alpha , & beta = object % beta , & vl = object % vl , & vr = object % vr , & work = object % work , & rwork = object % rwork , & gam = object % wvn , & jobvl = jobvl , & jobvr = jobvr , & mm = object % azimuthalMode , & ir = ir , & is = is , & vphi = object % vph , & akap = object % akap ) IF ( debug ) THEN WRITE ( 0 , * ) 'Leaving analysis CALL' ELSE ENDIF ! CALL output(& !     np     = object%numberOfRadialPoints,    & !     np4    = object%numberOfRadialPoints*4,   & !     mode   = object%azimuthalMode,    & !     rho    = object%hubTipRatio,   & !     omega  = object%frequency,    & !     egv    = jobvr, & !     attenh = object%hubLinerAdmittance,  & !     attend = object%ductLinerAdmittance,  & !     rmx    = object%rmx,   & !     drm    = object%drm,   & !     rmt    = object%rmt,   & !     drt    = object%drt,   & !     snd    = object%snd,   & !     rr     = object%r,     & !     wvn    = object%wvn,   & !     vrm    = object%vr,    & !     vphi   = object%vph,   & !     is     = is) ELSE WRITE ( 6 , * ) 'ERROR: The object is not initialized' CONTINUE ENDIF END SUBROUTINE runSWIRL SUBROUTINE CreateSwirlClassObjectMMS () !& !        TYPE(SwirlClassType) :: manufacturedObject !        TYPE(mmsClassType) :: SoundSpeedMMS_ClassObj, SourceTermMMS_ClassObj ! !        INTEGER :: & !            i ! ! !        REAL(KIND = rDef) :: & !            ExpectedRateOfConvergenceSoundSpeed , & !            ExpectedRateOfConvergenceSourceTerm ! !        REAL(KIND = rDef) ,DIMENSION(:), ALLOCATABLE ::& !            SoundSpeedExpected , & !            thetaMachData, & !            axialMachData ! !        COMPLEX(KIND = rDef) :: & !            axialWavenumberMMS ! ! !        COMPLEX(KIND = rDef) , DIMENSION(:) , ALLOCATABLE :: & !            S_A, S_B ! ! !            CALL CreateObject(& !                object          = manufacturedObject , & !                azimuthalMode   = azimuthalModeNumber, & !                np              = numberOfGridPoints , & !                sig             = hubToTipRatio             , & !                axialMachData   = axialMachData , & !                tangentialMachData   = thetaMachData, & !                ak = frequency, & !                etah = hubAdmittance            , & !                etad = ductAdmittance            , & !                ifdff = finiteDiffFlag           ) ! !            CALL runSwirlClassMethods(object = manufacturedObject) ! !            IF (manufacturedObject%FiniteDifferenceFlag.eq.1) THEN !                ExpectedRateOfConvergenceSoundSpeed = 2.0_rDef !            ELSEIF (manufacturedObject%FiniteDifferenceFlag.eq.2) THEN !                ExpectedRateOfConvergenceSoundSpeed = 4.0_rDef !            ENDIF ! !            IF (manufacturedObject%FiniteDifferenceFlag.eq.1) THEN !                ExpectedRateOfConvergenceSourceTerm = 2.0_rDef !            ELSEIF (manufacturedObject%FiniteDifferenceFlag.eq.2) THEN !                ExpectedRateOfConvergenceSourceTerm = 4.0_rDef !            ENDIF !            DO i = 1,manufacturedObject%numberOfRadialPoints ! !                manufacturedObject%eigenVectorMMS(i) = & !                    CMPLX(manufacturedObject%vRad(i),KIND = rDef) ! !                manufacturedObject%eigenVectorMMS(i +   manufacturedObject%numberOfRadialPoints) = & !                    CMPLX(manufacturedObject%vT(i), KIND = rDef) ! !                manufacturedObject%eigenVectorMMS(i + 2*manufacturedObject%numberOfRadialPoints) = & !                    CMPLX(manufacturedObject%vX(i), KIND = rDef) ! !                manufacturedObject%eigenVectorMMS(i + 3*manufacturedObject%numberOfRadialPoints) = & !                    CMPLX(manufacturedObject%Pr(i), KIND = rDef) ! !                manufacturedObject%S_Expected(i)  =& !                    manufacturedObject%S_1(i) ! !                manufacturedObject%S_Expected(i + manufacturedObject%numberOfRadialPoints)  =& !                    manufacturedObject%S_2(i) ! !                manufacturedObject%S_Expected(i + 2*manufacturedObject%numberOfRadialPoints)  =& !                    manufacturedObject%S_3(i) ! !                manufacturedObject%S_Expected(i + 3*manufacturedObject%numberOfRadialPoints)  =& !                    manufacturedObject%S_4(i) ! !            ENDDO ! ! !            axialWavenumberMMS = CMPLX(100.0_rDef,0.00_rDef,KIND=rDef) ! the value Is arbitrary, up to user ! !            S_A = MATMUL(manufacturedObject%aa_before,manufacturedObject%eigenVectorMMS) !            S_B = MATMUL(manufacturedObject%bb_before,manufacturedObject%eigenVectorMMS) ! !            manufacturedObject%S_actual = S_A - (-CMPLX(0.0, 1.0, KIND=rDef)*axialWavenumberMMS)*S_B ! ! !            CALL getL2Norm(& !                object    = SoundSpeedMMS_ClassObj ,& !                L2        = SoundSpeedErrorL2      ,& !                dataSet1  = manufacturedObject%SoundSpeedExpected     ,& !                dataSet2  = manufacturedObject%snd           ) ! ! !            CALL getL2Norm(& !                object    = SourceTermMMS_ClassObj,& !                L2        = S_L2 ,& !                dataSet1  = manufacturedObject%S_actual,& !                dataSet2  = manufacturedObject%S_Expected) ! !            CALL DestroyObject(object = manufacturedObject) !            DEALLOCATE(SoundSpeedExpected,thetaMachData,axialMachData) ! END SUBROUTINE CreateSwirlClassObjectMMS SUBROUTINE GetMeanData (& object ,& axialMach , & thetaMach , & axialMach_dr , & thetaMach_dr , & SoundSpeed , & SoundSpeed_dr , & radialData ) ! The goal of this subroutine is to extract the mean flow data that we input plus the rest of the mean flow parameters ! that SWIRL generated ! TYPE ( SwirlClassType ), INTENT ( IN ) :: & object REAL ( KIND = rDef ), DIMENSION ( object % numberOfRadialPoints ), INTENT ( OUT ) :: & axialMach , & thetaMach , & axialMach_dr , & thetaMach_dr , & SoundSpeed , & SoundSpeed_dr , & radialData ! The data we originally sent in axialMach = object % rmx axialMach_dr = object % drm thetaMach = object % rmt thetaMach_dr = object % drt SoundSpeed = object % snd SoundSpeed_dr = object % dsn radialData = object % r END SUBROUTINE GetMeanData SUBROUTINE GetRadialModeData (& object , & eigenValue , & eigenVector , & eigenIndex ) TYPE ( SwirlClassType ), INTENT ( IN ) :: & object INTEGER , INTENT ( IN ) :: & eigenIndex COMPLEX ( KIND = rDef ), INTENT ( INOUT ) :: & eigenValue COMPLEX ( KIND = rDef ), DIMENSION ( object % numberOfRadialPoints * 4 ), INTENT ( INOUT ) :: & eigenVector ! INTEGER :: i eigenValue = object % wvn ( eigenIndex ) eigenVector = object % vr (:, eigenIndex ) END SUBROUTINE GetRadialModeData SUBROUTINE GetResidualVector (& object ,& eigenVector ,& eigenValue ,& S ) TYPE ( SwirlClassType ), INTENT ( IN ) :: & object COMPLEX ( KIND = rDef ), DIMENSION ( object % numberOfRadialPoints * 4 ), INTENT ( IN ) :: & eigenVector COMPLEX ( KIND = rDef ), INTENT ( IN ) :: & eigenValue COMPLEX ( KIND = rDef ), DIMENSION ( object % numberOfRadialPoints * 4 ), INTENT ( INOUT ) :: & S ! Local variables INTEGER :: np COMPLEX ( KIND = rDef ), DIMENSION ( object % numberOfRadialPoints * 4 ) :: & S_A , & S_B np = object % numberOfRadialPoints S_A = MATMUL ( object % aa_before , eigenVector ) S_B = MATMUL ( object % bb_before , eigenVector ) ! S_A =  MATMUL(object%S_aa,eigenVector) ! S_B =  MATMUL(object%S_bb,age vector) S = S_A - eigenValue * S_B END SUBROUTINE GetResidualVector SUBROUTINE SortModeData () END SUBROUTINE SortModeData SUBROUTINE DestroySwirlClassObject (& object ) TYPE ( SwirlClassType ), INTENT ( INOUT ) :: & object object % isInitialized = . FALSE . DEALLOCATE (& object % dl1 , & object % y , & object % rwork , & object % r , & object % rmx , & object % drm , & object % rmt , & object % drt , & object % snd , & object % SoundSpeedExpected , & object % soundSpeed_L2array , & object % dsn , & object % rho , & object % akap , & object % alpha , & object % beta , & object % work , & object % vph , & object % wvn , & object % aa , & object % S_aa , & object % aa_before , & object % bb , & object % S_bb , & object % bb_before , & object % vl , & object % vr , & object % S_MMS , & object % S_actual , & object % S_Expected , & object % S_1 ,& object % S_2 ,& object % S_3 ,& object % S_4 ,& object % vRad ,& object % vT ,& object % vX ,& object % Pr ,& object % eigenVectorMMS ) END SUBROUTINE DestroySwirlClassObject ! END MODULE swirlClassObject","tags":"","loc":"sourcefile/swirlclassobject.f90.html"},{"title":"InputVariables.f90 – Fortran Program","text":"Contents Source Code InputVariables.f90 Source Code r_min = 0.10_rDef r_max = 1.00_rDef hubToTipRatio = r_min / r_max azimuthalModeNumber = 2 numericalIntegrationFlag = 1 !    DO FDfac = 1,2 ! FDfac = 1 finiteDiffFlag = 1 ! finiteDiffFlag            = FDfac secondOrderSmoother = 0.0_rDef fourthOrderSmoother = 0.0_rDef ductAdmittance = CMPLX ( 0.0 , 0.0 , rDef ) hubAdmittance = CMPLX ( 0.0 , 0.0 , rDef ) frequency = CMPLX ( - 1.0 , 0 , rDef ) gam = 1.4_rDef","tags":"","loc":"sourcefile/inputvariables.f90.html"},{"title":"derivsModule.f90 – Fortran Program","text":"Contents Modules derivsModule Source Code derivsModule.f90 Source Code MODULE derivsModule USE , INTRINSIC :: ISO_FORTRAN_ENV IMPLICIT NONE PRIVATE PUBLIC :: derivs INTERFACE derivs MODULE PROCEDURE derivs1 END INTERFACE derivs CONTAINS subroutine derivs1 ( np , sig , dl1 , ed2 , ed4 ) ! !     implicit real*8 (a-h,o-z) !     parameter (NMAX = 128) !     dimension  DL1(NMAX,NMAX),dl2(NMAX,NMAX),dl4(NMAX,NMAX) !     dimension  trans(NMAX) INTEGER , PARAMETER :: rDef = REAL64 INTEGER , INTENT ( IN ) :: np REAL ( KIND = rDef ), INTENT ( IN ) :: sig , & ed2 , & ed4 REAL ( KIND = rDef ), DIMENSION (:,:), INTENT ( INOUT ) :: dl1 ! local variables INTEGER :: n , & nhalf , & i , & j , & k REAL ( KIND = rDef ) :: pi , & pinr , & pinh , & zero , & alpha , & sina , & xj , & xk , & cbk , & cbj , & xdif , & tot , & fac , & s1 , & s2 , & gpr REAL ( KIND = rDef ), DIMENSION ( np ) :: trans REAL ( KIND = rDef ), DIMENSION ( np , np ) :: dl2 , & dl4 ! !  COMPUTE ARRAY FOR CHEBYSHEV DIFFERENTIATION AT FACES. !   See Canuto, p.69. ! !  Modified to follow Wai Don and Solomonoff recommendations. ! WRITE ( 6 , * ) 'Entering derivs' n = np - 1 pi = 4.0_rDef * ATAN ( 1.0_rDef ) pinr = pi / REAL ( n , rDef ) pinh = 0.5_rDef * pinr zero = 1.11e-16_rDef alpha = 1.0_rDef / COSH ( ABS ( LOG ( zero )) / REAL ( n , rDef )) sina = ASIN ( alpha ) ! ! !DRH: bugfix 9/23/17.  nhalf calculation was incorrect !                      for odd number of input points. ! !     if (MOD(n,2).eq.0) then !      nhalf = np/2 !     else !      nhalf = np/2 +1 !     endif nhalf = CEILING ( 0.5_rDef * REAL ( np , rDef )) !     WRITE(6,*) 'derivs: n     = ',n !     WRITE(6,*) 'derivs: nhalf = ',nhalf ! do k = 1 , nhalf ! ! calculate x_k using Eqn. (3.2) ! xk = COS ( REAL ( k - 1 , rDef ) * pinr ) ! ! this is cBar_j in Eqn. (3.6) ! cbk = 1.0_rDef if ( k . eq . 1 . or . k . eq . np ) cbk = 2.0_rDef do j = 1 , np xj = COS ( REAL ( j - 1 , rDef ) * pinr ) cbj = 1.0_rDef if ( j . eq . 1 . or . j . eq . np ) cbj = 2.0_rDef ! Eqn. (3.8) if ( j . ne . k ) then xdif = - 2.0_rDef * SIN ( pinh * REAL ( k + j - 2 , rDef )) * SIN ( pinh * REAL ( k - j , rDef )) dl1 ( k , j ) = ( cbk / cbj ) * ( - 1.0_rDef ) ** ( k + j ) / xdif elseif ( k . eq . 1 ) then dl1 ( 1 , 1 ) = ( 2.0_rDef * REAL ( n * n , rDef ) + 1.0_rDef ) / 6.0_rDef else dl1 ( k , j ) = - xj / ( 2.0_rDef * SIN ( REAL ( j - 1 , rDef ) * pinr ) ** 2 ) endif enddo enddo do k = nhalf + 1 , np do j = 1 , np dl1 ( k , j ) = - dl1 ( np - k + 1 , np - j + 1 ) enddo enddo do k = 1 , np xk = COS ( REAL ( k - 1 , rDef ) * pinr ) gpr = alpha / sina / SQRT ( 1.0_rDef - ( alpha * xk ) ** 2 ) trans ( k ) = 1.0_rDef / gpr enddo do k = 1 , np fac = trans ( k ) do j = 1 , np dl1 ( k , j ) = fac * dl1 ( k , j ) enddo enddo ! ! Switch signs on 1st derivative matrix due to mesh orientation !  from -1 to 1. s1 = 1.0_rDef - sig s2 = 2.0_rDef / s1 do k = 1 , np do j = 1 , np dl1 ( k , j ) = - dl1 ( k , j ) * s2 enddo enddo ! ! Compute 2nd and 4th derivative matrices. do k = 1 , np do j = 1 , np tot = 0.0_rDef do i = 1 , np tot = tot + dl1 ( k , i ) * dl1 ( i , j ) enddo dl2 ( k , j ) = tot enddo enddo do k = 1 , np do j = 1 , np tot = 0.0_rDef do i = 1 , np tot = tot + dl2 ( k , i ) * dl2 ( i , j ) enddo dl4 ( k , j ) = tot enddo enddo ! ! Correct 1st derivative matrix using 2nd and 4th order smoothing. do k = 1 , np do j = 1 , np dl1 ( k , j ) = dl1 ( k , j ) + ed2 * dl2 ( k , j ) + ed4 * dl4 ( k , j ) enddo enddo ! WRITE ( 6 , * ) 'Leaving derivs' return end END MODULE derivsModule","tags":"","loc":"sourcefile/derivsmodule.f90.html"},{"title":"SourceTermNoFlowMMS.f90 – Fortran Program","text":"Contents Subroutines SourceCalc Source Code SourceTermNoFlowMMS.f90 Source Code ! gam - axial wavenumber t ! ak  - reduced frequency ! kappa - ratio of specific heats ! i - imaginary number SUBROUTINE SourceCalc (& r , & S_1 , & S_2 , & S_3 , & S_4 ) REAL ( KIND = rDef ) , DIMENSION (:), INTENT ( IN ) :: r COMPLEX ( KIND = rDef ), DIMENSION (:), INTENT ( INOUT ) :: S_1 , S_2 , S_3 , S_4 ! Local variables COMPLEX ( KIND = rDef ) :: i INTEGER :: jj , numberOfGridPoints i = CMPLX ( 0.0 , 1.0 , KIND = rDef ) numberOfGridPoints = SIZE ( r ) DO jj = 2 , numberOfGridPoints S_1 ( jj ) = - i * ( - 1 0.0d0 * 0.0 ) * ( - 0.0 * ( - 2.0d0 * r ( jj ) ** 3 + 3.0d0 * r ( jj ) ** 2 ) - 0.0 * ( & 2.0d0 * r ( jj ) ** 3 - 3.0d0 * r ( jj ) ** 2 + 1 ) + 0.0 ) - 6.0d0 * r ( jj ) ** 2 + 6.0d0 * r ( jj ) S_2 ( jj ) = 7.0d0 * i * ( - 2.0d0 * r ( jj ) ** 3 + 3.0d0 * r ( jj ) ** 2 ) / r ( jj ) S_3 ( jj ) = 1 0.0d0 * i * ( - 2.0d0 * r ( jj ) ** 3 + 3.0d0 * r ( jj ) ** 2 ) S_4 ( jj ) = - 0.0 * ( - 6.0d0 * r ( jj ) ** 2 + 6.0d0 * r ( jj )) - 0.0 * ( 6.0d0 * r ( jj ) ** 2 - 6.0d0 * r ( jj )) - i * ( - 1 0.0d0 * & 0.0 ) * ( - 2.0d0 * r ( jj ) ** 3 + 3.0d0 * r ( jj ) ** 2 ) + 1.0d0 * ( - 0.0 * ( & - 2.0d0 * r ( jj ) ** 3 + 3.0d0 * r ( jj ) ** 2 ) - 0.0 * ( 2.0d0 * r ( jj ) ** 3 - 3.0d0 * r ( jj ) ** 2 + 1 ) + & 0.0 ) / r ( jj ) END DO S_1 ( 1 ) = 0 S_2 ( 1 ) = 0 S_3 ( 1 ) = 1 0.0d0 * i * ( - 2.0d0 * r ( 1 ) ** 3 + 3.0d0 * r ( 1 ) ** 2 ) S_4 ( 1 ) = 1 0.0d0 * i * ( - 2.0d0 * r ( 1 ) ** 3 + 3.0d0 * r ( 1 ) ** 2 ) END SUBROUTINE SourceCalc","tags":"","loc":"sourcefile/sourcetermnoflowmms.f90.html"},{"title":"fdgridModule.f90 – Fortran Program","text":"Contents Modules fdgridModule Source Code fdgridModule.f90 Source Code MODULE fdgridModule USE , INTRINSIC :: ISO_FORTRAN_ENV IMPLICIT NONE PRIVATE PUBLIC :: fdgrid INTERFACE fdgrid MODULE PROCEDURE fdgrid1 END INTERFACE INTEGER , PARAMETER :: rDef = REAL64 CONTAINS subroutine fdgrid1 ( np , sig , x , r ) ! ! Finite difference grid; equally spaced. ! INTEGER , INTENT ( IN ) :: np REAL ( KIND = rDef ), INTENT ( IN ) :: sig REAL ( KIND = rDef ), DIMENSION (:), INTENT ( OUT ) :: x , & r ! define local variables INTEGER :: i REAL ( KIND = rDef ) :: sigbar , & coeff , & dx !     implicit real*8 (a-h,o-z) !     parameter (NMAX = 128, NMAX4 = NMAX*4) !     dimension r(NMAX),x(NMAX) ! sigbar = ( 1.0_rDef + sig ) / ( 1.0_rDef - sig ) coeff = 0.5_rDef * ( 1.0_rDef - sig ) dx = 2.0_rDef / REAL ( np - 1 , rDef ) do i = 1 , np x ( i ) = - 1.0_rDef + REAL ( i - 1 , rDef ) * dx r ( i ) = coeff * ( x ( i ) + sigbar ) end do ! return end END MODULE fdgridModule","tags":"","loc":"sourcefile/fdgridmodule.f90.html"},{"title":"interpModule.f90 – Fortran Program","text":"Contents Modules interpModule Source Code interpModule.f90 Source Code MODULE interpModule USE , INTRINSIC :: ISO_FORTRAN_ENV USE derivsModule USE fdgridModule USE fdrivsModule USE gridModule IMPLICIT NONE PRIVATE PUBLIC :: interp INTERFACE interp MODULE PROCEDURE interp1 END INTERFACE INTERFACE REAL FUNCTION curv2 ( t , n , x , y , yp , sigma ) INTEGER :: n REAL :: t REAL , DIMENSION (:) :: x , y , yp REAL :: sigma END FUNCTION curv2 END INTERFACE INTEGER , PARAMETER :: rDef = REAL64 , & rSP = REAL32 CONTAINS subroutine interp1 ( np , sig , rr , rmx , drm , rmt , drt , snd , dsn , dd , & ifdff , ed2 , ed4 ) INTEGER , INTENT ( IN ) :: np , & ifdff REAL ( KIND = rDef ), INTENT ( OUT ) :: sig REAL ( KIND = rDef ), INTENT ( IN ) :: ed2 , & ed4 REAL ( KIND = rDef ), DIMENSION (:), INTENT ( OUT ) :: rr , & rmx , & rmt , & snd REAL ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: drm , & drt , & dsn REAL ( KIND = rDef ), DIMENSION (:,:), INTENT ( INOUT ) :: dd ! ! local variables ! CHARACTER ( LEN = 1 ) :: trans CHARACTER ( LEN = 70 ) :: filenam INTEGER :: i , & ierr , & incx , & incy , & nvals , & islpsw , & nmax REAL ( KIND = rDef ) :: alpha , & beta REAL ( KIND = rSP ) :: r , & sigma , & slp1 , & slp2 , & rDum REAL ( KIND = rDef ), DIMENSION ( np ) :: yy REAL ( KIND = rSP ), DIMENSION ( np ) :: yp , & temp REAL ( KIND = rSP ), DIMENSION (:), ALLOCATABLE :: xx , & ymx , & ymt , & yab ! ! Use fitpack to interpolate the given Mach distributions onto an !  appropriate cosine mesh. ! !     implicit real*8 (a-h,o-z) !     parameter (NMAX = 128, NMAX4 = NMAX*4) !     dimension rr(NMAX),rmx(NMAX),rmt(NMAX),snd(NMAX),yy(NMAX) ! !     real*4 xx(NMAX),ymx(NMAX),ymt(NMAX),yab(NMAX),yp(NMAX) !     real*4 temp(NMAX),slp1,slp2,sigma,r,curv2 ! !     dimension drm(NMAX),drt(NMAX),dsn(NMAX) !     dimension dd(NMAX,NMAX) !      dimension x(NMAX),y(NMAX),abr(NMAX),dbr(NMAX) !     character*70 filenam !     character*1  trans ! WRITE ( 6 , * ) 'Entering interp' trans = 'N' alpha = 1.0_rDef beta = 0.0_rDef incx = 1 incy = 1 ! write ( 6 , 12 ) 12 format ( 1 x , 'Input file name containing Mach distributions.' ) read ( 5 , '(A70)' ) filenam ! ! Read in Mach values from data. nvals = 0 open ( unit = 10 , file = filenam , status = 'unknown' ) read ( 10 , '(1x)' ) 5 CONTINUE !     do i = 1,NMAX read ( 10 , * , end = 100 ) rDum , rDum , rDum , rDum nvals = nvals + 1 GO TO 5 !     enddo 100 continue REWIND ( 10 ) read ( 10 , '(1x)' ) ALLOCATE ( xx ( nvals ), & ymx ( nvals ), & ymt ( nvals ), & yab ( nvals )) DO i = 1 , nvals read ( 10 , * ) xx ( i ), ymx ( i ), ymt ( i ), yab ( i ) END DO close ( 10 ) sig = REAL ( xx ( 1 ), rDef ) / REAL ( xx ( nvals ), rDef ) if ( ifdff . eq . 0 ) then call grid ( np = np , & sig = sig , & x = yy , & r = rr ) call derivs ( np = np , & sig = sig , & dl1 = dd , & ed2 = ed2 , & ed4 = ed4 ) else call fdgrid ( np = np , & sig = sig , & x = yy , & r = rr ) call fdrivs ( np = np , & sig = sig , & dl1 = dd , & iorder = ifdff , & ed2 = ed2 , & ed4 = ed4 ) endif ! ! Call spline routines to fit distributions. slp1 = 0.0_rSP slp2 = 0.0_rSP islpsw = 3 sigma = 0.0_rSP ! ! Mx distribution. call curv1 ( nvals , xx , ymx , slp1 , slp2 , islpsw , yp , temp , sigma , ierr ) if ( ierr . ne . 0 ) write ( 6 , * ) ierr do i = 1 , np r = REAL ( rr ( i ), rSP ) rmx ( i ) = REAL ( curv2 ( r , nvals , xx , ymx , yp , sigma ), rDef ) enddo nmax = np call dgemv (& trans ,& !Specifies the type of operation np ,& np ,& alpha ,& dd ,& np ,& rmx ,& incx ,& beta ,& drm ,& incy ) ! Mt distribution. call curv1 (& nvals ,& xx ,& ymt ,& slp1 ,& slp2 ,& islpsw ,& yp ,& temp ,& sigma ,& ierr ) if ( ierr . ne . 0 ) write ( 6 , * ) ierr do i = 1 , np r = REAL ( rr ( i ), rSP ) rmt ( i ) = REAL ( curv2 ( r , nvals , xx , ymt , yp , sigma ), rDef ) enddo call dgemv (& trans ,& np ,& np ,& alpha ,& dd ,& np ,& rmt ,& incx ,& beta ,& drt ,& incy ) ! Abar distribution. call curv1 ( nvals , xx , yab , slp1 , slp2 , islpsw , yp , temp , sigma , ierr ) if ( ierr . ne . 0 ) write ( 6 , * ) ierr do i = 1 , np r = REAL ( rr ( i ), rSP ) snd ( i ) = REAL ( curv2 ( r , nvals , xx , yab , yp , sigma ), rDef ) enddo call dgemv (& trans ,& np ,& np ,& alpha ,& dd ,& np ,& snd ,& incx ,& beta ,& dsn ,& incy ) ! ! Calculate isentropic Abar distribution based on input Mt distribution. !$      gm    = 1.4 !$      do i = 1,np-1 !$       coeff = (1. -gm)/2. !$       r     = rr(i) !$       xlo   = r !$       xup   = rr(np) !$       n     = np -i +1 !$       do j = 1,np-i+1 !$        x(j) = rr(i+j-1) !$        y(j) = rmt(i+j-1)*rmt(i+j-1)/rr(i+j-1) !$       enddo !$       call davint(x,y,n,xlo,xup,ans,ierr) !$       abr(i) = exp(coeff*ans) !$       write(6,*) i,xlo,xup,n,abr(i),ierr !$      enddo !$      call dgemv(trans,np,np,alpha,dd,NMAX,abr,incx,beta,dbr,incy) ! open ( unit = 12 , file = 'spline.out' , status = 'unknown' ) rewind 12 write ( 12 , 15 ) 15 format ( '#' , 7 x , 'rr' , 10 x , 'Mx' , 10 x , 'Mt' , 9 x , 'Abar' , 9 x , 'Ab_isen' ) do i = 1 , np !       write(12,20) rr(i),rmx(i),rmt(i),snd(i),abr(i) write ( 12 , 20 ) rr ( i ), rmx ( i ), rmt ( i ), snd ( i ) enddo 20 format ( 5 f12 . 6 ) close ( 12 ) ! DEALLOCATE ( xx , & ymx , & ymt , & yab ) WRITE ( 6 , * ) 'Leaving interp' return end END MODULE interpModule","tags":"","loc":"sourcefile/interpmodule.f90.html"},{"title":"sndspdModule.f90 – Fortran Program","text":"Contents Modules sndspdModule Source Code sndspdModule.f90 Source Code MODULE sndspdModule USE , INTRINSIC :: ISO_FORTRAN_ENV IMPLICIT NONE PRIVATE PUBLIC :: sndspd INTERFACE sndspd MODULE PROCEDURE sndspd1 END INTERFACE sndspd INTEGER , PARAMETER :: rDef = REAL64 CONTAINS subroutine sndspd1 ( np , rr , rmsw , asnd , dsnd , dd , rhob , angom , gam , sig , is ) INTEGER , INTENT ( IN ) :: np , & is REAL ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: rr , & rmsw , & rhob REAL ( KIND = rDef ), DIMENSION (:,:), INTENT ( IN ) :: dd REAL ( KIND = rDef ), INTENT ( IN ) :: angom , & gam , & sig REAL ( KIND = rDef ), DIMENSION (:), INTENT ( OUT ) :: asnd , & dsnd ! ! local variables ! INTEGER :: j , & k REAL ( KIND = rDef ) :: gm , & gm1 , & r , & ang , & agm , & alg , & tot ! !     implicit real*8 (a-h,o-z) !     parameter (NMAX = 128) !     dimension rr(NMAX),rmsw(NMAX),asnd(NMAX),dsnd(NMAX),rhob(NMAX) !     dimension dd(NMAX,NMAX) ! gm = 1.4_rDef gm1 = gm - 1.0_rDef do j = 1 , np r = rr ( j ) ! ! is = 0: no swirl ! if ( is . eq . 0 ) then asnd ( j ) = 1.0_rDef dsnd ( j ) = 0.0_rDef ! ! is = 1: solid-body swirl ! elseif ( is . eq . 1 ) then asnd ( j ) = 1.0_rDef - gm1 / 2. * angom * angom * ( 1.0_rDef - r * r ) asnd ( j ) = sqrt ( asnd ( j )) dsnd ( j ) = gm1 * angom * angom * r / ( 2. * asnd ( j )) ! ! is = 2: free-vortex swirl ! elseif ( is . eq . 2 ) then asnd ( j ) = 1. - gm1 / 2. * gam * gam * ( 1. / ( r * r ) - 1. ) asnd ( j ) = sqrt ( asnd ( j )) dsnd ( j ) = gm1 * gam * gam / ( 2. * r * r * r * asnd ( j )) ! ! is = 3: both solid-body and free-vortex swirl ! elseif ( is . eq . 3 ) then ang = - gm1 / 2. * angom * angom * ( 1. - r * r ) agm = - gm1 / 2. * gam * gam * ( 1. / ( r * r ) - 1. ) alg = 2 * gm1 * angom * gam * log ( r ) asnd ( j ) = 1. + ang + agm + alg asnd ( j ) = sqrt ( asnd ( j )) dsnd ( j ) = gm1 / 2. * ( angom * r + gam / r ) ** 2 / ( r * asnd ( j )) ! ! is = 4: Vt = 1/r&#94;2; put in for stability tests ! elseif ( is . eq . 4 ) then asnd ( j ) = 1. - gm1 / 4. * gam * gam * ( 1. / ( r ** 4 ) - 1. ) asnd ( j ) = sqrt ( asnd ( j )) dsnd ( j ) = gm1 * gam * gam / ( 2. * r ** 5 * asnd ( j )) ! ! is = 6: constant swirl across the duct ! elseif ( is . eq . 6 ) then asnd ( j ) = 1. + gm1 * angom * angom * log ( r ) asnd ( j ) = sqrt ( asnd ( j )) dsnd ( j ) = gm1 * angom * angom / ( 2. * r * asnd ( j )) ! ! otherwise:  integrate to find the speed of sound ! -------this was commented out in the original code-------- ! else asnd ( j ) = 0. do i = np , j , - 1 if ( i . eq . np ) then asnd ( i ) = 0. else if ( rr ( i ). ne . 0. ) then rswi = rmsw ( i ) * rmsw ( i ) / rr ( i ) rsw1 = rmsw ( i + 1 ) * rmsw ( i + 1 ) / rr ( i + 1 ) xi = rr ( i ) x1 = rr ( i + 1 ) asnd ( i ) = asnd ( i + 1 ) + 0.5_rDef * ( rswi + rsw1 ) * ( xi - x1 ) else asnd ( i ) = 2.0_rDef * rmsw ( i ) * ( rmsw ( i + 1 ) - rmsw ( i )) / rr ( i + 1 ) endif endif enddo asnd ( j ) = exp ( - gm1 * asnd ( j )) endif enddo ! ! is = 5: read in swirl from file. ! if ( is . eq . 5 ) then do k = 1 , np tot = 0. do j = 1 , np tot = tot + dd ( k , j ) * asnd ( j ) enddo dsnd ( k ) = tot enddo endif ! return WRITE ( 6 , * ) rhob , rmsw , sig end END MODULE sndspdModule","tags":"","loc":"sourcefile/sndspdmodule.f90.html"},{"title":"smachModule.f90 – Fortran Program","text":"Contents Modules smachModule Source Code smachModule.f90 Source Code MODULE smachModule USE , INTRINSIC :: ISO_FORTRAN_ENV ! USE Akima1D IMPLICIT NONE PRIVATE PUBLIC :: smach INTERFACE smach MODULE PROCEDURE smach1 END INTERFACE smach INTEGER , PARAMETER :: rDef = REAL64 CONTAINS subroutine smach1 ( npts , rr , rmsw , rmswp , snd , dsn , dd , angom , gam , rro , is ) INTEGER , INTENT ( IN ) :: npts , & is REAL ( KIND = rDef ), INTENT ( IN ) :: angom , & gam , & rro REAL ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: rr , & snd , & dsn REAL ( KIND = rDef ), DIMENSION (:,:), INTENT ( IN ) :: dd REAL ( KIND = rDef ), DIMENSION (:), INTENT ( OUT ) :: rmsw , & rmswp ! ! local variables ! INTEGER :: i , & j , & k REAL ( KIND = rDef ) :: r , & tot REAL ( KIND = rDef ), DIMENSION ( npts ) :: vsw , & vswp INTEGER :: nptsIn REAL ( KIND = rDef ), DIMENSION (:), ALLOCATABLE :: rIn , & rmswIn ! !     implicit real*8 (a-h,o-z) !     parameter (NMAX = 128) !     dimension rmsw(NMAX),rmswp(NMAX),dd(NMAX,NMAX),rr(NMAX) !     dimension vsw(1024),vswp(1024) !     dimension snd(NMAX),dsn(NMAX) ! !  is = 0: no swirl !  is = 1: solid-body swirl; ang. vel. angom !  is = 2: free-vortex swirl; gam/r !  is = 3: solid-body and free-vortex swirl. !  is = 4: Vt = 1/r&#94;2; put in for stability tests. !  is = 5: read in swirl from file. !  is = 6: constant swirl across the duct; Vt = const. !  is = 7: trailing line vortex; Vt = Vmax/r (1 - e&#94;(-r&#94;2)) ! !  is = 0: no swirl ! if ( is . eq . 0 ) then do i = 1 , npts rmsw ( i ) = 0.0_rDef rmswp ( i ) = 0.0_rDef enddo ! !  is = 1: solid-body swirl; ang. vel. angom ! elseif ( is . eq . 1 ) then do i = 1 , npts r = rr ( i ) vsw ( i ) = angom * r vswp ( i ) = angom rmsw ( i ) = vsw ( i ) / snd ( i ) rmswp ( i ) = angom / snd ( i ) * ( 1.0_rDef - r / snd ( i ) * dsn ( i )) enddo ! !  is = 2: free-vortex swirl; gam/r ! elseif ( is . eq . 2 ) then do i = 1 , npts r = rr ( i ) vsw ( i ) = gam / r vswp ( i ) = - gam / ( r * r ) rmsw ( i ) = vsw ( i ) / snd ( i ) rmswp ( i ) = - gam / ( snd ( i ) * snd ( i ) * r * r ) * ( snd ( i ) + r * dsn ( i )) enddo ! !  is = 3: solid-body and free-vortex swirl. ! elseif ( is . eq . 3 ) then do i = 1 , npts r = rr ( i ) vsw ( i ) = angom * r + gam / r rmsw ( i ) = vsw ( i ) / snd ( i ) vswp ( i ) = angom - gam / ( r * r ) rmswp ( i ) = angom / snd ( i ) * ( 1.0_rDef - r / snd ( i ) * dsn ( i )) & - gam / ( snd ( i ) * snd ( i ) * r * r ) * ( snd ( i ) + r * dsn ( i )) enddo ! !  is = 4: Vt = 1/r&#94;2; put in for stability tests. ! elseif ( is . eq . 4 ) then do i = 1 , npts r = rr ( i ) vsw ( i ) = gam / ( r * r ) rmsw ( i ) = vsw ( i ) / snd ( i ) vswp ( i ) = - 2.0_rDef * gam / ( r * r * r ) rmswp ( i ) = - gam / ( r ** 3 * snd ( i ) ** 2 ) * ( 2.0_rDef * snd ( i ) + r * dsn ( i )) enddo ! !  is = 5: read in swirl from file. ! elseif ( is . eq . 5 ) then open ( unit = 24 , file = 'swrl.input' , status = 'unknown' ) READ ( 24 , * ) nptsIn ALLOCATE ( rIn ( nptsIn ), & rmswIn ( nPtsIn )) DO i = 1 , nptsIn READ ( 24 , * ) rIn ( i ), rmsw ( i ) END DO !      read (24,*) (rmsw(i), i = 1,npts) close ( 24 ) ! ! spline data onto grid ! ! CALL Akima433Interpolation(inputDataLength  = nptsIn, & !                            xInputData       = rIn,    & !                            yInputData       = rmswIn, & !                            outputDataLength = npts,   & !                            xOutputData      = rr,     & !                            yOutputData      = rmsw) DEALLOCATE ( rIn , rmswIn ) ! ! Spectral computation of M_theta'. do k = 1 , npts tot = 0.0_rDef do j = 1 , npts tot = tot + dd ( k , j ) * rmsw ( j ) enddo rmswp ( k ) = tot enddo ! !  is = 6: constant swirl across the duct; Vt = const. ! elseif ( is . eq . 6 ) then do i = 1 , npts r = rr ( i ) vsw ( i ) = angom rmsw ( i ) = vsw ( i ) / snd ( i ) vswp ( i ) = 0.0_rDef rmswp ( i ) = - angom / snd ( i ) * dsn ( i ) enddo ! !  is = 7: trailing line vortex; Vt = Vmax/r (1 - e&#94;(-r&#94;2)) ! elseif ( is . eq . 7 ) then do i = 1 , npts r = rr ( i ) vsw ( i ) = gam / r * ( 1.0_rDef - exp ( - r * r )) rmsw ( i ) = vsw ( i ) / snd ( i ) vswp ( i ) = 2.0_rDef * gam * exp ( - r * r ) - gam / ( r * r ) * ( 1.0_rDef - exp ( r * r )) ! ! Need to add rmswp calculation here. ! enddo endif ! ! Divide swirl velocity by speed of sound to get swirl Mach number. !$      if (is.ne.5) then !$       do i = 1,npts !$        rmsw(i)  = vsw(i)/snd(i) !$        rmswp(i) = vswp(i)/snd(i) -vsw(i)*dsn(i)/(snd(i)*snd(i)) !$       enddo !$      endif ! return WRITE ( 6 , * ) rro end END MODULE smachModule","tags":"","loc":"sourcefile/smachmodule.f90.html"},{"title":"SourceTermModule.f90 – Fortran Program","text":"Contents Modules SourceTermModule Source Code SourceTermModule.f90 Source Code MODULE SourceTermModule USE , INTRINSIC :: ISO_FORTRAN_ENV IMPLICIT NONE PRIVATE PUBLIC :: & getMMSSourceTerms ,& !getMMSSourceTermComponents ,& getSoundSpeed ,& getPerturbationVariables INTERFACE getMMSSourceTerms MODULE PROCEDURE SourceCalc END INTERFACE getMMSSourceTerms !    INTERFACE getMMSSourceTermComponents !        MODULE PROCEDURE SourceCalcComponents !    END INTERFACE getMMSSourceTermComponents ! INTERFACE getSoundSpeed MODULE PROCEDURE CalcSoundSpeed END INTERFACE getSoundSpeed INTERFACE getPerturbationVariables MODULE PROCEDURE CalcPerturbationVariables END INTERFACE getPerturbationVariables INTEGER , PARAMETER :: rDef = REAL64 CONTAINS include 'SourceTermMMS.f90' !include 'SourceTermComponentsMMS.f90' include 'SoundSpeedMMS.f90' include 'CalcPerturbationVariablesMMS.f90' END MODULE SourceTermModule","tags":"","loc":"sourcefile/sourcetermmodule.f90.html"},{"title":"CalcPerturbationVariablesMMS.f90 – Fortran Program","text":"Contents Subroutines CalcPerturbationVariables Source Code CalcPerturbationVariablesMMS.f90 Source Code SUBROUTINE CalcPerturbationVariables (& r , & vR , & vTh , & vX , & Pr ) REAL ( KIND = rDef ) , DIMENSION (:), INTENT ( IN ) :: r REAL ( KIND = rDef ) , DIMENSION (:), INTENT ( INOUT ) :: vR , vTh , vX , Pr ! Local variables INTEGER :: numberOfGridPoints , i numberOfGridPoints = SIZE ( vR ) DO i = 1 , numberOfGridPoints vR ( i ) = 0.261177694086339d0 * ( r ( i ) - 0.1d0 ) ** 3 - 0.352589887016558d0 * ( r ( i ) - 0.1d0 ) ** 2 & + 0.125d0 * tanh ( 1.1111111111111112d0 * r ( i ) - 1.1111111111111112d0 ) + & 0.0951992694944706d0 vTh ( i ) = 0.125d0 * tanh ( 2 2.222222222222221d0 * r ( i ) - 2 2.222222222222221d0 ) + 1 vX ( i ) = 0.125d0 * tanh ( 2 2.222222222222221d0 * r ( i ) - 2 2.222222222222221d0 ) + 1 Pr ( i ) = 0.792590998767432d0 * r ( i ) - 0.390069245506146d0 * ( r ( i ) - 0.1d0 ) ** 3 - & 0.529594344341616d0 * ( r ( i ) - 0.1d0 ) ** 2 + 0.125d0 * tanh ( & 1 1.111111111111111d0 * r ( i ) - 1 1.111111111111111d0 ) + & 0.920740900123257d0 END DO END SUBROUTINE CalcPerturbationVariables","tags":"","loc":"sourcefile/calcperturbationvariablesmms.f90.html"},{"title":"L2NormModule.f90 – Fortran Program","text":"Contents Modules L2NormModule Source Code L2NormModule.f90 Source Code ! L2NormModule.f90 - Calculates the L2_Norm = !                       sqrt( sum (dataError)/numberofPoints) ! MODULE L2NormModule USE , INTRINSIC :: ISO_FORTRAN_ENV IMPLICIT NONE PRIVATE PUBLIC :: getL2Norm INTERFACE getL2Norm MODULE PROCEDURE L2N MODULE PROCEDURE L2N_One_Dataset MODULE PROCEDURE L2N_One_Dataset_Complex MODULE PROCEDURE L2N_COMPLEX MODULE PROCEDURE L2N_2D END INTERFACE INTERFACE getLMax MODULE PROCEDURE LMax END INTERFACE getLMax INTEGER , PARAMETER :: rDef = REAL64 INTEGER :: i !,numPoints CONTAINS SUBROUTINE L2N ( L2 ,& dataSet1 ,& dataSet2 ) !lenDataSet = SIZE(dataSet) ! INTEGER, INTENT(INOUT) :: numPoints REAL ( KIND = rDef ), INTENT ( INOUT ) :: L2 REAL ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: dataSet1 ,& dataSet2 !Local variables within submodule only INTEGER :: numPoints REAL ( KIND = rDef ) :: dataSum REAL ( KIND = rDef ), DIMENSION (:), ALLOCATABLE :: dataError ,& dataErrorSquared numPoints = SIZE ( dataSet1 ) ALLOCATE ( dataError ( numPoints ), & dataErrorSquared ( numPoints )) dataSum = 0.0_rDef DO i = 1 , numPoints dataError ( i ) = ABS ( dataSet1 ( i ) - dataSet2 ( i )) dataErrorSquared ( i ) = dataError ( i ) ** 2 dataSum = dataSum + dataErrorSquared ( i ) ENDDO L2 = SQRT ( dataSum / REAL ( numPoints , rDef )) DEALLOCATE ( dataError , dataErrorSquared ) !WRITE(6,*) L2 END SUBROUTINE L2N SUBROUTINE L2N_One_Dataset ( L2 ,& dataSet ) !lenDataSet = SIZE(dataSet) ! INTEGER, INTENT(INOUT) :: numPoints REAL ( KIND = rDef ), INTENT ( INOUT ) :: & L2 REAL ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: & dataSet !Local variables within submodule only INTEGER :: & numPoints REAL ( KIND = rDef ) :: & dataSum REAL ( KIND = rDef ), DIMENSION (:), ALLOCATABLE :: & dataError ,& dataErrorSquared numPoints = SIZE ( dataSet ) ALLOCATE (& dataError ( numPoints ), & dataErrorSquared ( numPoints )) dataSum = 0.0_rDef DO i = 1 , numPoints dataError ( i ) = ABS ( dataSet ( i ) ) dataErrorSquared ( i ) = dataError ( i ) ** 2 dataSum = dataSum + dataErrorSquared ( i ) ENDDO L2 = SQRT ( dataSum / REAL ( numPoints , rDef )) DEALLOCATE ( dataError , dataErrorSquared ) !WRITE(6,*) L2 END SUBROUTINE L2N_One_Dataset SUBROUTINE L2N_One_Dataset_Complex ( L2 ,& dataSet ) !lenDataSet = SIZE(dataSet) ! INTEGER, INTENT(INOUT) :: numPoints COMPLEX ( KIND = rDef ), INTENT ( INOUT ) :: & L2 COMPLEX ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: & dataSet !Local variables within submodule only INTEGER :: & numPoints COMPLEX ( KIND = rDef ) :: & dataSum COMPLEX ( KIND = rDef ), DIMENSION (:), ALLOCATABLE :: & dataError ,& dataErrorSquared numPoints = SIZE ( dataSet ) ALLOCATE (& dataError ( numPoints ), & dataErrorSquared ( numPoints )) dataSum = CMPLX ( 0.0_rDef , 0.0_rDef , rDef ) DO i = 1 , numPoints dataError ( i ) = ( CMPLX ( dataSet ( i ) , KIND = rDef )) dataErrorSquared ( i ) = dataError ( i ) ** 2 dataSum = dataSum + dataErrorSquared ( i ) ENDDO L2 = SQRT ( dataSum / CMPLX ( numPoints , KIND = rDef )) DEALLOCATE ( dataError , dataErrorSquared ) !WRITE(6,*) L2 END SUBROUTINE L2N_One_Dataset_Complex SUBROUTINE L2N_COMPLEX ( L2 ,& dataSet1 ,& dataSet2 ) !,& numPoints) COMPLEX ( KIND = rDef ), INTENT ( INOUT ) :: L2 COMPLEX ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: dataSet1 ,& dataSet2 !Local variables within submodule only INTEGER :: numPoints COMPLEX ( KIND = rDef ) :: dataSum COMPLEX ( KIND = rDef ), DIMENSION (:), ALLOCATABLE :: dataError ,& dataErrorSquared numPoints = SIZE ( dataSet1 ) ALLOCATE (& dataError ( numPoints ) , & dataErrorSquared ( numPoints )) dataSum = CMPLX ( 0.0 , 0.0 , rDef ) DO i = 1 , numPoints dataError ( i ) = CMPLX ( ABS ( dataSet1 ( i ) - dataSet2 ( i )), KIND = rDef ) dataErrorSquared ( i ) = dataError ( i ) ** 2 dataSum = dataSum + dataErrorSquared ( i ) ENDDO L2 = SQRT ( dataSum / CMPLX ( numPoints , KIND = rDef )) DEALLOCATE ( dataError , dataErrorSquared ) END SUBROUTINE L2N_COMPLEX SUBROUTINE L2N_2D ( L2 ,& dataSet1 ,& dataSet2 ,& numPoints ) ! This will calculare the L2 Norm of a 2D array that ! has (numPoints,numPoints) dimension INTEGER :: j ! Index for the second dimension INTEGER , INTENT ( INOUT ) :: numPoints COMPLEX ( KIND = rDef ), INTENT ( INOUT ) :: L2 COMPLEX ( KIND = rDef ), DIMENSION (:,:), INTENT ( IN ) :: dataSet1 ,& dataSet2 !Local variables within submodule only REAL ( KIND = rDef ) :: dataSum REAL ( KIND = rDef ), DIMENSION ( numPoints , numPoints ) :: dataError ,& dataErrorSquared dataSum = 0.0_rDef DO i = 1 , numPoints DO j = 1 , numPoints dataError ( i , j ) = ABS ( dataSet1 ( i , j ) - dataSet2 ( i , j )) dataErrorSquared ( i , j ) = dataError ( i , j ) ** 2 dataSum = dataSum + dataErrorSquared ( i , j ) ENDDO ENDDO L2 = SQRT ( CMPLX ( dataSum , KIND = rDef ) & / CMPLX ( numPoints , KIND = rDef )) ! WRITE(6,*) L2 END SUBROUTINE L2N_2D SUBROUTINE LMax ( & LM , & dataSet ) REAL ( KIND = rDef ), INTENT ( INOUT ) :: LM REAL ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: dataSet LM = MAXVAL ( dataSet ) END SUBROUTINE LMax END MODULE L2NormModule","tags":"","loc":"sourcefile/l2normmodule.f90.html"},{"title":"gridModule.f90 – Fortran Program","text":"Contents Modules gridModule Source Code gridModule.f90 Source Code MODULE gridModule USE , INTRINSIC :: ISO_FORTRAN_ENV IMPLICIT NONE PRIVATE PUBLIC :: grid INTERFACE grid MODULE PROCEDURE grid1 END INTERFACE INTEGER , PARAMETER :: rDef = REAL64 CONTAINS subroutine grid1 ( np , sig , x , r ) ! !  COMPUTE THE CHEBYSHEV GAUSS-LOBATTO GRID, reversed. !    See Canuto, p. 67. ! !     implicit real*8 (a-h,o-z) !     parameter (NMAX = 128) INTEGER , INTENT ( IN ) :: np REAL ( KIND = rDef ), INTENT ( IN ) :: sig REAL ( KIND = rDef ), DIMENSION (:), INTENT ( OUT ) :: x , & ! np r ! np ! local variables INTEGER :: n , j REAL ( KIND = rDef ) :: alpha , & zero , & sina , & pi , & pin , & sigbar , & coeff , & yj !     real*8 x(NMAX),r(NMAX),alpha,zero,sina ! WRITE ( 6 , * ) 'Entering grid' PI = 4.0_rDef * ATAN ( 1.0_rDef ) n = np - 1 PIN = PI / REAL ( N , rDef ) zero = 1.11e-16_rDef alpha = 1.0_rDef / cosh ( abs ( log ( zero )) / REAL ( n , rDef )) sina = asin ( alpha ) sigbar = ( 1.0_rDef + sig ) / ( 1.0_rDef - sig ) coeff = 0.50_rDef * ( 1.0_rDef - sig ) DO j = 1 , NP x ( j ) = - COS ( REAL (( j - 1 ), rDef ) * PIN ) yj = asin ( - x ( j ) * alpha ) / sina r ( j ) = coeff * ( - yj + sigbar ) END DO WRITE ( 6 , * ) 'Leaving grid' ! return end SUBROUTINE grid1 END MODULE gridModule","tags":"","loc":"sourcefile/gridmodule.f90.html"},{"title":"egvModule.f90 – Fortran Program","text":"Contents Modules egvModule Source Code egvModule.f90 Source Code MODULE egvModule USE , INTRINSIC :: ISO_FORTRAN_ENV IMPLICIT NONE PRIVATE PUBLIC :: saveEGV INTERFACE saveEGV !MODULE PROCEDURE saveEGV1 MODULE PROCEDURE saveEGV2 END INTERFACE INTEGER , PARAMETER :: rDef = REAL64 CONTAINS !    SUBROUTINE saveEGV1(np,np4,vrm,rr) !        ! this was initially commented out in the original code !        INTEGER, INTENT(IN) :: np,& !            np4 ! !        REAL(KIND=rDef), DIMENSION(:),INTENT(IN) :: rr !        COMPLEX(KIND=rDef), DIMENSION(:,:), INTENT(IN) :: vrm ! !! Initialized character to append at the end of the file name !        CHARACTER(2) ::ff !        CHARACTER(15)::basen,basem !        INTEGER :: j,n, mf,  delta_egv, mn, mx, k, ncols, nf !!        INTEGER :: i,j,k,n, mf, mn, mx, nf, delta_egv,ncols !        INTEGER, DIMENSION(1000) :: nfile,mfile ! !! the output is currently done such that the real values are stored in basen and imaginary values are stored with basem !        delta_egv = 2 !        ncols = np4/delta_egv !        do n = 1,ncols+1 !            ! assign a value to the character variable ff, to be appended to the file names !            write(ff,'(i2.2)') n !            nfile(n) = 25 +n !            mfile(n) = 5500 +n ! !!            WRITE(0,*) nfile(n), mfile(n) !! redefining file name for each eigenvalue !            basen    = '04-EVanalysis/egvre.' !            basem    = '04-EVanalysis/egvim.' !            open(newunit=nfile(n),file=basen//ff,status='unknown') !            open(unit=mfile(n),file=basem//ff,status='unknown') !!            rewind nfile(n) !!            rewind mfile(n) !        enddo !!5    format('#',2i4,100e10.2) !!      if (egv .eq. 'V') then !        do j=1,np !            do n = 1,ncols+1 !                nf  = nfile(n) !                mf  = mfile(n) !                mn  = (n -1)*delta_egv +1 !                mx  = n*delta_egv !                if (n.eq.ncols+1) then !                    mx = min(mx,np4) !                endif !                write(nf,500) rr(j),(real(vrm(j+3*np,k)), k=mn,mx) !                write(mf,500) rr(j),(aimag(vrm(j+3*np,k)), k=mn,mx) !            enddo !        enddo !        !      endif !500     format(16e12.3) ! !        do n = 1,ncols+1 !            close(nfile(n)) !            close(mfile(n)) !        enddo ! !    END SUBROUTINE saveEGV1 SUBROUTINE saveEGV2 ( np , vrm , rr ) INTEGER , INTENT ( IN ) :: & np REAL ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: & rr COMPLEX ( KIND = rDef ), DIMENSION (:,:), INTENT ( IN ) :: & vrm ! ! Initialized character to append at the end of the file name CHARACTER ( 10 ) :: & ff CHARACTER ( 1000 ) :: & formatHeader , & formatData , & basen COMPLEX ( KIND = rDef ) :: & ci REAL ( KIND = rDef ) :: phi INTEGER :: j , n , np4 , myunit1 ci = CMPLX ( 0.0_rDef , 1.0_rDef , rDef ) formatHeader = \"(13a16)\" formatData = \"(13f16.12)\" np4 = np * 4 ! the output is currently done such that the real values are stored in basen and imaginary values are stored with basem DO n = 1 , np4 ! assign a value to the character variable ff, to be appended to the file names WRITE ( ff , '(i0.4)' ) n ! redefining file name for each eigenvalue basen = '04-EVanalysis/egv.' open ( newunit = myunit1 , file = TRIM ( ADJUSTL ( basen )) // TRIM ( ADJUSTL ( ff ))) !,status='old') WRITE ( myunit1 , formatHeader ) & 'Rad' , 'v_r[Re]' , 'v_t[Re]' , 'v_x[Re]' , 'p[Re]  ' , 'p_mg[Re]' , 'p_no_phase[Re]' , & 'v_r[Im]' , 'v_t[Im]' , 'v_x[Im]' , 'p[Im]  ' , 'p_mg[Im]' , 'p_no_phase[Im]' phi = atan2 ( aimag ( vrm ( np4 , n )), real ( vrm ( np4 , n ))) DO j = 1 , np write ( myunit1 , formatData ) & rr ( j ),& real ( vrm ( j , n )), & real ( vrm ( j + 1 * np , n )), & real ( vrm ( j + 2 * np , n )), & real ( vrm ( j + 3 * np , n )), & SQRT ( real ( vrm ( j + 3 , n )) ** 2.0_rDef + aimag ( vrm ( j + 3 , n )) ** 2.0_rDef ) , & real ( vrm ( j + 3 * np , n ) * exp ( - ci * phi )), & aimag ( vrm ( j , n )), & aimag ( vrm ( j + 1 * np , n )), & aimag ( vrm ( j + 2 * np , n )), & aimag ( vrm ( j + 3 * np , n )) ,& SQRT ( real ( vrm ( j + 3 , n )) ** 2.0_rDef + aimag ( vrm ( j + 3 , n )) ** 2.0_rDef ),& aimag ( vrm ( j + 3 * np , n ) * exp ( - ci * phi )) ENDDO close ( myunit1 ) ENDDO END SUBROUTINE saveEGV2 END MODULE egvModule","tags":"","loc":"sourcefile/egvmodule.f90.html"},{"title":"FindResidualVectorModule.f90 – Fortran Program","text":"Contents Modules FindResidualVectorModule Source Code FindResidualVectorModule.f90 Source Code MODULE FindResidualVectorModule USE , INTRINSIC :: ISO_FORTRAN_ENV ! USE L2NormModule IMPLICIT NONE PRIVATE PUBLIC :: getSvector INTERFACE getSvector MODULE PROCEDURE getSv1Dinput ! MODULE PROCEDURE getSv2Dinput END INTERFACE getSvector INTEGER , PARAMETER :: rDef = REAL64 CONTAINS SUBROUTINE getSv1Dinput (& A , & B , & x , & lambda , & np4 ,& S_MMS ) INTEGER , INTENT ( IN ) :: np4 COMPLEX ( KIND = REAL64 ), DIMENSION ( np4 , np4 ), INTENT ( IN ) :: A , & B COMPLEX ( KIND = REAL64 ), INTENT ( IN ) :: lambda COMPLEX ( KIND = REAL64 ), INTENT ( INOUT ), DIMENSION ( np4 ) :: S_MMS , x ! Local variables ! INTEGER:: i !, j, h, Q, jj WRITE ( 6 , * ) A , B , x , SIZE ( S_MMS ), lambda END SUBROUTINE getSv1Dinput !SUBROUTINE getSv2Dinput(& !    A, & !    B, & !    x, & !    lambda, & !    np4,& !    eigenIndex , & !    S_MMS ) !    INTEGER, INTENT(IN):: np4,eigenIndex !    COMPLEX(KIND = REAL64), DIMENSION(np4, np4), INTENT(IN):: A, & !        B,x !    COMPLEX(KIND = REAL64), DIMENSION(np4), INTENT(IN):: lambda !    COMPLEX(KIND = REAL64), INTENT(INOUT), DIMENSION(np4):: S_MMS !    ! Local variables !    ! INTEGER:: i !    !, j, h, Q, jj !    COMPLEX(KIND = REAL64),  DIMENSION(np4):: S_MMS_A, S_MMS_B !    ! WRITE(6,*) A,B,x,SIZE(S_MMS) !    S_MMS_A =MATMUL(A, x(:,eigenIndex)) !    S_MMS_B = MATMUL(B, x(:,eigenIndex)) !    S_MMS = S_MMS_A   - lambda(eigenIndex)*S_MMS_B !    ! WRITE(6,*) S_MMS !END SUBROUTINE getSv2Dinput END MODULE FindResidualVectorModule","tags":"","loc":"sourcefile/findresidualvectormodule.f90.html"},{"title":"kapsubModule.f90 – Fortran Program","text":"Contents Modules kapsubModule Source Code kapsubModule.f90 Source Code MODULE kapsubModule USE , INTRINSIC :: ISO_FORTRAN_ENV IMPLICIT NONE PRIVATE PUBLIC :: kappa INTERFACE kappa MODULE PROCEDURE kappa1 END INTERFACE kappa INTEGER , PARAMETER :: rDef = REAL64 CONTAINS subroutine kappa1 ( mm , mumax , sig , mu , akap ) INTEGER , INTENT ( IN ) :: mm , & mumax REAL ( KIND = rDef ), INTENT ( IN ) :: sig INTEGER , DIMENSION (:), INTENT ( INOUT ) :: mu REAL ( KIND = rDef ), DIMENSION (:), INTENT ( INOUT ) :: akap ! ! local variables ! INTEGER :: np , & np4 , & i , & kmax , & kpts , & mold REAL ( KIND = rDef ) :: pi , & rxmax COMPLEX ( KIND = rDef ) :: c0 , & ak , & etah , & etad CHARACTER :: jobvl , & jobvr REAL ( KIND = rDef ), DIMENSION (:), ALLOCATABLE :: rwork , & r , & rmx , & akappa INTEGER , DIMENSION (:), ALLOCATABLE :: mmu REAL ( KIND = rDef ), DIMENSION (:,:), ALLOCATABLE :: dl1 COMPLEX ( KIND = rDef ), DIMENSION (:), ALLOCATABLE :: alpha , & beta , & work , & wvn COMPLEX ( KIND = rDef ), DIMENSION (:,:), ALLOCATABLE :: aa , & bb , & vl , & vr ! !     implicit real*8 (a-h,o-z) !     parameter (NMAX = 128, NMAX4 = NMAX*4) !     parameter (PI = 3.141592653589793238462643) ! !     dimension dl1(NMAX,NMAX),rwork(8*NMAX4),r(NMAX) !     dimension rmx(NMAX),akap(NMAX),mu(NMAX) !     dimension mmu(NMAX),akappa(NMAX) !     character jobvl,jobvr ! !     complex*16 alpha(NMAX4),beta(NMAX4),work(2*NMAX4) !     complex*16 etah,etad,ak,c0 !     complex*16 aa(NMAX4,NMAX4),bb(NMAX4,NMAX4) !     complex*16 vl(NMAX4,NMAX4),vr(NMAX4,NMAX4),wvn(NMAX4) ! pi = 4.0_rDef * ATAN ( 1.0_rDef ) c0 = CMPLX ( 0.0_rDef , 0.0_rDef , rDef ) np = INT ( REAL ( mumax , rDef ) * PI + 1.0_rDef ) np4 = 4 * np ak = CMPLX ( 1 0.0_rDef , 0.0_rDef , rDef ) rxmax = 0.5_rDef jobvl = 'N' jobvr = 'V' etah = c0 etad = c0 ALLOCATE ( dl1 ( np , np ), & rwork ( 8 * np4 ), & r ( np ), & rmx ( np ), & mmu ( np ), & akappa ( np4 ), & alpha ( np4 ), & beta ( np4 ), & work ( 2 * np4 ), & aa ( np4 , np4 ), & bb ( np4 , np4 ), & vl ( np4 , np4 ), & vr ( np4 , np4 ), & wvn ( np4 )) ! CALL ugrid ( np = np , & sig = sig , & r = r ) CALL uderivs ( np = np , & sig = sig , & dl1 = dl1 ) CALL urmach ( npts = np , & rr = r , & rmch = rmx , & rxmax = rxmax ) CALL uglobal ( np = np , & np4 = np4 , & sig = sig , & mode = mm , & om = ak , & dd = dl1 , & rr = r , & rx = rmx , & aa = aa , & bb = bb ) CALL uboundary ( np = np , & sig = sig , & ak = ak , & etah = etah , & etad = etad , & rmx = rmx , & dd = dl1 , & aa = aa , & bb = bb ) CALL uanalysis ( np = np , & np4 = np4 , & ak = ak , & rr = r , & rmx = rmx , & aa = aa , & bb = bb , & alpha = alpha , & beta = beta , & vl = vl , & vr = vr , & work = work , & rwork = rwork , & gam = wvn , & jobvl = jobvl , & jobvr = jobvr , & mm = mm ) CALL uoutput ( np = np , & np4 = np4 , & mode = mm , & rho = sig , & omega = ak , & rmax = rxmax , & egv = jobvr , & attenh = etah , & attend = etad , & rmx = rmx , & rr = r , & wvn = wvn , & vrm = vr , & mu = mmu , & aksort = akappa ) ! kmax = 0 do i = 1 , np if ( mmu ( i ) . le . mumax ) then kmax = i endif enddo mold = 100 kpts = 0 do i = 1 , kmax if ( mmu ( i ) . ne . mold ) then kpts = kpts + 1 akap ( kpts ) = akappa ( i ) mu ( kpts ) = mmu ( i ) mold = mmu ( i ) endif enddo ! DEALLOCATE ( dl1 , & rwork , & r , & rmx , & mmu , & akappa , & alpha , & beta , & work , & aa , & bb , & vl , & vr , & wvn ) return end subroutine uanalysis ( np , np4 , ak , rr , rmx , aa , bb , alpha , beta , & vl , vr , work , rwork , gam , jobvl , jobvr , mm ) INTEGER , INTENT ( IN ) :: np , & np4 , & mm COMPLEX ( KIND = rDef ), INTENT ( IN ) :: ak REAL ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: rr , & rmx REAL ( KIND = rDef ), DIMENSION (:), INTENT ( INOUT ) :: rwork COMPLEX ( KIND = rDef ), DIMENSION (:), INTENT ( INOUT ) :: alpha , & beta , & work , & gam COMPLEX ( KIND = rDef ), DIMENSION (:,:), INTENT ( INOUT ) :: aa , & bb , & vl , & vr CHARACTER , INTENT ( IN ) :: jobvl , & jobvr ! local variables INTEGER :: j , & k , & info , & nmax4 LOGICAL :: badcol , & badrow LOGICAL , DIMENSION ( np4 ) :: col , & row REAL ( KIND = rDef ) :: eps , & rm COMPLEX ( KIND = rDef ) :: ci , & c0 ! !     implicit real*8 (a-h,o-z) !     parameter (NMAX = 128, NMAX4 = NMAX*4) ! !     dimension rwork(8*np4) !     character jobvl,jobvr !     logical   col(500),row(500),badrow,badcol ! !     complex*16 alpha(NMAX4),beta(NMAX4),work(2*NMAX4) !     complex*16 ci,c0,ak !     complex*16 aa(NMAX4,NMAX4),bb(NMAX4,NMAX4) !     complex*16 vl(NMAX4,NMAX4),vr(NMAX4,NMAX4),gam(NMAX4) !     dimension  rmx(NMAX),rr(NMAX) ! ci = CMPLX ( 0.0_rDef , 1.0_rDef , rDef ) eps = 1.e-8_rDef ! ! Compute convected wavenumbers.  Store them in a file. rm = rmx ( 1 ) ! ! Check for zero rows and columns in A. badcol = . false . do j = 1 , np4 col ( j ) = . true . do k = 1 , np4 if ( abs ( aa ( k , j )). gt . eps ) then col ( j ) = . false . endif enddo enddo do j = 1 , np4 if ( col ( j )) then write ( 6 , 20 ) j badcol = . true . endif enddo badrow = . false . do k = 1 , np4 row ( k ) = . true . do j = 1 , np4 if ( abs ( aa ( k , j )). gt . eps ) then row ( j ) = . false . endif enddo enddo do k = 1 , np4 if ( row ( k )) then write ( 6 , 25 ) k badrow = . true . endif enddo ! if ( badrow . or . badcol ) return 20 format ( 1 x , 'Column ' , i4 , ' contains all zeros.' ) 25 format ( 1 x , 'Row    ' , i4 , ' contains all zeros.' ) ! nmax4 = np4 !     CALL ZGEGV(JOBVL,JOBVR,np4,aa,NMAX4,bb,NMAX4,ALPHA,BETA, & !        VL,NMAX4,VR,NMAX4,WORK,2*NMAX4,RWORK,INFO ) ! ! ! updated call ! CALL ZGGEV ( JOBVL , & ! JOBVL JOBVR , & ! JOBVR np4 , & ! N aa , & ! A NMAX4 , & ! LDA bb , & ! B NMAX4 , & ! LDB ALPHA , & ! ALPHA BETA , & ! BETA VL , & ! VL NMAX4 , & ! LDVL VR , & ! VR NMAX4 , & ! LDVR WORK , & ! WORK 2 * NMAX4 , & ! LWORK RWORK , & ! RWORK INFO ) ! INFO ! c0 = CMPLX ( 0.0_rDef , 0.0_rDef , rDef ) ! ! Print the gammas to the display. do j = 1 , np4 if ( beta ( j ). ne . c0 ) then gam ( j ) = ci * alpha ( j ) / beta ( j ) if ( abs ( aimag ( gam ( j ))). lt . eps ) then gam ( j ) = cmplx ( real ( gam ( j )), 0.0_rDef , rDef ) endif endif enddo ! !10   format(1x,i4,9e13.6) return WRITE ( 6 , * ) ak , mm , np , rr end subroutine uboundary ( np , sig , ak , etah , etad , rmx , dd , aa , bb ) INTEGER , INTENT ( IN ) :: np REAL ( KIND = rDef ), INTENT ( IN ) :: sig COMPLEX ( KIND = rDef ), INTENT ( IN ) :: ak , & etah , & etad REAL ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: rmx REAL ( KIND = rDef ), DIMENSION (:,:), INTENT ( IN ) :: dd COMPLEX ( KIND = rDef ), DIMENSION (:,:), INTENT ( INOUT ) :: aa , & bb ! local variables INTEGER :: j REAL ( KIND = rDef ) :: eps , & etamag , & rmh , & rmd COMPLEX ( KIND = rDef ) :: & ci ,& c0 ! !     implicit real*8 (a-h,o-z) !     parameter (NMAX = 128, NMAX4 = NMAX*4) ! !     real*8     dd(NMAX,NMAX),rmx(NMAX),rmd,rmh !     complex*16 aa(4*NMAX,4*NMAX),bb(4*NMAX,4*NMAX),etah,etad,ci,ak ! ! Boundary conditions. ci = CMPLX ( 0.0_rDef , 1.0_rDef , rDef ) eps = 1.e-4_rDef ! c0 = CMPLX ( 0.0_rDef , 0.0_rDef , rDef ) etamag = abs ( etah ) + abs ( etad ) if ( etamag . gt . eps ) then rmh = rmx ( 1 ) rmd = rmx ( np ) aa ( np , np ) = ci * ak aa ( np , 2 * np ) = c0 do j = 1 , np aa ( np , 3 * np + j ) = c0 enddo aa ( np , 4 * np ) = - ci * ak * etad bb ( np , np ) = c0 bb ( np , 4 * np ) = etad * CMPLX ( rmd , KIND = rDef ) if ( sig . ne . 0.0_rDef ) then aa ( 1 , 1 ) = - ci * ak aa ( 1 , np + 1 ) = c0 do j = 1 , np aa ( 1 , 3 * np + j ) = c0 enddo aa ( 1 , 3 * np + 1 ) = - ci * ak * etah bb ( 1 , 1 ) = c0 bb ( 1 , 3 * np + 1 ) = etah * CMPLX ( rmh , KIND = rDef ) endif else if ( sig . ne . 0.0_rDef ) then do j = 1 , np aa ( 1 , np + j ) = c0 aa ( 1 , 3 * np + j ) = c0 bb ( 1 , j ) = c0 enddo endif do j = 1 , np aa ( np , np + j ) = c0 aa ( np , 3 * np + j ) = c0 bb ( np , j ) = c0 enddo endif ! return WRITE ( 6 , * ) ak , dd end subroutine uderivs ( np , sig , dl1 ) INTEGER , INTENT ( IN ) :: np REAL ( KIND = rDef ), INTENT ( IN ) :: sig REAL ( KIND = rDef ), DIMENSION (:,:), INTENT ( INOUT ) :: dl1 ! ! local variables ! INTEGER :: n , & i , & j , & k REAL ( KIND = rDef ) :: pi , & pinr , & pinh , & cbk , & cbj , & xdif , & sumj , & s1 , & s2 , & xj ! !     implicit real*8 (a-h,o-z) !     parameter (NMAX = 128, NMAX4 = NMAX*4) !     dimension  DL1(NMAX,NMAX) ! !  COMPUTE ARRAY FOR CHEBYSHEV DIFFERENTIATION AT FACES. !   See Canuto, p.69. ! n = np - 1 pi = 4.0_rDef * ATAN ( 1.0_rDef ) PINR = pi / REAL ( n , rDef ) PINH = 0.5_rDef * PINr ! do k = 1 , np cbk = 1.0_rDef if ( k . eq . 1 . or . k . eq . np ) cbk = 2.0_rDef do j = 1 , np xj = cos ( REAL ( j - 1 , rDef ) * pinr ) cbj = 1.0_rDef if ( j . eq . 1 . or . j . eq . np ) cbj = 2.0_rDef if ( j . ne . k ) then xdif = - 2.0_rDef * sin ( PINH * REAL ( k + j - 2 , rDef )) * sin ( PINH * REAL ( k - j , rDef )) dl1 ( k , j ) = ( cbk / cbj ) * ( - 1.0_rDef ) ** ( k + j ) / xdif elseif ( k . eq . 1 ) then dl1 ( 1 , 1 ) = ( 2.0_rDef * REAL ( n * n , rDef ) + 1.0_rDef ) / 6.0_rDef elseif ( k . eq . np ) then dl1 ( np , np ) = - ( 2.0_rDef * REAL ( n * n , rDef ) + 1.0_rDef ) / 6.0_rDef else dl1 ( k , j ) = - xj / ( 2.0_rDef * sin ( REAL ( j - 1 , rDef ) * PINR ) ** 2 ) endif enddo enddo ! ! Fix derivative matrix so that rows sum to zero. do i = 1 , np sumj = 0.0_rDef do j = 1 , np if ( i . ne . j ) sumj = sumj + dl1 ( i , j ) enddo dl1 ( i , i ) = - sumj enddo ! ! Switch signs on 1st derivative matrix due to mesh orientation !  from -1 to 1. s1 = 1.0_rDef - sig s2 = 2.0_rDef / s1 do k = 1 , np do j = 1 , np dl1 ( k , j ) = - dl1 ( k , j ) * s2 enddo enddo ! return end subroutine uglobal ( np , np4 , sig , mode , om , dd , rr , rx , aa , bb ) INTEGER , INTENT ( IN ) :: np , & np4 , & mode REAL ( KIND = rDef ), INTENT ( IN ) :: sig REAL ( KIND = rDef ), DIMENSION (:,:), INTENT ( IN ) :: dd REAL ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: rr , & rx COMPLEX ( KIND = rDef ), INTENT ( IN ) :: om COMPLEX ( KIND = rDef ), DIMENSION (:,:), INTENT ( OUT ) :: aa , & bb ! define local variables INTEGER :: j , & k REAL ( KIND = rDef ) :: r COMPLEX ( KIND = rDef ) :: ci ! !     implicit real*8 (a-h,o-z) !     parameter (NMAX = 128, NMAX4 = NMAX*4) ! !     dimension  dd(NMAX,NMAX),rx(NMAX),rr(NMAX) !     real*8     r !     complex*16 aa(NMAX4,NMAX4),bb(NMAX4,NMAX4),ci,om ! do j = 1 , np4 do k = 1 , np4 aa ( k , j ) = CMPLX ( 0.0_rDef , 0.0_rDef , rDef ) bb ( k , j ) = CMPLX ( 0.0_rDef , 0.0_rDef , rDef ) enddo enddo ! ci = CMPLX ( 0.0_rDef , 1.0_rDef , rDef ) ! ! Global matrices. do k = 1 , np r = rr ( k ) do j = 1 , np aa ( k , 3 * np + j ) = CMPLX ( dd ( k , j ), KIND = rDef ) aa ( 3 * np + k , j ) = CMPLX ( dd ( k , j ), KIND = rDef ) if ( k . eq . j ) then aa ( k , j ) = - ci * om aa ( np + k , np + j ) = - ci * om aa ( 2 * np + k , 2 * np + j ) = - ci * om aa ( 3 * np + k , 3 * np + j ) = - ci * om aa ( np + k , j ) = CMPLX ( 0.0_rDef , 0.0_rDef , rDef ) aa ( 2 * np + k , j ) = CMPLX ( 0.0_rDef , 0.0_rDef , rDef ) if ( r . ne . 0.0_rDef ) then aa ( np + k , 3 * np + j ) = ci * CMPLX ( mode , KIND = rDef ) / CMPLX ( r , KIND = rDef ) aa ( 3 * np + k , np + j ) = ci * CMPLX ( mode , KIND = rDef ) / CMPLX ( r , KIND = rDef ) aa ( 3 * np + k , j ) = aa ( 3 * np + k , j ) + CMPLX ( 1.0_rDef , KIND = rDef ) / CMPLX ( r , KIND = rDef ) else aa ( np + k , 3 * np + j ) = CMPLX ( 0.0_rDef , 0.0_rDef , rDef ) aa ( 3 * np + k , np + j ) = CMPLX ( 0.0_rDef , 0.0_rDef , rDef ) endif bb ( k , j ) = CMPLX ( rx ( j ), KIND = rDef ) bb ( np + k , np + j ) = CMPLX ( rx ( j ), KIND = rDef ) bb ( 2 * np + k , 2 * np + j ) = CMPLX ( rx ( j ), KIND = rDef ) bb ( 3 * np + k , 3 * np + j ) = CMPLX ( rx ( j ), KIND = rDef ) bb ( 2 * np + k , 3 * np + j ) = CMPLX ( 1.0_rDef , 0.0_rDef , rDef ) bb ( 3 * np + k , 2 * np + j ) = CMPLX ( 1.0_rDef , 0.0_rDef , rDef ) endif enddo enddo ! return WRITE ( 6 , * ) sig end subroutine ugrid ( np , sig , r ) INTEGER , INTENT ( IN ) :: np REAL ( KIND = rDef ), INTENT ( IN ) :: sig REAL ( KIND = rDef ), DIMENSION (:), INTENT ( OUT ) :: r ! ! local variables ! INTEGER :: j , & n REAL ( KIND = rDef ) :: pi , & pin , & sigbar , & coeff , & xx ! !  COMPUTE THE CHEBYSHEV GAUSS-LOBATTO GRID, reversed. !    See Canuto, p. 67. ! !     implicit real*8 (a-h,o-z) !     parameter (NMAX = 128, NMAX4 = NMAX*4) !     real*8 r(NMAX) ! PI = 4.0_rDef * ATAN ( 1.0_rDef ) n = np - 1 PIN = PI / REAL ( N , rDef ) sigbar = ( 1.0_rDef + sig ) / ( 1.0_rDef - sig ) coeff = 0.5_rDef * ( 1.0_rDef - sig ) DO j = 1 , NP xx = - COS ( REAL ( j - 1 , rDef ) * PIN ) r ( j ) = coeff * ( xx + sigbar ) END DO ! return end SUBROUTINE uINDEXX ( N , ARRIN , INDX ) INTEGER , INTENT ( IN ) :: n REAL ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: arrin INTEGER , DIMENSION (:), INTENT ( INOUT ) :: indx ! local variables INTEGER :: i , & j , & l , & ir , & indxt REAL ( KIND = rDef ) :: q !     DIMENSION ARRIN(N),INDX(N) DO 11 J = 1 , N INDX ( J ) = J 11 CONTINUE IF ( N . EQ . 1 ) RETURN L = N / 2 + 1 IR = N 10 CONTINUE IF ( L . GT . 1 ) THEN L = L - 1 INDXT = INDX ( L ) Q = ARRIN ( INDXT ) ELSE INDXT = INDX ( IR ) Q = ARRIN ( INDXT ) INDX ( IR ) = INDX ( 1 ) IR = IR - 1 IF ( IR . EQ . 1 ) THEN INDX ( 1 ) = INDXT RETURN ENDIF ENDIF I = L J = L + L 20 IF ( J . LE . IR ) THEN IF ( J . LT . IR ) THEN IF ( ARRIN ( INDX ( J )). LT . ARRIN ( INDX ( J + 1 ))) J = J + 1 ENDIF IF ( Q . LT . ARRIN ( INDX ( J ))) THEN INDX ( I ) = INDX ( J ) I = J J = J + J ELSE J = IR + 1 ENDIF GO TO 20 ENDIF INDX ( I ) = INDXT GO TO 10 END subroutine uoutput ( np , np4 , mode , rho , omega , rmax , egv , attenh , attend , & rmx , rr , wvn , vrm , mu , aksort ) INTEGER , INTENT ( IN ) :: np , & np4 , & mode INTEGER , DIMENSION (:), INTENT ( INOUT ) :: mu REAL ( KIND = rDef ), INTENT ( IN ) :: rho , & rmax REAL ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: rmx , & rr REAL ( KIND = rDef ), DIMENSION (:), INTENT ( INOUT ) :: aksort COMPLEX ( KIND = rDef ), INTENT ( IN ) :: omega , & attenh , & attend COMPLEX ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: wvn COMPLEX ( KIND = rDef ), DIMENSION (:,:), INTENT ( IN ) :: vrm CHARACTER , INTENT ( IN ) :: egv ! ! local variables ! INTEGER :: i , & ii , & j , & jtmp , & nkpts INTEGER , DIMENSION ( np4 ) :: izeros , & indx REAL ( KIND = rDef ) :: rx , & cv , & cvmin , & cvmax , & akx , & val , & vold , & eps , & akap , & alm1 , & alm2 , & gam1 , & gam2 , & gim1 , & gim2 , & pi REAL ( KIND = rDef ), DIMENSION ( np4 ) :: aindex , & akappa ! !     implicit real*8 (a-h,o-z) !     parameter (NMAX = 128, NMAX4 = NMAX*4) ! !     parameter   (PI = 3.14159265358979324) !     dimension   rr(NMAX),izeros(1024),index(1024),kndex(1024) !     dimension   rmx(NMAX),akappa(NMAX),aksort(NMAX),mu(NMAX) !     dimension   nfile(32),mfile(32) !     real*4      aindex(1024) !     real*8      rx !     complex*16  vrm(NMAX4,NMAX4),wvn(NMAX4),omega !     complex*16  vphi(NMAX4),attenh,attend !     character   egv !     character*2 ff !     character*6 basen,basem ! ! Compute convected wavenumber. pi = 4.0_rDef * ATAN ( 1.0_rDef ) rx = rmx ( 1 ) cv = real ( omega ) / rx if ( cv . gt . 0.0_rDef ) then cvmin = 0.9_rDef * cv cvmax = 1.1_rDef * cv else cvmin = 1.1_rDef * cv cvmax = 0.9_rDef * cv endif ! ! Compute kappas for acoustic modes. do i = 1 , np4 akx = real ( wvn ( i )) if ( akx . le . cvmin . or . akx . ge . cvmax ) then akap = ( rx * rx - 1.0_rDef ) * REAL ( wvn ( i )) * REAL ( wvn ( i )) & - 2.0_rDef * real ( omega ) * rx * REAL ( wvn ( i )) + real ( omega ) * real ( omega ) if ( akap . ge . 0.0_rDef ) then akappa ( i ) = sqrt ( akap ) izeros ( i ) = 0 vold = real ( vrm ( 3 * np + 1 , i )) do j = 3 * np + 2 , np4 val = real ( vrm ( j , i )) if ( val * vold . lt . 0.0_rDef ) then izeros ( i ) = izeros ( i ) + 1 endif vold = val enddo else izeros ( i ) = 100 endif else izeros ( i ) = 100 endif enddo ! ! Sort modes by number of zero crossings. do i = 1 , np4 aindex ( i ) = REAL ( izeros ( i ), rDef ) enddo CALL uindexx ( n = np4 , & arrin = aindex , & indx = indx ) ! ! Sort nonconvected modes into upstream and downstream. eps = 1.e-3_rDef !     do j=1,np4 do j = 1 , np4 - 1 if ( izeros ( indx ( j )). eq . izeros ( indx ( j + 1 ))) then gam1 = real ( wvn ( indx ( j ))) gam2 = real ( wvn ( indx ( j + 1 ))) if ( abs ( gam1 / gam2 - 1.0_rDef ). lt . eps ) then gim1 = aimag ( wvn ( indx ( j ))) gim2 = aimag ( wvn ( indx ( j + 1 ))) if ( gim1 . lt . gim2 ) then jtmp = indx ( j ) indx ( j ) = indx ( j + 1 ) indx ( j + 1 ) = jtmp endif else alm1 = 2.0_rDef * PI / gam1 alm2 = 2.0_rDef * PI / gam2 if ( abs ( alm1 ). lt . abs ( alm2 )) then jtmp = indx ( j ) indx ( j ) = indx ( j + 1 ) indx ( j + 1 ) = jtmp endif endif endif enddo nkpts = 0 do i = 1 , np4 ii = indx ( i ) if ( izeros ( ii ). ne . 100 ) then if ( abs ( real ( wvn ( ii ))). ge . eps ) then nkpts = nkpts + 1 aksort ( nkpts ) = akappa ( ii ) mu ( nkpts ) = izeros ( ii ) endif endif enddo ! return IF ( ABS ( attenh ) > 0.0_rDef ) CONTINUE IF ( ABS ( attend ) > 0.0_rDef ) CONTINUE WRITE ( 6 , * ) egv , mode , rho , rmax , rr end subroutine urmach ( npts , rr , rmch , rxmax ) INTEGER , INTENT ( IN ) :: npts REAL ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: rr REAL ( KIND = rDef ), DIMENSION (:), INTENT ( OUT ) :: rmch REAL ( KIND = rDef ), INTENT ( IN ) :: rxmax ! local variables INTEGER :: i ! !     implicit real*8 (a-h,o-z) !     parameter (NMAX = 128, NMAX4 = NMAX*4) !     dimension rmch(NMAX),rr(NMAX) ! !  ir = 0 : uniform ! do i = 1 , npts rmch ( i ) = rxmax enddo ! return IF ( MAXVAL ( rr ) > 0.0_rDef ) CONTINUE end END MODULE kapsubModule","tags":"","loc":"sourcefile/kapsubmodule.f90.html"},{"title":"machoutModule.f90 – Fortran Program","text":"Contents Modules machoutModule Source Code machoutModule.f90 Source Code MODULE machoutModule USE , INTRINSIC :: ISO_FORTRAN_ENV IMPLICIT NONE PRIVATE PUBLIC :: machout INTERFACE machout MODULE PROCEDURE machout1 END INTERFACE machout INTEGER , PARAMETER :: rDef = REAL64 CONTAINS subroutine machout1 ( npts , rr , rmch , rmchp , rmsw , rmswp , snd , dsn , rhob ) INTEGER , INTENT ( IN ) :: npts REAL ( KIND = rDef ), DIMENSION (:), INTENT ( IN ) :: rr , & rmch , & rmchp , & rmsw , & rmswp , & snd , & dsn REAL ( KIND = rDef ), DIMENSION (:), INTENT ( OUT ) :: rhob ! ! local variables ! INTEGER :: i REAL ( KIND = rDef ) :: r , & rm , & rt , & rtot , & pbar ! !     implicit real*8 (a-h,o-z) !     parameter (NMAX = 128, NMAX4 = NMAX*4) !     dimension rr(NMAX),rmch(NMAX),rmchp(NMAX),rmsw(NMAX),rmswp(NMAX) !     dimension snd(NMAX),dsn(NMAX),rhob(NMAX) ! !  Output Mach number, shear, and swirl distributions. open ( unit = 21 , & file = 'mach.dat' , & status = 'unknown' ) rewind 21 write ( 21 , 5 ) 5 format ( '#' , 5 x , 'r' , 8 x , 'M_x' , 5 x , 'dM_x/dr' , 5 x , 'M_th' , 3 x , 'dM_th/dr' , & 4 x , 'M_tot' , 7 x , 'A' , 8 x , 'dA/dr' , 5 x , 'rhob' , 6 x , 'pbar' ) open ( unit = 22 , & file = 'machOut.dat' , & status = 'unknown' ) rewind ( 22 ) WRITE ( 22 , * ) nPts do i = 1 , npts r = rr ( i ) rm = rmch ( i ) rt = rmsw ( i ) rtot = sqrt ( rm * rm + rt * rt ) rhob ( i ) = snd ( i ) ** 5 pbar = snd ( i ) ** 7 write ( 21 , 10 ) r , rm , rmchp ( i ), rt , rmswp ( i ), rtot , snd ( i ), dsn ( i ), & rhob ( i ), pbar write ( 22 , * ) r , rm , rt , rhob ( i ), pbar , snd ( i ) enddo 10 format ( 1 0e15 . 4 ) close ( 21 ) close ( 22 ) ! return end END MODULE machoutModule","tags":"","loc":"sourcefile/machoutmodule.f90.html"},{"title":"SourceTermMMS-checkpoint.f90 – Fortran Program","text":"Contents Subroutines SourceCalc Source Code SourceTermMMS-checkpoint.f90 Source Code ! gam - axial wavenumber t ! ak  - reduced frequency ! kappa - ratio of specific heats ! i - imaginary number SUBROUTINE SourceCalc (& gam , & i , & ak , & kappa , & m , & r , & r_max , & S_1 , & S_2 , & S_3 , & S_4 ) INTEGER , INTENT ( IN ) :: m REAL ( KIND = rDef ) , INTENT ( IN ) :: kappa , r , r_max !REAL(KIND=rDef)   , DIMENSION(:), INTENT(IN) :: r_loc COMPLEX ( KIND = rDef ), INTENT ( IN ) :: i , gam , ak COMPLEX ( KIND = rDef ), INTENT ( INOUT ) :: S_1 , S_2 , S_3 , S_4 ! Local variables COMPLEX ( KIND = rDef ) :: mC , kappaC , rC , r_maxC COMPLEX ( KIND = rDef ) :: one , two , three one = CMPLX ( 1.0 , KIND = rDef ) two = CMPLX ( 2.0 , KIND = rDef ) three = CMPLX ( 3.0 , KIND = rDef ) mC = CMPLX ( m , KIND = rDef ) kappaC = CMPLX ( kappa , KIND = rDef ) rC = CMPLX ( r , KIND = rDef ) r_maxC = CMPLX ( r_max , KIND = rDef ) S_1 = - i * ( - 1.58113883008419d0 * mC * sqrt ( r * ( - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) ** 2 - & 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) ** 2 - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) ** 2 + & 0.00422231256821366d0 ) / ( 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) + 1 )) / r - & 0.125d0 * tanh ( 6 2.5d0 * r - 6 2.5d0 ) - 0.125d0 * tanh ( 6 2.5d0 * r - 5 0.0d0 & ) - 0.125d0 * tanh ( 6 2.5d0 * r - 3 7.5d0 ) - 0.125d0 * tanh ( 6 2.5d0 * r - & 2 5.0d0 ) - 0.125d0 * tanh ( 6 2.5d0 * r - 1 2.5d0 ) - 0.500000000003472d0 + & 1 0.0d0 / ( 0.1875d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) + 0.1875d0 * tanh ( 0.0037499999999999999d0 * & r - 0.0022500000000000003d0 ) + 0.1875d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) + & 0.999156251898431d0 )) * ( 2.05447160938161d0 * ( r - 0.2d0 ) ** 3 - & 2.46536593125793d0 * ( r - 0.2d0 ) ** 2 + 0.125d0 * tanh ( 1.25d0 * r - & 1.25d0 ) + 0.125d0 * tanh ( 1.25d0 * r - 1.0d0 ) + 0.125d0 * tanh ( 1.25d0 * r & - 0.75d0 ) + 0.125d0 * tanh ( 1.25d0 * r - 0.5d0 ) + 0.125d0 * tanh ( 1.25d0 * & r - 0.25d0 ) + 0.262972366000846d0 ) + 1 1.5295969398069d0 * r - & 1 4.0976514193326d0 * ( r - 0.2d0 ) ** 2 - 1.5625d0 * tanh ( 1 2.5d0 * r - & 1 2.5d0 ) ** 2 - 1.5625d0 * tanh ( 1 2.5d0 * r - 1 0.0d0 ) ** 2 - 1.5625d0 * tanh ( & 1 2.5d0 * r - 7.5d0 ) ** 2 - 1.5625d0 * tanh ( 1 2.5d0 * r - 5.0d0 ) ** 2 - & 1.5625d0 * tanh ( 1 2.5d0 * r - 2.5d0 ) ** 2 + 3.90224080557348d0 - & 1.58113883008419d0 * two * sqrt ( r * ( - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) ** 2 - & 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) ** 2 - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) ** 2 + & 0.00422231256821366d0 ) / ( 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) + 1 )) * ( & 0.125d0 * tanh ( 2 5.0d0 * r - 2 5.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r - 2 0.0d0 & ) + 0.125d0 * tanh ( 2 5.0d0 * r - 1 5.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r - & 1 0.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r - 5.0d0 ) + 0.500011349982487d0 ) / r & + ( 1.58113883008419d0 * sqrt ( r * ( - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) ** 2 - & 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) ** 2 - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) ** 2 + & 0.00422231256821366d0 ) / ( 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) + 1 ))) ** two & * ( 1.4d0 - one ) * ( - 1.60433980646514d0 * r - 4.69921713977753d0 * ( r - & 0.2d0 ) ** 3 + 5.76479846990345d0 * ( r - 0.2d0 ) ** 2 + 0.125d0 * tanh ( & 1 2.5d0 * r - 1 2.5d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r - 1 0.0d0 ) + 0.125d0 * & tanh ( 1 2.5d0 * r - 7.5d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r - 5.0d0 ) + 0.125d0 & * tanh ( 1 2.5d0 * r - 2.5d0 ) + 0.82255260048212d0 ) / r S_2 = i * mC * ( - 1.60433980646514d0 * r - 4.69921713977753d0 * ( r - 0.2d0 ) ** 3 + & 5.76479846990345d0 * ( r - 0.2d0 ) ** 2 + 0.125d0 * tanh ( 1 2.5d0 * r - & 1 2.5d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r - 1 0.0d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r & - 7.5d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r - 5.0d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r & - 2.5d0 ) + 0.82255260048212d0 ) / r - i * ( 0.125d0 * tanh ( 2 5.0d0 * r - & 2 5.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r - 2 0.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r & - 1 5.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r - 1 0.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 & * r - 5.0d0 ) + 0.500011349982487d0 ) * ( - 1.58113883008419d0 * mC * sqrt ( r * & ( - 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) ** 2 - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) ** 2 - & 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) ** 2 + 0.00422231256821366d0 ) / ( & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) + 1 )) / r - 0.125d0 * tanh ( 6 2.5d0 * r - & 6 2.5d0 ) - 0.125d0 * tanh ( 6 2.5d0 * r - 5 0.0d0 ) - 0.125d0 * tanh ( 6 2.5d0 * r & - 3 7.5d0 ) - 0.125d0 * tanh ( 6 2.5d0 * r - 2 5.0d0 ) - 0.125d0 * tanh ( 6 2.5d0 & * r - 1 2.5d0 ) - 0.500000000003472d0 + 1 0.0d0 / ( 0.1875d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) + 0.1875d0 * & tanh ( 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) + & 0.1875d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) + 0.999156251898431d0 )) + ( & 1.58113883008419d0 * sqrt ( r * ( - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) ** 2 - & 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) ** 2 - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) ** 2 + & 0.00422231256821366d0 ) / ( 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) + 1 )) * ( & 0.5d0 * r * ( - 0.00140743752273789d0 * ( 0.0075d0 - 0.0075d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) ** 2 ) * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) - & 0.00140743752273789d0 * ( 0.0075d0 - 0.0075d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) ** 2 ) * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) - & 0.00140743752273789d0 * ( 0.0075d0 - 0.0075d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) ** 2 ) * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 )) / ( & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) + 1 ) + 0.5d0 * r * ( - 0.00140743752273789d0 * & tanh ( 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) ** 2 - & 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) ** 2 - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) ** 2 + & 0.00422231256821366d0 ) * ( 0.000703718761368943d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) ** 2 + & 0.000703718761368943d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) ** 2 + 0.000703718761368943d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) ** 2 - & 0.00211115628410683d0 ) / ( 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) + 1 ) ** 2 + & 0.5d0 * ( - 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) ** 2 - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) ** 2 - & 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) ** 2 + 0.00422231256821366d0 ) / ( & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) + 1 )) * ( 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) + 1 ) / ( r * ( & - 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) ** 2 - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) ** 2 - & 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) ** 2 + 0.00422231256821366d0 )) + & 1.58113883008419d0 * sqrt ( r * ( - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) ** 2 - & 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) ** 2 - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) ** 2 + & 0.00422231256821366d0 ) / ( 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) + 1 )) / r + ( & 1.58113883008419d0 * sqrt ( r * ( - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) ** 2 - & 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) ** 2 - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) ** 2 + & 0.00422231256821366d0 ) / ( 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) + 1 ))) ** & three * ( 1.4d0 - one ) / ( r * two )) * ( 2.05447160938161d0 * ( r - 0.2d0 ) ** 3 - & 2.46536593125793d0 * ( r - 0.2d0 ) ** 2 + 0.125d0 * tanh ( 1.25d0 * r - & 1.25d0 ) + 0.125d0 * tanh ( 1.25d0 * r - 1.0d0 ) + 0.125d0 * tanh ( 1.25d0 * r & - 0.75d0 ) + 0.125d0 * tanh ( 1.25d0 * r - 0.5d0 ) + 0.125d0 * tanh ( 1.25d0 * & r - 0.25d0 ) + 0.262972366000846d0 ) S_3 = 1 0.0d0 * i * one * ( - 1.60433980646514d0 * r - 4.69921713977753d0 * ( r - 0.2d0 ) ** 3 & + 5.76479846990345d0 * ( r - 0.2d0 ) ** 2 + 0.125d0 * tanh ( 1 2.5d0 * r - & 1 2.5d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r - 1 0.0d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r & - 7.5d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r - 5.0d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r & - 2.5d0 ) + 0.82255260048212d0 ) - i * ( 0.125d0 * tanh ( 2 5.0d0 * r - & 2 5.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r - 2 0.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r & - 1 5.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r - 1 0.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 & * r - 5.0d0 ) + 0.500011349982487d0 ) * ( - 1.58113883008419d0 * mC * sqrt ( r * & ( - 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) ** 2 - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) ** 2 - & 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) ** 2 + 0.00422231256821366d0 ) / ( & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) + 1 )) / r - 0.125d0 * tanh ( 6 2.5d0 * r - & 6 2.5d0 ) - 0.125d0 * tanh ( 6 2.5d0 * r - 5 0.0d0 ) - 0.125d0 * tanh ( 6 2.5d0 * r & - 3 7.5d0 ) - 0.125d0 * tanh ( 6 2.5d0 * r - 2 5.0d0 ) - 0.125d0 * tanh ( 6 2.5d0 & * r - 1 2.5d0 ) - 0.500000000003472d0 + 1 0.0d0 / ( 0.1875d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) + 0.1875d0 * & tanh ( 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) + & 0.1875d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) + 0.999156251898431d0 )) + ( - 0.78125d0 * & tanh ( 6 2.5d0 * r - 6 2.5d0 ) ** 2 - 0.78125d0 * tanh ( 6 2.5d0 * r - 5 0.0d0 ) ** 2 & - 0.78125d0 * tanh ( 6 2.5d0 * r - 3 7.5d0 ) ** 2 - 0.78125d0 * tanh ( 6 2.5d0 * r & - 2 5.0d0 ) ** 2 - 0.78125d0 * tanh ( 6 2.5d0 * r - 1 2.5d0 ) ** 2 + 3.90625d0 + & ( 1.58113883008419d0 * sqrt ( r * ( - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) ** 2 - & 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) ** 2 - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) ** 2 + & 0.00422231256821366d0 ) / ( 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) + 1 ))) ** two & * ( 1.4d0 - one ) * ( 0.0125d0 * tanh ( 6 2.5d0 * r - 6 2.5d0 ) + 0.0125d0 * tanh ( & 6 2.5d0 * r - 5 0.0d0 ) + 0.0125d0 * tanh ( 6 2.5d0 * r - 3 7.5d0 ) + 0.0125d0 * & tanh ( 6 2.5d0 * r - 2 5.0d0 ) + 0.0125d0 * tanh ( 6 2.5d0 * r - 1 2.5d0 ) + & 0.0500000000003472d0 ) / ( r * two )) * ( 2.05447160938161d0 * ( r - 0.2d0 ) ** 3 & - 2.46536593125793d0 * ( r - 0.2d0 ) ** 2 + 0.125d0 * tanh ( 1.25d0 * r - & 1.25d0 ) + 0.125d0 * tanh ( 1.25d0 * r - 1.0d0 ) + 0.125d0 * tanh ( 1.25d0 * r & - 0.75d0 ) + 0.125d0 * tanh ( 1.25d0 * r - 0.5d0 ) + 0.125d0 * tanh ( 1.25d0 * & r - 0.25d0 ) + 0.262972366000846d0 ) S_4 = i * mC * ( 0.125d0 * tanh ( 2 5.0d0 * r - 2 5.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r - 2 0.0d0 ) + & 0.125d0 * tanh ( 2 5.0d0 * r - 1 5.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r - 1 0.0d0 & ) + 0.125d0 * tanh ( 2 5.0d0 * r - 5.0d0 ) + 0.500011349982487d0 ) / r + & 1 0.0d0 * i * one * ( 0.125d0 * tanh ( 2 5.0d0 * r - 2 5.0d0 ) + 0.125d0 * tanh ( & 2 5.0d0 * r - 2 0.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r - 1 5.0d0 ) + 0.125d0 * & tanh ( 2 5.0d0 * r - 1 0.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r - 5.0d0 ) + & 0.500011349982487d0 ) - i * ( - 1.58113883008419d0 * mC * sqrt ( r * ( & - 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) ** 2 - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) ** 2 - & 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) ** 2 + 0.00422231256821366d0 ) / ( & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) + 1 )) / r - 0.125d0 * tanh ( 6 2.5d0 * r - & 6 2.5d0 ) - 0.125d0 * tanh ( 6 2.5d0 * r - 5 0.0d0 ) - 0.125d0 * tanh ( 6 2.5d0 * r & - 3 7.5d0 ) - 0.125d0 * tanh ( 6 2.5d0 * r - 2 5.0d0 ) - 0.125d0 * tanh ( 6 2.5d0 & * r - 1 2.5d0 ) - 0.500000000003472d0 + 1 0.0d0 / ( 0.1875d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) + 0.1875d0 * & tanh ( 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) + & 0.1875d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) + 0.999156251898431d0 )) * ( & - 1.60433980646514d0 * r - 4.69921713977753d0 * ( r - 0.2d0 ) ** 3 + & 5.76479846990345d0 * ( r - 0.2d0 ) ** 2 + 0.125d0 * tanh ( 1 2.5d0 * r - & 1 2.5d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r - 1 0.0d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r & - 7.5d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r - 5.0d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r & - 2.5d0 ) + 0.82255260048212d0 ) - 4.93073186251587d0 * r + & 6.16341482814484d0 * ( r - 0.2d0 ) ** 2 + ( one / r + ( 1.58113883008419d0 * & sqrt ( r * ( - 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) ** 2 - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) ** 2 - & 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) ** 2 + 0.00422231256821366d0 ) / ( & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) + 1 ))) ** two * ( one + 1.4d0 ) / ( r * two )) * ( & 2.05447160938161d0 * ( r - 0.2d0 ) ** 3 - 2.46536593125793d0 * ( r - 0.2d0 & ) ** 2 + 0.125d0 * tanh ( 1.25d0 * r - 1.25d0 ) + 0.125d0 * tanh ( 1.25d0 * r - & 1.0d0 ) + 0.125d0 * tanh ( 1.25d0 * r - 0.75d0 ) + 0.125d0 * tanh ( 1.25d0 * r & - 0.5d0 ) + 0.125d0 * tanh ( 1.25d0 * r - 0.25d0 ) + 0.262972366000846d0 & ) - 0.15625d0 * tanh ( 1.25d0 * r - 1.25d0 ) ** 2 - 0.15625d0 * tanh ( 1.25d0 * & r - 1.0d0 ) ** 2 - 0.15625d0 * tanh ( 1.25d0 * r - 0.75d0 ) ** 2 - 0.15625d0 * & tanh ( 1.25d0 * r - 0.5d0 ) ** 2 - 0.15625d0 * tanh ( 1.25d0 * r - 0.25d0 ) ** 2 & + 1.76739637250317d0 END SUBROUTINE SourceCalc","tags":"","loc":"sourcefile/sourcetermmms-checkpoint.f90.html"},{"title":"SourceTermComponentsMMS-checkpoint.f90 – Fortran Program","text":"Contents Subroutines SourceCalcComponents Source Code SourceTermComponentsMMS-checkpoint.f90 Source Code ! gam - axial wavenumber t ! ak  - reduced frequency ! kappa - ratio of specific heats ! i - imaginary number SUBROUTINE SourceCalcComponents (& gam , & i , & ak , & kappa , & m , & r , & r_max , & S_1 , & S_2 , & S_3 , & S_4 , & S_A11 , & S_A12 , & S_A13 , & S_A14 , & S_A21 , & S_A22 , & S_A23 , & S_A24 , & S_A31 , & S_A32 , & S_A33 , & S_A34 , & S_A41 , & S_A42 , & S_A43 , & S_A44 , & S_B11 , & S_B12 , & S_B13 , & S_B14 , & S_B21 , & S_B22 , & S_B23 , & S_B24 , & S_B31 , & S_B32 , & S_B33 , & S_B34 , & S_B41 , & S_B42 , & S_B43 , & S_B44 ) INTEGER , INTENT ( IN ) :: m REAL ( KIND = rDef ) , INTENT ( IN ) :: kappa , r , r_max !REAL(KIND=rDef)   , DIMENSION(:), INTENT(IN) :: r_loc COMPLEX ( KIND = rDef ), INTENT ( IN ) :: i , gam , ak COMPLEX ( KIND = rDef ), INTENT ( INOUT ) :: & S_1 , S_2 , S_3 , S_4 , & S_A11 , & S_A12 , & S_A13 , & S_A14 , & S_A21 , & S_A22 , & S_A23 , & S_A24 , & S_A31 , & S_A32 , & S_A33 , & S_A34 , & S_A41 , & S_A42 , & S_A43 , & S_A44 , & S_B11 , & S_B12 , & S_B13 , & S_B14 , & S_B21 , & S_B22 , & S_B23 , & S_B24 , & S_B31 , & S_B32 , & S_B33 , & S_B34 , & S_B41 , & S_B42 , & S_B43 , & S_B44 ! Local variables COMPLEX ( KIND = rDef ) :: mC , kappaC , rC , r_maxC REAL ( KIND = rDef ) :: one , two , three one = REAL ( 1.0 , KIND = rDef ) two = REAL ( 2.0 , KIND = rDef ) three = REAL ( 3.0 , KIND = rDef ) mC = CMPLX ( m , KIND = rDef ) kappaC = CMPLX ( kappa , KIND = rDef ) rC = CMPLX ( r , KIND = rDef ) r_maxC = CMPLX ( r_max , KIND = rDef ) S_A11 =- i * ( - 1.58113883008419d0 * mC * sqrt ( r * 1 d0 / ( 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) + 1 ) * ( & - 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) ** 2 - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) ** 2 - & 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) ** 2 + 0.00422231256821366d0 )) / r + 1 0.0d0 & / ( 0.1875d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) + 0.1875d0 * tanh ( 0.0037499999999999999d0 * & r - 0.0022500000000000003d0 ) + 0.1875d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) + & 0.999156251898431d0 )) * ( 2.05447160938161d0 * ( r - 0.2d0 ) ** 3 - & 2.46536593125793d0 * ( r - 0.2d0 ) ** 2 + 0.125d0 * tanh ( 1.25d0 * r - & 1.25d0 ) + 0.125d0 * tanh ( 1.25d0 * r - 1.0d0 ) + 0.125d0 * tanh ( 1.25d0 * r & - 0.75d0 ) + 0.125d0 * tanh ( 1.25d0 * r - 0.5d0 ) + 0.125d0 * tanh ( 1.25d0 * & r - 0.25d0 ) + 0.262972366000846d0 ) S_A12 =- 1.58113883008419d0 * two * sqrt ( r * 1 d0 / ( 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) + 1 ) * ( & - 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) ** 2 - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) ** 2 - & 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) ** 2 + 0.00422231256821366d0 )) * ( 0.125d0 * & tanh ( 2 5.0d0 * r - 2 5.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r - 2 0.0d0 ) + & 0.125d0 * tanh ( 2 5.0d0 * r - 1 5.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r - 1 0.0d0 & ) + 0.125d0 * tanh ( 2 5.0d0 * r - 5.0d0 ) + 0.500011349982487d0 ) / r S_A13 = 0 S_A14 = (( 1 1.5295969398069d0 * r - 1 4.0976514193326d0 * ( r - 0.2d0 ) ** 2 - 1.5625d0 * & tanh ( 1 2.5d0 * r - 1 2.5d0 ) ** 2 - 1.5625d0 * tanh ( 1 2.5d0 * r - 1 0.0d0 ) ** 2 & - 1.5625d0 * tanh ( 1 2.5d0 * r - 7.5d0 ) ** 2 - 1.5625d0 * tanh ( 1 2.5d0 * r - & 5.0d0 ) ** 2 - 1.5625d0 * tanh ( 1 2.5d0 * r - 2.5d0 ) ** 2 + & 3.90224080557348d0 ) / ( - 1.60433980646514d0 * r - 4.69921713977753d0 * ( & r - 0.2d0 ) ** 3 + 5.76479846990345d0 * ( r - 0.2d0 ) ** 2 + 0.125d0 * tanh ( & 1 2.5d0 * r - 1 2.5d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r - 1 0.0d0 ) + 0.125d0 * & tanh ( 1 2.5d0 * r - 7.5d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r - 5.0d0 ) + 0.125d0 & * tanh ( 1 2.5d0 * r - 2.5d0 ) + 0.82255260048212d0 ) + ( & 1.58113883008419d0 * sqrt ( r * 1 d0 / ( 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) + 1 ) * ( & - 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) ** 2 - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) ** 2 - & 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) ** 2 + 0.00422231256821366d0 ))) ** two * ( & 1.4d0 - one ) / r ) * ( - 1.60433980646514d0 * r - 4.69921713977753d0 * ( r - & 0.2d0 ) ** 3 + 5.76479846990345d0 * ( r - 0.2d0 ) ** 2 + 0.125d0 * tanh ( & 1 2.5d0 * r - 1 2.5d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r - 1 0.0d0 ) + 0.125d0 * & tanh ( 1 2.5d0 * r - 7.5d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r - 5.0d0 ) + 0.125d0 & * tanh ( 1 2.5d0 * r - 2.5d0 ) + 0.82255260048212d0 ) S_A21 = ( 1.58113883008419d0 * sqrt ( r * 1 d0 / ( 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) + 1 ) * ( & - 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) ** 2 - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) ** 2 - & 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) ** 2 + 0.00422231256821366d0 )) * ( 0.5d0 * r * ( & - 0.00140743752273789d0 * ( 0.0075d0 - 0.0075d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) ** 2 ) * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) - & 0.00140743752273789d0 * ( 0.0075d0 - 0.0075d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) ** 2 ) * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) - & 0.00140743752273789d0 * ( 0.0075d0 - 0.0075d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) ** 2 ) * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 )) * 1 d0 / ( & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) + 1 ) + 0.5d0 * r * ( 0.187658336365052d0 * & tanh ( 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) + 1 ) ** ( & - 2.0d0 ) * ( - 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) ** 2 - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) ** 2 - & 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) ** 2 + 0.00422231256821366d0 ) * ( & 0.000703718761368943d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) ** 2 + 0.000703718761368943d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) ** 2 + & 0.000703718761368943d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) ** 2 - 0.00211115628410683d0 ) + 0.5d0 * 1 d0 & / ( 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) + 1 ) * ( - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) ** 2 - & 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) ** 2 - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) ** 2 + & 0.00422231256821366d0 )) * ( 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) + 1 ) ** 1.0d0 & / ( r * ( - 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) ** 2 - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) ** 2 - & 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) ** 2 + 0.00422231256821366d0 )) + & 1.58113883008419d0 * sqrt ( r * 1 d0 / ( 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) + 1 ) * ( & - 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) ** 2 - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) ** 2 - & 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) ** 2 + 0.00422231256821366d0 )) / r + ( & 1.58113883008419d0 * sqrt ( r * 1 d0 / ( 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) + 1 ) * ( & - 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) ** 2 - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) ** 2 - & 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) ** 2 + 0.00422231256821366d0 ))) ** three * ( & 1.4d0 - one ) / ( r * two )) * ( 2.05447160938161d0 * ( r - 0.2d0 ) ** 3 - & 2.46536593125793d0 * ( r - 0.2d0 ) ** 2 + 0.125d0 * tanh ( 1.25d0 * r - & 1.25d0 ) + 0.125d0 * tanh ( 1.25d0 * r - 1.0d0 ) + 0.125d0 * tanh ( 1.25d0 * r & - 0.75d0 ) + 0.125d0 * tanh ( 1.25d0 * r - 0.5d0 ) + 0.125d0 * tanh ( 1.25d0 * & r - 0.25d0 ) + 0.262972366000846d0 ) S_A22 =- i * ( - 1.58113883008419d0 * mC * sqrt ( r * 1 d0 / ( 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) + 1 ) * ( & - 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) ** 2 - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) ** 2 - & 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) ** 2 + 0.00422231256821366d0 )) / r + 1 0.0d0 & / ( 0.1875d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) + 0.1875d0 * tanh ( 0.0037499999999999999d0 * & r - 0.0022500000000000003d0 ) + 0.1875d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) + & 0.999156251898431d0 )) * ( 0.125d0 * tanh ( 2 5.0d0 * r - 2 5.0d0 ) + 0.125d0 * & tanh ( 2 5.0d0 * r - 2 0.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r - 1 5.0d0 ) + & 0.125d0 * tanh ( 2 5.0d0 * r - 1 0.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r - 5.0d0 ) & + 0.500011349982487d0 ) S_A23 = 0 S_A24 = i * mC * ( - 1.60433980646514d0 * r - 4.69921713977753d0 * ( r - 0.2d0 ) ** 3 + & 5.76479846990345d0 * ( r - 0.2d0 ) ** 2 + 0.125d0 * tanh ( 1 2.5d0 * r - & 1 2.5d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r - 1 0.0d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r & - 7.5d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r - 5.0d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r & - 2.5d0 ) + 0.82255260048212d0 ) / r S_A31 = ( - 0.78125d0 * tanh ( 6 2.5d0 * r - 6 2.5d0 ) ** 2 - 0.78125d0 * tanh ( 6 2.5d0 * r - & 5 0.0d0 ) ** 2 - 0.78125d0 * tanh ( 6 2.5d0 * r - 3 7.5d0 ) ** 2 - 0.78125d0 * & tanh ( 6 2.5d0 * r - 2 5.0d0 ) ** 2 - 0.78125d0 * tanh ( 6 2.5d0 * r - 1 2.5d0 ) ** 2 & + 3.90625d0 + ( 1.58113883008419d0 * sqrt ( r * 1 d0 / ( 0.187658336365052d0 & * tanh ( 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) + 1 ) * ( & - 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) ** 2 - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) ** 2 - & 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) ** 2 + 0.00422231256821366d0 ))) ** two * ( & 1.4d0 - one ) * ( 0.0125d0 * tanh ( 6 2.5d0 * r - 6 2.5d0 ) + 0.0125d0 * tanh ( & 6 2.5d0 * r - 5 0.0d0 ) + 0.0125d0 * tanh ( 6 2.5d0 * r - 3 7.5d0 ) + 0.0125d0 * & tanh ( 6 2.5d0 * r - 2 5.0d0 ) + 0.0125d0 * tanh ( 6 2.5d0 * r - 1 2.5d0 ) + & 0.0500000000003472d0 ) / ( r * two )) * ( 2.05447160938161d0 * ( r - 0.2d0 ) ** 3 & - 2.46536593125793d0 * ( r - 0.2d0 ) ** 2 + 0.125d0 * tanh ( 1.25d0 * r - & 1.25d0 ) + 0.125d0 * tanh ( 1.25d0 * r - 1.0d0 ) + 0.125d0 * tanh ( 1.25d0 * r & - 0.75d0 ) + 0.125d0 * tanh ( 1.25d0 * r - 0.5d0 ) + 0.125d0 * tanh ( 1.25d0 * & r - 0.25d0 ) + 0.262972366000846d0 ) S_A32 = 0 S_A33 =- i * ( - 1.58113883008419d0 * mC * sqrt ( r * 1 d0 / ( 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) + 1 ) * ( & - 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) ** 2 - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) ** 2 - & 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) ** 2 + 0.00422231256821366d0 )) / r + 1 0.0d0 & / ( 0.1875d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) + 0.1875d0 * tanh ( 0.0037499999999999999d0 * & r - 0.0022500000000000003d0 ) + 0.1875d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) + & 0.999156251898431d0 )) * ( 0.125d0 * tanh ( 2 5.0d0 * r - 2 5.0d0 ) + 0.125d0 * & tanh ( 2 5.0d0 * r - 2 0.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r - 1 5.0d0 ) + & 0.125d0 * tanh ( 2 5.0d0 * r - 1 0.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r - 5.0d0 ) & + 0.500011349982487d0 ) S_A34 = 0 S_A41 = ( one / r + ( - 4.93073186251587d0 * r + 6.16341482814484d0 * ( r - 0.2d0 ) ** 2 - & 0.15625d0 * tanh ( 1.25d0 * r - 1.25d0 ) ** 2 - 0.15625d0 * tanh ( 1.25d0 * r - & 1.0d0 ) ** 2 - 0.15625d0 * tanh ( 1.25d0 * r - 0.75d0 ) ** 2 - 0.15625d0 * tanh & ( 1.25d0 * r - 0.5d0 ) ** 2 - 0.15625d0 * tanh ( 1.25d0 * r - 0.25d0 ) ** 2 + & 1.76739637250317d0 ) / ( 2.05447160938161d0 * ( r - 0.2d0 ) ** 3 - & 2.46536593125793d0 * ( r - 0.2d0 ) ** 2 + 0.125d0 * tanh ( 1.25d0 * r - & 1.25d0 ) + 0.125d0 * tanh ( 1.25d0 * r - 1.0d0 ) + 0.125d0 * tanh ( 1.25d0 * r & - 0.75d0 ) + 0.125d0 * tanh ( 1.25d0 * r - 0.5d0 ) + 0.125d0 * tanh ( 1.25d0 * & r - 0.25d0 ) + 0.262972366000846d0 ) + ( 1.58113883008419d0 * sqrt ( r * & 1 d0 / ( 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) + 1 ) * ( - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) ** 2 - & 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) ** 2 - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) ** 2 + & 0.00422231256821366d0 ))) ** two * ( one + 1.4d0 ) / ( r * two )) * ( & 2.05447160938161d0 * ( r - 0.2d0 ) ** 3 - 2.46536593125793d0 * ( r - 0.2d0 & ) ** 2 + 0.125d0 * tanh ( 1.25d0 * r - 1.25d0 ) + 0.125d0 * tanh ( 1.25d0 * r - & 1.0d0 ) + 0.125d0 * tanh ( 1.25d0 * r - 0.75d0 ) + 0.125d0 * tanh ( 1.25d0 * r & - 0.5d0 ) + 0.125d0 * tanh ( 1.25d0 * r - 0.25d0 ) + 0.262972366000846d0 ) S_A42 = i * mC * ( 0.125d0 * tanh ( 2 5.0d0 * r - 2 5.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r - 2 0.0d0 ) + & 0.125d0 * tanh ( 2 5.0d0 * r - 1 5.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r - 1 0.0d0 & ) + 0.125d0 * tanh ( 2 5.0d0 * r - 5.0d0 ) + 0.500011349982487d0 ) / r S_A43 = 0 S_A44 =- i * ( - 1.58113883008419d0 * mC * sqrt ( r * 1 d0 / ( 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0037499999999999999d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0022500000000000003d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) + 1 ) * ( & - 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) ** 2 - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r - 0.0022500000000000003d0 ) ** 2 - & 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r - & 0.00075000000000000002d0 ) ** 2 + 0.00422231256821366d0 )) / r + 1 0.0d0 & / ( 0.1875d0 * tanh ( 0.0037499999999999999d0 * r - & 0.0037499999999999999d0 ) + 0.1875d0 * tanh ( 0.0037499999999999999d0 * & r - 0.0022500000000000003d0 ) + 0.1875d0 * tanh ( & 0.0037499999999999999d0 * r - 0.00075000000000000002d0 ) + & 0.999156251898431d0 )) * ( - 1.60433980646514d0 * r - 4.69921713977753d0 & * ( r - 0.2d0 ) ** 3 + 5.76479846990345d0 * ( r - 0.2d0 ) ** 2 + 0.125d0 * & tanh ( 1 2.5d0 * r - 1 2.5d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r - 1 0.0d0 ) + & 0.125d0 * tanh ( 1 2.5d0 * r - 7.5d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r - 5.0d0 ) + & 0.125d0 * tanh ( 1 2.5d0 * r - 2.5d0 ) + 0.82255260048212d0 ) S_B11 =- 1 0.0d0 * i * ( 0.0125d0 * tanh ( 6 2.5d0 * r - 6 2.5d0 ) + 0.0125d0 * tanh ( 6 2.5d0 * r - & 5 0.0d0 ) + 0.0125d0 * tanh ( 6 2.5d0 * r - 3 7.5d0 ) + 0.0125d0 * tanh ( 6 2.5d0 & * r - 2 5.0d0 ) + 0.0125d0 * tanh ( 6 2.5d0 * r - 1 2.5d0 ) + & 0.0500000000003472d0 ) * ( 2.05447160938161d0 * ( r - 0.2d0 ) ** 3 - & 2.46536593125793d0 * ( r - 0.2d0 ) ** 2 + 0.125d0 * tanh ( 1.25d0 * r - & 1.25d0 ) + 0.125d0 * tanh ( 1.25d0 * r - 1.0d0 ) + 0.125d0 * tanh ( 1.25d0 * r & - 0.75d0 ) + 0.125d0 * tanh ( 1.25d0 * r - 0.5d0 ) + 0.125d0 * tanh ( 1.25d0 * & r - 0.25d0 ) + 0.262972366000846d0 ) S_B12 = 0 S_B13 = 0 S_B14 = 0 S_B21 = 0 S_B22 =- 1 0.0d0 * i * ( 0.125d0 * tanh ( 2 5.0d0 * r - 2 5.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r - & 2 0.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r - 1 5.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r & - 1 0.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r - 5.0d0 ) + 0.500011349982487d0 ) & * ( 0.0125d0 * tanh ( 6 2.5d0 * r - 6 2.5d0 ) + 0.0125d0 * tanh ( 6 2.5d0 * r - & 5 0.0d0 ) + 0.0125d0 * tanh ( 6 2.5d0 * r - 3 7.5d0 ) + 0.0125d0 * tanh ( 6 2.5d0 & * r - 2 5.0d0 ) + 0.0125d0 * tanh ( 6 2.5d0 * r - 1 2.5d0 ) + & 0.0500000000003472d0 ) S_B23 = 0 S_B24 = 0 S_B31 = 0 S_B32 = 0 S_B33 =- 1 0.0d0 * i * ( 0.125d0 * tanh ( 2 5.0d0 * r - 2 5.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r - & 2 0.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r - 1 5.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r & - 1 0.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r - 5.0d0 ) + 0.500011349982487d0 ) & * ( 0.0125d0 * tanh ( 6 2.5d0 * r - 6 2.5d0 ) + 0.0125d0 * tanh ( 6 2.5d0 * r - & 5 0.0d0 ) + 0.0125d0 * tanh ( 6 2.5d0 * r - 3 7.5d0 ) + 0.0125d0 * tanh ( 6 2.5d0 & * r - 2 5.0d0 ) + 0.0125d0 * tanh ( 6 2.5d0 * r - 1 2.5d0 ) + & 0.0500000000003472d0 ) S_B34 =- 1 0.0d0 * i * one * ( - 1.60433980646514d0 * r - 4.69921713977753d0 * ( r - 0.2d0 ) ** 3 & + 5.76479846990345d0 * ( r - 0.2d0 ) ** 2 + 0.125d0 * tanh ( 1 2.5d0 * r - & 1 2.5d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r - 1 0.0d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r & - 7.5d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r - 5.0d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r & - 2.5d0 ) + 0.82255260048212d0 ) S_B41 = 0 S_B42 = 0 S_B43 =- 1 0.0d0 * i * one * ( 0.125d0 * tanh ( 2 5.0d0 * r - 2 5.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r - & 2 0.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r - 1 5.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r & - 1 0.0d0 ) + 0.125d0 * tanh ( 2 5.0d0 * r - 5.0d0 ) + 0.500011349982487d0 ) S_B44 =- 1 0.0d0 * i * ( 0.0125d0 * tanh ( 6 2.5d0 * r - 6 2.5d0 ) + 0.0125d0 * tanh ( 6 2.5d0 * r - & 5 0.0d0 ) + 0.0125d0 * tanh ( 6 2.5d0 * r - 3 7.5d0 ) + 0.0125d0 * tanh ( 6 2.5d0 & * r - 2 5.0d0 ) + 0.0125d0 * tanh ( 6 2.5d0 * r - 1 2.5d0 ) + & 0.0500000000003472d0 ) * ( - 1.60433980646514d0 * r - 4.69921713977753d0 & * ( r - 0.2d0 ) ** 3 + 5.76479846990345d0 * ( r - 0.2d0 ) ** 2 + 0.125d0 * & tanh ( 1 2.5d0 * r - 1 2.5d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r - 1 0.0d0 ) + & 0.125d0 * tanh ( 1 2.5d0 * r - 7.5d0 ) + 0.125d0 * tanh ( 1 2.5d0 * r - 5.0d0 ) + & 0.125d0 * tanh ( 1 2.5d0 * r - 2.5d0 ) + 0.82255260048212d0 ) S_1 = & S_A11 + & S_A12 + & S_A13 + & S_A14 - (& S_B11 + & S_B12 + & S_B13 + & S_B14 ) S_2 = & S_A21 + & S_A22 + & S_A23 + & S_A24 - (& S_B21 + & S_B22 + & S_B23 + & S_B24 ) S_3 = & S_A31 + & S_A32 + & S_A33 + & S_A34 - (& S_B31 + & S_B32 + & S_B33 + & S_B34 ) S_4 = & S_A41 + & S_A42 + & S_A43 + & S_A44 - (& S_B41 + & S_B42 + & S_B43 + & S_B44 ) END SUBROUTINE SourceCalcComponents","tags":"","loc":"sourcefile/sourcetermcomponentsmms-checkpoint.f90.html"},{"title":"SoundSpeedMMS-checkpoint.f90 – Fortran Program","text":"Contents Subroutines CalcSoundSpeed Source Code SoundSpeedMMS-checkpoint.f90 Source Code ! Returns M_theta and the corresponding sound speed as defined in ! SourceTermSymbolicSolver.ipynb SUBROUTINE CalcSoundSpeed (& r , & kappa , & SoundSpeedExpected , & thetaMachData , & axialMachData ) REAL ( KIND = rDef ) , INTENT ( IN ) :: & kappa REAL ( KIND = rDef ) , DIMENSION (:), INTENT ( INOUT ) :: & SoundSpeedExpected , thetaMachData , axialMachData REAL ( KIND = rDef ) , DIMENSION (:), INTENT ( IN ) :: & r ! Local variables INTEGER :: & numberOfGridPoints , i !, j REAL ( KIND = rDef ) :: one , two , three one = ( 1.0_rDef ) two = ( 2.0_rDef ) three = ( 3.0_rDef ) numberOfGridPoints = SIZE ( SoundSpeedExpected ) DO i = 1 , numberOfGridPoints SoundSpeedExpected ( i ) = 0.1875d0 * tanh ( 0.0037499999999999999d0 * r ( i ) - 0.0037499999999999999d0 ) + & 0.1875d0 * tanh ( 0.0037499999999999999d0 * r ( i ) - 0.0022500000000000003d0 & ) + 0.1875d0 * tanh ( 0.0037499999999999999d0 * r ( i ) - & 0.00075000000000000002d0 ) + 0.999156251898431d0 thetaMachData ( i ) = 1.58113883008419d0 * sqrt ( r ( i ) * ( - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r ( i ) - 0.0037499999999999999d0 ) ** 2 - & 0.00140743752273789d0 * tanh ( 0.0037499999999999999d0 * r ( i ) - & 0.0022500000000000003d0 ) ** 2 - 0.00140743752273789d0 * tanh ( & 0.0037499999999999999d0 * r ( i ) - 0.00075000000000000002d0 ) ** 2 + & 0.00422231256821366d0 ) / ( 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r ( i ) - 0.0037499999999999999d0 ) + & 0.187658336365052d0 * tanh ( 0.0037499999999999999d0 * r ( i ) - & 0.0022500000000000003d0 ) + 0.187658336365052d0 * tanh ( & 0.0037499999999999999d0 * r ( i ) - 0.00075000000000000002d0 ) + 1 )) axialMachData ( i ) = 0.0125d0 * tanh ( 6 2.5d0 * r ( i ) - 6 2.5d0 ) + 0.0125d0 * tanh ( 6 2.5d0 * r ( i ) - 5 0.0d0 ) + & 0.0125d0 * tanh ( 6 2.5d0 * r ( i ) - 3 7.5d0 ) + 0.0125d0 * tanh ( 6 2.5d0 * r ( i ) - & 2 5.0d0 ) + 0.0125d0 * tanh ( 6 2.5d0 * r ( i ) - 1 2.5d0 ) + 0.0500000000003472d0 END DO END SUBROUTINE CalcSoundSpeed","tags":"","loc":"sourcefile/soundspeedmms-checkpoint.f90.html"},{"title":"main.f90 – Fortran Program","text":"Contents Programs MAIN Source Code main.f90 Source Code PROGRAM MAIN USE , INTRINSIC :: ISO_FORTRAN_ENV IMPLICIT NONE INTEGER , PARAMETER :: & rDef = REAL64 INTEGER :: & UNIT ,& i , & j , & numberOfXlocations , & numberOfPoints REAL ( KIND = rDef ) :: x_max , x_min , delta_x , & C , S_horiz , S_vert REAL ( KIND = rDef ) , DIMENSION (:), ALLOCATABLE :: & A , & B REAL ( KIND = rDef ), DIMENSION (:), ALLOCATABLE :: & x , y , R , L , x_loc , y_loc !, A, B ! REAL(KIND=rDef), DIMENSION(:,:), ALLOCATABLE :: & !     R_array LOGICAL :: & ! debug = .FALSE. debug = . TRUE . CONTINUE numberOfPoints = 250 numberOfXlocations = 3 x_max = 0.70_rDef x_min = 0.20_rDef ! Equal Width between points requires grid spacing delta_x = ( x_max - x_min ) / REAL ( numberOfPoints , KIND = rDef ) ! delta_tanh = 0.50_rDef C = 1.0_rDef S_vert = C S_horiz = 1.0_rDef ALLOCATE ( & x ( numberOfPoints ) ,& y ( numberOfPoints ) ,& R ( numberOfPoints ) ,& L ( numberOfPoints )) !,& ALLOCATE ( & x_loc ( numberOfXlocations ) , & y_loc ( numberOfXlocations ) , & A ( numberOfXlocations ) , & B ( numberOfXlocations ) ) DO i = 1 , numberOfXlocations A ( i ) = 0.01_rDef ! Amplitude B ( i ) = 1 0.0_rdef ! Concavity ENDDO x_loc ( 1 ) = x_max x_loc ( 2 ) = 0.50_rDef x_loc ( 3 ) = 0.20_rDef y_loc ( 1 ) = 0.0_rDef y_loc ( 2 ) = 0.0_rDef y_loc ( 3 ) = 0.0_rDef DO i = 1 , numberOfPoints x ( i ) = x_min + delta_x * REAL ( i , KIND = rDef ) ENDDO DO i = 1 , numberOfPoints R ( i ) = 0.0_rDef L ( i ) = 0.0_rDef y ( i ) = 0.0_rDef ENDDO DO i = 1 , numberOfPoints DO j = 1 , SIZE ( x_loc ) R ( i ) = R ( i ) + y_loc ( j ) + A ( j ) * tanh ( B ( j ) * ( x ( i ) - x_loc ( j ))) L ( i ) = L ( i ) + y_loc ( j ) + A ( j ) * tanh ( B ( j ) * ( x_loc ( j ) - x_max )) y ( i ) = S_vert + ( L ( i ) + R ( i )) ENDDO ENDDO ! Writing data to file OPEN ( NEWUNIT = UNIT , FILE = '../ExecutableFiles/data.dat' ) DO i = 1 , numberOfPoints WRITE ( UNIT , * ) x ( i ), y ( i ) IF ( debug ) THEN WRITE ( 0 , * ) x ( i ), y ( i ) ENDIF ENDDO CLOSE ( UNIT ) DEALLOCATE ( & x ,& y ,& R ,& L ,& A ,& B ,& x_loc ) END PROGRAM MAIN","tags":"","loc":"sourcefile/main.f90~2.html"},{"title":"main-local-variables.f90 – Fortran Program","text":"Contents Source Code main-local-variables.f90 Source Code ! inputs needed for SwirlClassType azimuthalModeNumber = 1 hubToTipRatio = r_min / r_max numericalIntegrationFlag = 1 finiteDiffFlag = 1 secondOrderSmoother = 0.0_rDef fourthOrderSmoother = 0.0_rDef IF ( numericalIntegrationFlag . eq . 1 ) THEN ExpectedRateOfConvergenceSoundSpeed = 2.0_rDef ELSEIF ( numericalIntegrationFlag . eq . 2 ) THEN ExpectedRateOfConvergenceSoundSpeed = 4.0_rDef ENDIF IF ( finiteDiffFlag . eq . 1 ) THEN ExpectedRateOfConvergenceSourceTerm = 2.0_rDef ELSEIF ( finiteDiffFlag . eq . 2 ) THEN ExpectedRateOfConvergenceSourceTerm = 4.0_rDef ENDIF ! constants needed for calculations ! gam = 1.4_rDef               ! ratio of specific heats gm1 = gam - 1.0_rDef ci = CMPLX ( 0.0 , 1.0 , rDef ) !imaginary number ! constants for MMS module boundingConstant = 1.00_rDef eigenIndex = 1 facCount = 0 ! initializer for fac count","tags":"","loc":"sourcefile/main-local-variables.f90.html"},{"title":"swirl-data-export-MMS.f90 – Fortran Program","text":"Contents Source Code swirl-data-export-MMS.f90 Source Code ! Exporting the results from the Method of Manufactured Solutions dir_name = '02-method-of-manufactured-solutions/' OPEN (& NEWUNIT = UNIT ,& FILE = & TRIM ( ADJUSTL ( dir_name )) // & 'L2-sound_speed-' // & '.dat' ) WRITE ( UNIT , FORMAT_L2_HEADER ) 'GridPoints ' , 'L2' DO i = 1 , numberOfIterations WRITE ( UNIT , FORMAT_L2 ) numberOfGridPointsArray ( i ) , SoundSpeedL2Array ( i ) END DO CLOSE ( UNIT ); OPEN (& NEWUNIT = UNIT ,& FILE = & TRIM ( ADJUSTL ( dir_name )) // & 'ROC-sound_speed' // & '.dat' ) WRITE ( UNIT , FORMAT_ROC_HEADER ) 'Delta_r' , 'ROC' DO i = 1 , numberOfIterations - 1 WRITE ( UNIT , FORMAT_ROC ) & numberOfGridPointsArray ( i ), & RateOfConvergence1 ( i ) ENDDO CLOSE ( UNIT ); ! Linearized Perturbation Equations OPEN (& NEWUNIT = UNIT ,& FILE = & TRIM ( ADJUSTL ( dir_name )) // & 'L2-LEE' // & '.dat' ) WRITE ( UNIT , FORMAT_L2_HEADER ) 'GridPoints' , 'L2' DO i = 1 , numberOfIterations WRITE ( UNIT , FORMAT_L2 ) & numberOfGridPointsArray ( i ) , & REAL ( S_L2Array ( i ), KIND = rDef ) END DO CLOSE ( UNIT ); OPEN (& NEWUNIT = UNIT ,& FILE = & TRIM ( ADJUSTL ( dir_name )) // & 'ROC-LEE' // & '.dat' ) WRITE ( UNIT , FORMAT_ROC_HEADER ) 'Delta_r ' , 'ROC' DO i = 1 , numberOfIterations - 1 WRITE ( UNIT , FORMAT_ROC ) & numberOfGridPointsArray ( i ), & ABS ( REAL ( RateOfConvergence2 ( i ), KIND = rDef )) ENDDO CLOSE ( UNIT ) IF ( debug ) THEN WRITE ( 0 , FORMAT_L2_HEADER ) 'Gridpoints' , 'L2-SoundSpeed' DO i = 1 , numberOfIterations WRITE ( 0 , FORMAT_L2 ) 5 + 2 ** i , SoundSpeedL2Array ( i ) END DO WRITE ( 0 , FORMAT_L2_HEADER ) 'Gridpoints' , 'L2-Source' DO i = 1 , numberOfIterations WRITE ( 0 , FORMAT_L2 ) 5 + 2 ** i , REAL ( S_L2Array ( i ), KIND = rDef ) END DO WRITE ( 0 , FORMAT_ROC_HEADER ) 'Delta_r' , 'ROC' DO i = 1 , numberOfIterations - 1 WRITE ( 0 , FORMAT_ROC ) & numberOfGridPointsArray ( i ), & RateOfConvergence1 ( i ) ENDDO WRITE ( 0 , FORMAT_ROC_HEADER ) 'Delta_r' , 'ROC' DO i = 1 , numberOfIterations - 1 WRITE ( 0 , FORMAT_ROC ) & numberOfGridPointsArray ( i ), & RateOfConvergence2 ( i ) ENDDO ELSE END IF","tags":"","loc":"sourcefile/swirl-data-export-mms.f90.html"},{"title":"main-variables.f90 – Fortran Program","text":"Contents Source Code main-variables.f90 Source Code INTEGER , PARAMETER :: & rDef = REAL64 INTEGER :: & !UNIT                ,& ! for NEWUNIT finiteDiffFlag ,& ! finite difference flag numericalIntegrationFlag ,& !  numerical integration flag numberOfGridPoints ,& ! number of points azimuthalModeNumber , & i ,& !j               ,& ! indexer for do loops fac ,& ! variable used for doubling grid points eigenIndex ,& facCount ! counts the outermost do loop LOGICAL :: & debug = . TRUE . , & MMSflag = . TRUE . COMPLEX ( KIND = rDef ), DIMENSION (:), ALLOCATABLE :: & S_eig , & !S_actual                                     , & S_1 , & S_2 , & S_3 , & S_4 , & S_A11 , & S_A12 , & S_A13 , & S_A14 , & S_A21 , & S_A22 , & S_A23 , & S_A24 , & S_A31 , & S_A32 , & S_A33 , & S_A34 , & S_A41 , & S_A42 , & S_A43 , & S_A44 , & S_B11 , & S_B12 , & S_B13 , & S_B14 , & S_B21 , & S_B22 , & S_B23 , & S_B24 , & S_B31 , & S_B32 , & S_B33 , & S_B34 , & S_B41 , & S_B42 , & S_B43 , & S_B44 , & S_Expected , & S_error , & !S_L2Array                                    , & eigenVector , & eigenVectorMMS COMPLEX ( KIND = rDef ) :: & ci !                 ,& S_L2 COMPLEX ( KIND = rDef ), DIMENSION (:), ALLOCATABLE :: & S_A_actual , & S_B_actual REAL ( KIND = rDef ), DIMENSION (:), ALLOCATABLE :: & r ,& !radial grid locations axialMachData ,& !M_x thetaMachData ,& !M_th totalMachData ,& !M_total = sqrt(M_x&#94;2+M_th&#94;2) !SoundSpeedExpected  ,& !Based on Eqn 2.6 in Kousen's paper rOut ,& !radial grid after it leaves swirlClassObj axialMachDataOut ,& !M_x         after it leaves swirlClassObj thetaMachDataOut ,& !M_th        after it leaves swirlClassObj SoundSpeedOut ,& !Sound Speed after it leaves swirlClassObj axialMachData_dr_Out ,& !dM_x/dr thetaMachData_dr_Out ,& !dM_th/dr SoundSpeed_dr_Out ,& !dA/dr !SoundSpeedError     ,& !eps_A !SoundSpeedL2Array   ,& !array of L2norm (eps_A) ! Perturbation variables vR ,& !radial     velocity vT ,& !tangential velocity vX ,& !axial velocity Pr !,& !pressure REAL ( KIND = REAL64 ) :: & ExpectedRateOfConvergenceSoundSpeed ,& ExpectedRateOfConvergenceSourceTerm ,& gm1 ,& secondOrderSmoother ,& !2nd order smoothing coefficient fourthOrderSmoother ,& !4th order smoothing coefficient boundingConstant ,& dr ,& hubToTipRatio ! ,& SoundSpeedErrorL2 ! input variables: REAL ( KIND = rDef ), PARAMETER :: & gam = 1.40_rDef ,& r_min = 0.10_rDef ,& r_max = 1.000_rDef INTEGER , PARAMETER :: & numberOfIterations = 4 !, & azimuthalModeNumber = 0 ! mode order COMPLEX ( KIND = rDef ), PARAMETER :: & hubAdmittance = CMPLX ( 0.0 , 0 , rDef ) , & ductAdmittance = CMPLX ( 0.0 , 0.0 , rDef ) , & frequency = CMPLX ( 1 , 0 , rDef ) TYPE ( SwirlClassType ) , DIMENSION ( numberOfIterations ) :: & swirlClassObj","tags":"","loc":"sourcefile/main-variables.f90.html"},{"title":"inputs.f90 – Fortran Program","text":"Contents Source Code inputs.f90 Source Code","tags":"","loc":"sourcefile/inputs.f90.html"},{"title":"debug-script.f90 – Fortran Program","text":"Contents Source Code debug-script.f90 Source Code","tags":"","loc":"sourcefile/debug-script.f90.html"},{"title":"swirl-data-export-per-grid.f90 – Fortran Program","text":"Contents Source Code swirl-data-export-per-grid.f90 Source Code ! used to export data for swirl ! 01-mean-flow-data WRITE ( file_id , '(i0.4)' ) numberOfGridPoints dir_name = '01-mean-flow/' OPEN (& NEWUNIT = UNIT ,& FILE = & TRIM ( ADJUSTL ( dir_name )) // & 'mean-flow' // & TRIM ( ADJUSTL ( file_id )) // & '.dat' ) ! Write the resulting mean flow WRITE ( UNIT , * ) & 'radius ' , & 'M_x ' , & 'M_theta ' , & 'A_actual ' DO i = 1 , numberOfGridPoints WRITE ( UNIT , * ) & r ( i ) , & axialMachDataMMSOut ( i ) , & thetaMachDataMMSOut ( i ) ENDDO CLOSE ( UNIT );","tags":"","loc":"sourcefile/swirl-data-export-per-grid.f90.html"},{"title":"swirl-data-export-per-grid-MMS.f90 – Fortran Program","text":"Contents Source Code swirl-data-export-per-grid-MMS.f90 Source Code ! used to export data for swirl ! 01-mean-flow-data WRITE ( file_id , '(i0.4)' ) numberOfGridPoints !WRITE(FDfac_id, '(i0)') FDfac dir_name = '01-mean-flow/' OPEN (& NEWUNIT = UNIT ,& FILE = & TRIM ( ADJUSTL ( dir_name )) // & 'mean-flow' // & TRIM ( ADJUSTL ( file_id )) // & '.dat' ) !OPEN(& !    NEWUNIT=UNIT,& !    FILE   =& !    TRIM(ADJUSTL(dir_name))  // & !    'mean-flow-MMS' // & !    TRIM(ADJUSTL(file_id))   // & !    'finite-diff-method' // & !    TRIM(ADJUSTL(FDfac_id)) // & !    '.dat') ! ! Write the resulting mean flow WRITE ( UNIT , * ) & 'radius ' , & 'M_x ' , & 'M_theta ' , & 'A_expected ' , & 'A_actual ' , & 'vR ' , & 'vTh ' , & 'vX ' , & 'Pr ' , & 'S_1_e ' , & 'S_2_e ' , & 'S_3_e ' , & 'S_4_e ' , & 'S_1_a ' , & 'S_2_a ' , & 'S_3_a ' , & 'S_4_a ' DO i = 1 , numberOfGridPoints WRITE ( UNIT , * ) & rOut ( i ) , & axialMachDataMMS ( i ) , & thetaMachDataMMSOut ( i ) , & speedOfSoundMMS ( i ) , & SoundSpeedOut ( i ) , & vR ( i ) , & vTh ( i ) , & vX ( i ) , & Pr ( i ) , & REAL ( S_MMS ( i ), KIND = rDef ) , & REAL ( S_MMS ( i + 1 * numberOfGridPoints ), KIND = rDef ) , & REAL ( S_MMS ( i + 2 * numberOfGridPoints ), KIND = rDef ) , & REAL ( S_MMS ( i + 3 * numberOfGridPoints ), KIND = rDef ) , & REAL ( S_actual ( i ), KIND = rDef ) , & REAL ( S_actual ( i + 1 * numberOfGridPoints ), KIND = rDef ) , & REAL ( S_actual ( i + 2 * numberOfGridPoints ) , KIND = rDef ) , & REAL ( S_actual ( i + 3 * numberOfGridPoints ) , KIND = rDef ) IF ( debug ) THEN ! WRITE(0,FORMAT_MEAN_FLOW) & !     rOut(i)                 , & !     axialMachDataMMSOut(i)     , & !     thetaMachDataMMSOut(i)     , & !     speedOfSoundMMS(i)   , & !     SoundSpeedOut(i) ELSE ENDIF ENDDO CLOSE ( UNIT ); ! LEE dir_name = '02-method-of-manufactured-solutions/' OPEN (& NEWUNIT = UNIT ,& FILE = & TRIM ( ADJUSTL ( dir_name )) // & 'perturbation-variables' // & TRIM ( ADJUSTL ( file_id )) // & '.dat' ) WRITE ( UNIT , FORMAT_PERTURB_HEADER ) & 'radius ' , 'vR ' , 'vTh ' , 'vX ' , 'Pr ' DO i = 1 , numberOfGridPoints WRITE ( UNIT , FORMAT_PERTURB_VARS ) r ( i ) , vR ( i ) , vTh ( i ) , vX ( i ), Pr ( i ) END DO CLOSE ( UNIT ); ! MMS OPEN (& NEWUNIT = UNIT ,& FILE = & TRIM ( ADJUSTL ( dir_name )) // & 'sound-speed-error' // & TRIM ( ADJUSTL ( file_id )) // & '.dat' ) WRITE ( UNIT , FORMAT_ERROR_HEADER ) 'radius ' , 'SpeedofSoundError ' , 'Expected ' , 'Actual ' DO i = 1 , numberOfGridPoints WRITE ( UNIT , FORMAT_ERROR ) r ( i ) , SoundSpeedError ( i ), speedOfSoundMMS ( i ), SoundSpeedOut ( i ) END DO CLOSE ( UNIT ); OPEN (& NEWUNIT = UNIT ,& FILE = & TRIM ( ADJUSTL ( dir_name )) // & 'SourceTermData1_' // & TRIM ( ADJUSTL ( file_id )) // & '.dat' ) WRITE ( UNIT , FORMAT_SOURCE_TERMS_HEADER ) & 'radius ' , 'S_expected ' , 'S_actual ' , 'Error ' DO i = 1 , numberOfGridPoints WRITE ( UNIT , FORMAT_SOURCE_TERMS ) & rOut ( i ), & REAL ( S_MMS ( i ), KIND = rDef ), & REAL ( S_actual ( i ), KIND = rDef ) , & REAL ( S_error ( i ), KIND = rDef ) END DO CLOSE ( UNIT ); OPEN (& NEWUNIT = UNIT ,& FILE = & TRIM ( ADJUSTL ( dir_name )) // & 'SourceTermData2_' // & TRIM ( ADJUSTL ( file_id )) // & '.dat' ) WRITE ( UNIT , FORMAT_SOURCE_TERMS_HEADER ) 'radius ' , 'S_expected ' , 'S_actual ' , 'Error ' DO i = 1 , numberOfGridPoints WRITE ( UNIT , FORMAT_SOURCE_TERMS ) & rOut ( i ) , & REAL ( S_MMS ( i + numberOfGridPoints ), KIND = rDef ), & REAL ( S_actual ( i + numberOfGridPoints ), KIND = rDef ) , & REAL ( S_error ( i + numberOfGridPoints ), KIND = rDef ) END DO CLOSE ( UNIT ); OPEN (& NEWUNIT = UNIT ,& FILE = & TRIM ( ADJUSTL ( dir_name )) // & 'SourceTermData3_' // & TRIM ( ADJUSTL ( file_id )) // & '.dat' ) WRITE ( UNIT , FORMAT_SOURCE_TERMS_HEADER ) 'radius ' , 'S_expected ' , 'S_actual ' , 'Error ' DO i = 1 , numberOfGridPoints WRITE ( UNIT , FORMAT_SOURCE_TERMS ) & rOut ( i ), & REAL ( S_MMS ( i + numberOfGridPoints * 2 ), KIND = rDef ), & REAL ( S_actual ( i + numberOfGridPoints * 2 ), KIND = rDef ) , & REAL ( S_error ( i + numberOfGridPoints * 2 ), KIND = rDef ) END DO CLOSE ( UNIT ); OPEN (& NEWUNIT = UNIT ,& FILE = & TRIM ( ADJUSTL ( dir_name )) // & 'SourceTermData4_' // & TRIM ( ADJUSTL ( file_id )) // & '.dat' ) WRITE ( UNIT , FORMAT_SOURCE_TERMS_HEADER ) 'radius ' , 'S_expected ' , 'S_actual ' , 'Error ' DO i = 1 , numberOfGridPoints WRITE ( UNIT , FORMAT_SOURCE_TERMS ) & rOut ( i ), & REAL ( S_MMS ( i + numberOfGridPoints * 3 ), KIND = rDef ), & REAL ( S_actual ( i + numberOfGridPoints * 3 ), KIND = rDef ) , & REAL ( S_error ( i + numberOfGridPoints * 3 ), KIND = rDef ) END DO CLOSE ( UNIT );","tags":"","loc":"sourcefile/swirl-data-export-per-grid-mms.f90.html"},{"title":"input-variables.f90 – Fortran Program","text":"Contents Source Code input-variables.f90 Source Code","tags":"","loc":"sourcefile/input-variables.f90.html"},{"title":"calculating-rate-of-convergence.f90 – Fortran Program","text":"Contents Source Code calculating-rate-of-convergence.f90 Source Code CALL getRateOfConvergence (& object = SoundSpeedMMS_ClassObj , & ExpectedRateOfConvergence = ExpectedRateOfConvergenceSoundSpeed , & RateOfConvergence = RateOfConvergence1 , & L2Array = SoundSpeedL2Array ) CALL getRateOfConvergence (& object = SourceTermMMS_ClassObj , & RateOfConvergence = RateOfConvergence2 , & L2Array = S_L2Array ) !     IF (debug) !     WRITE(0,*) RateOfConvergence1(1) !     ENDIF","tags":"","loc":"sourcefile/calculating-rate-of-convergence.f90.html"},{"title":"main-variables-checkpoint.f90 – Fortran Program","text":"Contents Source Code main-variables-checkpoint.f90 Source Code ! Character Variables CHARACTER ( 50 ) :: & dir_name CHARACTER ( 50 ) :: & FORMAT_MEAN_FLOW , & FORMAT_PERTURB_VARS , & FORMAT_PERTURB_HEADER , & FORMAT_MEAN_FLOW_HEADER , & FORMAT_SOURCE_TERMS , & FORMAT_SOURCE_TERMS_HEADER , & FORMAT_L2 , & FORMAT_L2_HEADER , & FORMAT_ERROR , & FORMAT_ERROR_HEADER , & FORMAT_ROC , & FORMAT_ROC_HEADER CHARACTER ( 10 ) :: file_id ! INTEGER Variables INTEGER , PARAMETER :: & rDef = REAL64 , & numberOfIterations = 9 INTEGER :: & UNIT ,& ! for NEWUNIT finiteDiffFlag ,& ! finite difference flag azimuthalModeNumber ,& ! mode order numberOfGridPoints ,& ! number of points i ,& !j               ,& ! indexer for do loops i1 ,& !j1            ,& ! indexer for do loops i2 ,& !j2            ,& ! indexer for do loops i3 ,& !j3            ,& ! indexer for do loops fac ,& ! variable used for doubling grid points eigenIndex ,& facCount ! counts the outermost do loop INTEGER , DIMENSION (:), ALLOCATABLE :: & numberOfGridPointsArray TYPE ( SwirlClassType ) , DIMENSION ( numberOfIterations ) :: & swirlClassObj TYPE ( mmsClassType ) :: & SoundSpeedMMS_ClassObj , & SourceTermMMS_ClassObj LOGICAL :: debug = . TRUE . COMPLEX ( KIND = rDef ), DIMENSION (:), ALLOCATABLE :: & k , & S_eig , & S_actual , & S_1 , & S_2 , & S_3 , & S_4 , & S_A11 , & S_A12 , & S_A13 , & S_A14 , & S_A21 , & S_A22 , & S_A23 , & S_A24 , & S_A31 , & S_A32 , & S_A33 , & S_A34 , & S_A41 , & S_A42 , & S_A43 , & S_A44 , & S_B11 , & S_B12 , & S_B13 , & S_B14 , & S_B21 , & S_B22 , & S_B23 , & S_B24 , & S_B31 , & S_B32 , & S_B33 , & S_B34 , & S_B41 , & S_B42 , & S_B43 , & S_B44 , & S_Expected , & S_error , & S_L2Array , & eigenVector , & eigenVectorMMS COMPLEX ( KIND = rDef ) :: & frequency ,& !non-dimensional frequency hubAdmittance ,& !Liner Admittance At the Hub ductAdmittance ,& ci ,& S_L2 ,& axialWavenumberMMS COMPLEX ( KIND = rDef ), DIMENSION (:), ALLOCATABLE :: & !     S_A_expected , & !     S_B_expected , & S_A_actual , & S_B_actual REAL ( KIND = rDef ), DIMENSION (:), ALLOCATABLE :: & r ,& !radial grid locations axialMachData ,& !M_x thetaMachData ,& !M_th totalMachData ,& !M_total = sqrt(M_x&#94;2+M_th&#94;2) SoundSpeedExpected ,& !Based on Eqn 2.6 in Kousen's paper rOut ,& !radial grid after it leaves swirlClassObj axialMachDataOut ,& !M_x         after it leaves swirlClassObj thetaMachDataOut ,& !M_th        after it leaves swirlClassObj SoundSpeedOut ,& !Sound Speed after it leaves swirlClassObj axialMachData_dr_Out ,& !dM_x/dr thetaMachData_dr_Out ,& !dM_th/dr SoundSpeed_dr_Out ,& !dA/dr SoundSpeedError ,& !eps_A SoundSpeedL2Array ,& !array of L2norm (eps_A) ! Perturbation variables vR ,& !radial     velocity vT ,& !tangential velocity vX ,& !axial velocity Pr ,& !pressure RateOfConvergence1 ,& RateOfConvergence2 REAL ( KIND = REAL64 ) :: & gam ,& gm1 ,& secondOrderSmoother ,& !2nd order smoothing coefficient fourthOrderSmoother ,& !4th order smoothing coefficient boundingConstant ,& dr ,& hubToTipRatio ,& SoundSpeedErrorL2 REAL ( KIND = rDef ), PARAMETER :: & r_min = 0.20_rDef ,& r_max = 1.000_rDef","tags":"","loc":"sourcefile/main-variables-checkpoint.f90.html"},{"title":"mmsClassType – Fortran Program ","text":"type, public :: mmsClassType Contents None","tags":"","loc":"type/mmsclasstype.html"},{"title":"SwirlClassType – Fortran Program ","text":"type, public :: SwirlClassType Contents None","tags":"","loc":"type/swirlclasstype.html"},{"title":"SourceCalc – Fortran Program","text":"subroutine SourceCalc(r, S_1, S_2, S_3, S_4) Arguments Type Intent Optional Attributes Name real(kind=rDef), intent(in), DIMENSION(:) :: r complex(kind=rDef), intent(inout), DIMENSION(:) :: S_1 complex(kind=rDef), intent(inout), DIMENSION(:) :: S_2 complex(kind=rDef), intent(inout), DIMENSION(:) :: S_3 complex(kind=rDef), intent(inout), DIMENSION(:) :: S_4 Contents None","tags":"","loc":"proc/sourcecalc.html"},{"title":"CalcSoundSpeed – Fortran Program","text":"subroutine CalcSoundSpeed(r, SoundSpeedExpected, thetaMachData, axialMachData) Arguments Type Intent Optional Attributes Name real(kind=rDef), intent(in), DIMENSION(:) :: r real(kind=rDef), intent(inout), DIMENSION(:) :: SoundSpeedExpected real(kind=rDef), intent(inout), DIMENSION(:) :: thetaMachData real(kind=rDef), intent(inout), DIMENSION(:) :: axialMachData Contents None","tags":"","loc":"proc/calcsoundspeed.html"},{"title":"SourceCalcComponents – Fortran Program","text":"subroutine SourceCalcComponents(gam, i, ak, m, r, S_1, S_2, S_3, S_4, S_A11, S_A12, S_A13, S_A14, S_A21, S_A22, S_A23, S_A24, S_A31, S_A32, S_A33, S_A34, S_A41, S_A42, S_A43, S_A44, S_B11, S_B12, S_B13, S_B14, S_B21, S_B22, S_B23, S_B24, S_B31, S_B32, S_B33, S_B34, S_B41, S_B42, S_B43, S_B44) Arguments Type Intent Optional Attributes Name complex(kind=rDef), intent(in) :: gam complex(kind=rDef), intent(in) :: i complex(kind=rDef), intent(in) :: ak integer, intent(in) :: m real(kind=rDef), intent(in) :: r complex(kind=rDef), intent(inout) :: S_1 complex(kind=rDef), intent(inout) :: S_2 complex(kind=rDef), intent(inout) :: S_3 complex(kind=rDef), intent(inout) :: S_4 complex(kind=rDef), intent(inout) :: S_A11 complex(kind=rDef), intent(inout) :: S_A12 complex(kind=rDef), intent(inout) :: S_A13 complex(kind=rDef), intent(inout) :: S_A14 complex(kind=rDef), intent(inout) :: S_A21 complex(kind=rDef), intent(inout) :: S_A22 complex(kind=rDef), intent(inout) :: S_A23 complex(kind=rDef), intent(inout) :: S_A24 complex(kind=rDef), intent(inout) :: S_A31 complex(kind=rDef), intent(inout) :: S_A32 complex(kind=rDef), intent(inout) :: S_A33 complex(kind=rDef), intent(inout) :: S_A34 complex(kind=rDef), intent(inout) :: S_A41 complex(kind=rDef), intent(inout) :: S_A42 complex(kind=rDef), intent(inout) :: S_A43 complex(kind=rDef), intent(inout) :: S_A44 complex(kind=rDef), intent(inout) :: S_B11 complex(kind=rDef), intent(inout) :: S_B12 complex(kind=rDef), intent(inout) :: S_B13 complex(kind=rDef), intent(inout) :: S_B14 complex(kind=rDef), intent(inout) :: S_B21 complex(kind=rDef), intent(inout) :: S_B22 complex(kind=rDef), intent(inout) :: S_B23 complex(kind=rDef), intent(inout) :: S_B24 complex(kind=rDef), intent(inout) :: S_B31 complex(kind=rDef), intent(inout) :: S_B32 complex(kind=rDef), intent(inout) :: S_B33 complex(kind=rDef), intent(inout) :: S_B34 complex(kind=rDef), intent(inout) :: S_B41 complex(kind=rDef), intent(inout) :: S_B42 complex(kind=rDef), intent(inout) :: S_B43 complex(kind=rDef), intent(inout) :: S_B44 Contents None","tags":"","loc":"proc/sourcecalccomponents.html"},{"title":"SourceCalc – Fortran Program","text":"subroutine SourceCalc(r, S_1, S_2, S_3, S_4) Arguments Type Intent Optional Attributes Name real(kind=rDef), intent(in), DIMENSION(:) :: r complex(kind=rDef), intent(inout), DIMENSION(:) :: S_1 complex(kind=rDef), intent(inout), DIMENSION(:) :: S_2 complex(kind=rDef), intent(inout), DIMENSION(:) :: S_3 complex(kind=rDef), intent(inout), DIMENSION(:) :: S_4 Contents None","tags":"","loc":"proc/sourcecalc~2.html"},{"title":"CalcPerturbationVariables – Fortran Program","text":"subroutine CalcPerturbationVariables(r, vR, vTh, vX, Pr) Arguments Type Intent Optional Attributes Name real(kind=rDef), intent(in), DIMENSION(:) :: r real(kind=rDef), intent(inout), DIMENSION(:) :: vR real(kind=rDef), intent(inout), DIMENSION(:) :: vTh real(kind=rDef), intent(inout), DIMENSION(:) :: vX real(kind=rDef), intent(inout), DIMENSION(:) :: Pr Contents None","tags":"","loc":"proc/calcperturbationvariables.html"},{"title":"SourceCalc – Fortran Program","text":"subroutine SourceCalc(gam, i, ak, kappa, m, r, r_max, S_1, S_2, S_3, S_4) Arguments Type Intent Optional Attributes Name complex(kind=rDef), intent(in) :: gam complex(kind=rDef), intent(in) :: i complex(kind=rDef), intent(in) :: ak real(kind=rDef), intent(in) :: kappa integer, intent(in) :: m real(kind=rDef), intent(in) :: r real(kind=rDef), intent(in) :: r_max complex(kind=rDef), intent(inout) :: S_1 complex(kind=rDef), intent(inout) :: S_2 complex(kind=rDef), intent(inout) :: S_3 complex(kind=rDef), intent(inout) :: S_4 Contents None","tags":"","loc":"proc/sourcecalc~3.html"},{"title":"SourceCalcComponents – Fortran Program","text":"subroutine SourceCalcComponents(gam, i, ak, kappa, m, r, r_max, S_1, S_2, S_3, S_4, S_A11, S_A12, S_A13, S_A14, S_A21, S_A22, S_A23, S_A24, S_A31, S_A32, S_A33, S_A34, S_A41, S_A42, S_A43, S_A44, S_B11, S_B12, S_B13, S_B14, S_B21, S_B22, S_B23, S_B24, S_B31, S_B32, S_B33, S_B34, S_B41, S_B42, S_B43, S_B44) Arguments Type Intent Optional Attributes Name complex(kind=rDef), intent(in) :: gam complex(kind=rDef), intent(in) :: i complex(kind=rDef), intent(in) :: ak real(kind=rDef), intent(in) :: kappa integer, intent(in) :: m real(kind=rDef), intent(in) :: r real(kind=rDef), intent(in) :: r_max complex(kind=rDef), intent(inout) :: S_1 complex(kind=rDef), intent(inout) :: S_2 complex(kind=rDef), intent(inout) :: S_3 complex(kind=rDef), intent(inout) :: S_4 complex(kind=rDef), intent(inout) :: S_A11 complex(kind=rDef), intent(inout) :: S_A12 complex(kind=rDef), intent(inout) :: S_A13 complex(kind=rDef), intent(inout) :: S_A14 complex(kind=rDef), intent(inout) :: S_A21 complex(kind=rDef), intent(inout) :: S_A22 complex(kind=rDef), intent(inout) :: S_A23 complex(kind=rDef), intent(inout) :: S_A24 complex(kind=rDef), intent(inout) :: S_A31 complex(kind=rDef), intent(inout) :: S_A32 complex(kind=rDef), intent(inout) :: S_A33 complex(kind=rDef), intent(inout) :: S_A34 complex(kind=rDef), intent(inout) :: S_A41 complex(kind=rDef), intent(inout) :: S_A42 complex(kind=rDef), intent(inout) :: S_A43 complex(kind=rDef), intent(inout) :: S_A44 complex(kind=rDef), intent(inout) :: S_B11 complex(kind=rDef), intent(inout) :: S_B12 complex(kind=rDef), intent(inout) :: S_B13 complex(kind=rDef), intent(inout) :: S_B14 complex(kind=rDef), intent(inout) :: S_B21 complex(kind=rDef), intent(inout) :: S_B22 complex(kind=rDef), intent(inout) :: S_B23 complex(kind=rDef), intent(inout) :: S_B24 complex(kind=rDef), intent(inout) :: S_B31 complex(kind=rDef), intent(inout) :: S_B32 complex(kind=rDef), intent(inout) :: S_B33 complex(kind=rDef), intent(inout) :: S_B34 complex(kind=rDef), intent(inout) :: S_B41 complex(kind=rDef), intent(inout) :: S_B42 complex(kind=rDef), intent(inout) :: S_B43 complex(kind=rDef), intent(inout) :: S_B44 Contents None","tags":"","loc":"proc/sourcecalccomponents~2.html"},{"title":"CalcSoundSpeed – Fortran Program","text":"subroutine CalcSoundSpeed(r, kappa, SoundSpeedExpected, thetaMachData, axialMachData) Arguments Type Intent Optional Attributes Name real(kind=rDef), intent(in), DIMENSION(:) :: r real(kind=rDef), intent(in) :: kappa real(kind=rDef), intent(inout), DIMENSION(:) :: SoundSpeedExpected real(kind=rDef), intent(inout), DIMENSION(:) :: thetaMachData real(kind=rDef), intent(inout), DIMENSION(:) :: axialMachData Contents None","tags":"","loc":"proc/calcsoundspeed~2.html"},{"title":"analysis – Fortran Program","text":"public interface analysis Contents Module Procedures analysis1 Module Procedures private subroutine analysis1(np, np4, ak, rr, snd, rmx, rmt, aa, bb, alpha, beta, VL, VR, work, rwork, gam, jobvl, jobvr, mm, ir, is, vphi, akap) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np integer, intent(in) :: np4 complex(kind=rDef), intent(in) :: ak real(kind=rDef), intent(in), DIMENSION(:) :: rr real(kind=rDef), intent(in), DIMENSION(:) :: snd real(kind=rDef), intent(in), DIMENSION(:) :: rmx real(kind=rDef), intent(in), DIMENSION(:) :: rmt complex(kind=rDef), intent(in), DIMENSION(:,:) :: aa complex(kind=rDef), intent(in), DIMENSION(:,:) :: bb complex(kind=rDef), intent(in), DIMENSION(:) :: alpha complex(kind=rDef), intent(in), DIMENSION(:) :: beta complex(kind=rDef), intent(in), DIMENSION(:,:) :: VL complex(kind=rDef), intent(in), DIMENSION(:,:) :: VR complex(kind=rDef), intent(in), DIMENSION(:) :: work real(kind=rDef), intent(in), DIMENSION(:) :: rwork complex(kind=rDef), intent(out), DIMENSION(:) :: gam character, intent(in) :: jobvl character, intent(in) :: jobvr integer, intent(in) :: mm integer, intent(in) :: ir integer, intent(in) :: is complex(kind=rDef), intent(out), DIMENSION(:) :: vphi real(kind=rDef), intent(out), DIMENSION(:) :: akap","tags":"","loc":"interface/analysis.html"},{"title":"fdrivs – Fortran Program","text":"public interface fdrivs Contents Module Procedures fdrivs1 Module Procedures private subroutine fdrivs1(np, sig, dl1, iorder, ed2, ed4) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np real(kind=rDef), intent(in) :: sig real(kind=rDef), intent(inout), DIMENSION(:,:) :: dl1 integer, intent(in) :: iorder real(kind=rDef), intent(in) :: ed2 real(kind=rDef), intent(in) :: ed4","tags":"","loc":"interface/fdrivs.html"},{"title":"indexx – Fortran Program","text":"public interface indexx Contents Module Procedures indexx1 Module Procedures private subroutine INDEXX1(n, arrin, indx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rDef), intent(inout), DIMENSION(:) :: arrin integer, intent(out), DIMENSION(:) :: indx","tags":"","loc":"interface/indexx.html"},{"title":"output – Fortran Program","text":"public interface output Contents Module Procedures output1 Module Procedures private subroutine output1(np, np4, mode, rho, omega, egv, attenh, attend, rmx, drm, rmt, drt, snd, rr, wvn, vrm, vphi, is) Compute average axial Mach number. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: np integer, intent(in) :: np4 integer, intent(in) :: mode real(kind=rDef), intent(in) :: rho complex(kind=rDef), intent(in) :: omega character, intent(in) :: egv complex(kind=rDef), intent(in) :: attenh complex(kind=rDef), intent(in) :: attend real(kind=rDef), intent(in), DIMENSION(:) :: rmx real(kind=rDef), intent(in), DIMENSION(:) :: drm real(kind=rDef), intent(in), DIMENSION(:) :: rmt real(kind=rDef), intent(in), DIMENSION(:) :: drt real(kind=rDef), intent(in), DIMENSION(:) :: snd real(kind=rDef), intent(in), DIMENSION(:) :: rr complex(kind=rDef), intent(in), DIMENSION(:) :: wvn complex(kind=rDef), intent(in), DIMENSION(:,:) :: vrm complex(kind=rDef), intent(in), DIMENSION(:) :: vphi integer, intent(in) :: is","tags":"","loc":"interface/output.html"},{"title":"boundary – Fortran Program","text":"public interface boundary Contents Module Procedures boundary1 Module Procedures private subroutine boundary1(np, sig, ak, etah, etad, rmx, rmt, dd, aa, bb) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np real(kind=rDef), intent(in) :: sig complex(kind=rDef), intent(in) :: ak complex(kind=rDef), intent(in) :: etah complex(kind=rDef), intent(in) :: etad real(kind=rDef), intent(in), DIMENSION(:) :: rmx real(kind=rDef), intent(in), DIMENSION(:) :: rmt real(kind=rDef), intent(in), DIMENSION(:,:) :: dd complex(kind=rDef), intent(inout), DIMENSION(:,:) :: aa complex(kind=rDef), intent(inout), DIMENSION(:,:) :: bb","tags":"","loc":"interface/boundary.html"},{"title":"input – Fortran Program","text":"public interface input Contents Module Procedures input1 Module Procedures private subroutine input1(mode, np, np4, rho, freq, ixp, nxp, irr, rxmax, slp, iss, ang, gm, vlchar, vrchar, itst, etah, etad, irpt, ifdff, eps2, eps4, icomp) Arguments Type Intent Optional Attributes Name integer, intent(out) :: mode integer, intent(out) :: np integer, intent(out) :: np4 real(kind=rDef), intent(out) :: rho complex(kind=rDef), intent(out) :: freq integer, intent(out) :: ixp integer, intent(out) :: nxp integer, intent(out) :: irr real(kind=rDef), intent(out) :: rxmax real(kind=rDef), intent(out) :: slp integer, intent(out) :: iss real(kind=rDef), intent(out) :: ang real(kind=rDef), intent(out) :: gm character, intent(out) :: vlchar character, intent(out) :: vrchar integer, intent(out) :: itst complex(kind=rDef), intent(out) :: etah complex(kind=rDef), intent(out) :: etad integer, intent(out) :: irpt integer, intent(out) :: ifdff real(kind=rDef), intent(out) :: eps2 real(kind=rDef), intent(out) :: eps4 integer, intent(out) :: icomp","tags":"","loc":"interface/input.html"},{"title":"Akima433Interpolation – Fortran Program","text":"public interface Akima433Interpolation Contents Module Procedures Akima433InterpolationSP Akima433InterpolationDP Module Procedures private subroutine Akima433InterpolationSP(inputDataLength, xInputData, yInputData, outputDataLength, xOutputData, yOutputData) Arguments Type Intent Optional Attributes Name integer, intent(in) :: inputDataLength real(kind=REAL32), intent(in), DIMENSION(:) :: xInputData real(kind=REAL32), intent(in), DIMENSION(:) :: yInputData integer, intent(in) :: outputDataLength real(kind=REAL32), intent(in), DIMENSION(:) :: xOutputData real(kind=REAL32), intent(out), DIMENSION(:) :: yOutputData private subroutine Akima433InterpolationDP(inputDataLength, xInputData, yInputData, outputDataLength, xOutputData, yOutputData) Arguments Type Intent Optional Attributes Name integer, intent(in) :: inputDataLength real(kind=REAL64), intent(in), DIMENSION(:) :: xInputData real(kind=REAL64), intent(in), DIMENSION(:) :: yInputData integer, intent(in) :: outputDataLength real(kind=REAL64), intent(in), DIMENSION(:) :: xOutputData real(kind=REAL64), intent(out), DIMENSION(:) :: yOutputData","tags":"","loc":"interface/akima433interpolation.html"},{"title":"Akima433CurveFit – Fortran Program","text":"public interface Akima433CurveFit Contents Module Procedures Akima433CurveFitSP Akima433CurveFitDP Module Procedures private subroutine Akima433CurveFitSP(inputDataLength, functionHasMultipleValues, xInputData, yInputData, numberOfSubintervals, outputDataLength, xOutputData, yOutputData) Arguments Type Intent Optional Attributes Name integer, intent(in) :: inputDataLength logical, intent(in) :: functionHasMultipleValues real(kind=REAL32), intent(in), DIMENSION(:) :: xInputData real(kind=REAL32), intent(in), DIMENSION(:) :: yInputData integer, intent(in) :: numberOfSubintervals integer, intent(in) :: outputDataLength real(kind=REAL32), intent(in), DIMENSION(:) :: xOutputData real(kind=REAL32), intent(out), DIMENSION(:) :: yOutputData private subroutine Akima433CurveFitDP(inputDataLength, functionHasMultipleValues, xInputData, yInputData, numberOfSubintervals, outputDataLength, xOutputData, yOutputData) Arguments Type Intent Optional Attributes Name integer, intent(in) :: inputDataLength logical, intent(in) :: functionHasMultipleValues real(kind=REAL64), intent(in), DIMENSION(:) :: xInputData real(kind=REAL64), intent(in), DIMENSION(:) :: yInputData integer, intent(in) :: numberOfSubintervals integer, intent(in) :: outputDataLength real(kind=REAL64), intent(in), DIMENSION(:) :: xOutputData real(kind=REAL64), intent(out), DIMENSION(:) :: yOutputData","tags":"","loc":"interface/akima433curvefit.html"},{"title":"getL2Norm – Fortran Program","text":"public interface getL2Norm Contents Module Procedures L2N L2N_One_Dataset L2N_One_Dataset_Complex L2N_COMPLEX L2N_2D Module Procedures private subroutine L2N(object, L2, dataSet1, dataSet2) Arguments Type Intent Optional Attributes Name type( mmsClassType ), intent(inout) :: object real(kind=rDef), intent(inout) :: L2 real(kind=rDef), intent(in), DIMENSION(:) :: dataSet1 real(kind=rDef), intent(in), DIMENSION(:) :: dataSet2 private subroutine L2N_One_Dataset(object, L2, dataSet) Arguments Type Intent Optional Attributes Name type( mmsClassType ), intent(inout) :: object real(kind=rDef), intent(inout) :: L2 real(kind=rDef), intent(in), DIMENSION(:) :: dataSet private subroutine L2N_One_Dataset_Complex(object, L2, dataSet) Arguments Type Intent Optional Attributes Name type( mmsClassType ), intent(inout) :: object complex(kind=rDef), intent(inout) :: L2 complex(kind=rDef), intent(in), DIMENSION(:) :: dataSet private subroutine L2N_COMPLEX(object, L2, dataSet1, dataSet2) Arguments Type Intent Optional Attributes Name type( mmsClassType ), intent(inout) :: object complex(kind=rDef), intent(inout) :: L2 complex(kind=rDef), intent(in), DIMENSION(:) :: dataSet1 complex(kind=rDef), intent(in), DIMENSION(:) :: dataSet2 private subroutine L2N_2D(object, L2, dataSet1, dataSet2, numPoints) Arguments Type Intent Optional Attributes Name type( mmsClassType ), intent(inout) :: object complex(kind=rDef), intent(inout) :: L2 complex(kind=rDef), intent(in), DIMENSION(:,:) :: dataSet1 complex(kind=rDef), intent(in), DIMENSION(:,:) :: dataSet2 integer, intent(inout) :: numPoints","tags":"","loc":"interface/getl2norm.html"},{"title":"getRateOfConvergence – Fortran Program","text":"public interface getRateOfConvergence Contents Module Procedures getROC getROC_Complex Module Procedures private subroutine getROC(object, ExpectedRateOfConvergence, RateOfConvergence, L2Array) Arguments Type Intent Optional Attributes Name type( mmsClassType ), intent(inout) :: object real(kind=rDef), intent(in) :: ExpectedRateOfConvergence real(kind=rDef), intent(out), DIMENSION(:) :: RateOfConvergence real(kind=rDef), intent(in), DIMENSION(:) :: L2Array private subroutine getROC_Complex(object, RateOfConvergence, L2Array) Arguments Type Intent Optional Attributes Name type( mmsClassType ), intent(inout) :: object real(kind=rDef), intent(out), DIMENSION(:) :: RateOfConvergence complex(kind=rDef), intent(in), DIMENSION(:) :: L2Array","tags":"","loc":"interface/getrateofconvergence.html"},{"title":"smachAndSndspd – Fortran Program","text":"public interface smachAndSndspd Contents Module Procedures smachAndSndspd1 Module Procedures private subroutine smachAndSndspd1(npts, rr, rmsw, rmswp, snd, dsn, dd) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npts real(kind=rDef), intent(in), DIMENSION(:) :: rr real(kind=rDef), intent(out), DIMENSION(:) :: rmsw real(kind=rDef), intent(out), DIMENSION(:) :: rmswp real(kind=rDef), intent(inout), DIMENSION(:) :: snd real(kind=rDef), intent(out), DIMENSION(:) :: dsn real(kind=rDef), intent(in), DIMENSION(:,:) :: dd","tags":"","loc":"interface/smachandsndspd.html"},{"title":"rmach – Fortran Program","text":"public interface rmach Contents Module Procedures rmach1 Module Procedures private subroutine rmach1(npts, rmch, drm, dd) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npts real(kind=rDef), intent(out), DIMENSION(:) :: rmch real(kind=rDef), intent(out), DIMENSION(:) :: drm real(kind=rDef), intent(in), DIMENSION(:,:) :: dd","tags":"","loc":"interface/rmach.html"},{"title":"globalM – Fortran Program","text":"public interface globalM Contents Module Procedures globalM1 Module Procedures private subroutine globalM1(np, np4, sig, mode, om, snd, dd, rr, rx, dr, rt, dt, aa, bb, S_aa, S_bb, row, col) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np integer, intent(in) :: np4 real(kind=rDef), intent(in) :: sig integer, intent(in) :: mode complex(kind=rDef), intent(in) :: om real(kind=rDef), intent(in), DIMENSION(:) :: snd real(kind=rDef), intent(in), DIMENSION(:,:) :: dd real(kind=rDef), intent(in), DIMENSION(:) :: rr real(kind=rDef), intent(in), DIMENSION(:) :: rx real(kind=rDef), intent(in), DIMENSION(:) :: dr real(kind=rDef), DIMENSION(np) :: rt real(kind=rDef), intent(in), DIMENSION(:) :: dt complex(kind=rDef), intent(out), DIMENSION(:,:) :: aa complex(kind=rDef), intent(out), DIMENSION(:,:) :: bb complex(kind=rDef), intent(out), DIMENSION(:,:) :: S_aa complex(kind=rDef), intent(out), DIMENSION(:,:) :: S_bb integer, intent(in) :: row integer, intent(in) :: col","tags":"","loc":"interface/globalm.html"},{"title":"CreateObject – Fortran Program","text":"public interface CreateObject Contents Module Procedures CreateSwirlClassObject Module Procedures private subroutine CreateSwirlClassObject(object, azimuthalMode, np, sig, axialMachData, tangentialMachData, ak, etah, etad, ifdff) Arguments Type Intent Optional Attributes Name type( SwirlClassType ), intent(inout) :: object integer, intent(inout) :: azimuthalMode integer, intent(inout) :: np real(kind=REAL64), intent(inout) :: sig real(kind=REAL64), intent(inout), DIMENSION(:) :: axialMachData real(kind=REAL64), intent(inout), DIMENSION(:) :: tangentialMachData complex(kind=REAL64), intent(in) :: ak complex(kind=REAL64), intent(in) :: etah complex(kind=REAL64), intent(in) :: etad integer, intent(inout) :: ifdff","tags":"","loc":"interface/createobject.html"},{"title":"runSwirlClassMethods – Fortran Program","text":"public interface runSwirlClassMethods Contents Module Procedures runSWIRL Module Procedures private subroutine runSWIRL(object) Arguments Type Intent Optional Attributes Name type( SwirlClassType ), intent(inout) :: object","tags":"","loc":"interface/runswirlclassmethods.html"},{"title":"CreateMMSObject – Fortran Program","text":"public interface CreateMMSObject Contents Module Procedures CreateSwirlClassObjectMMS Module Procedures private subroutine CreateSwirlClassObjectMMS() Arguments None","tags":"","loc":"interface/createmmsobject.html"},{"title":"FindResidualData – Fortran Program","text":"public interface FindResidualData Contents Module Procedures GetResidualVector Module Procedures private subroutine GetResidualVector(object, eigenVector, eigenValue, S) Arguments Type Intent Optional Attributes Name type( SwirlClassType ), intent(in) :: object complex(kind=rDef), intent(in), DIMENSION(object%numberOfRadialPoints*4) :: eigenVector complex(kind=rDef), intent(in) :: eigenValue complex(kind=rDef), intent(inout), DIMENSION(object%numberOfRadialPoints*4) :: S","tags":"","loc":"interface/findresidualdata.html"},{"title":"GetModeData – Fortran Program","text":"public interface GetModeData Contents Module Procedures GetRadialModeData Module Procedures private subroutine GetRadialModeData(object, eigenValue, eigenVector, eigenIndex) Arguments Type Intent Optional Attributes Name type( SwirlClassType ), intent(in) :: object complex(kind=rDef), intent(inout) :: eigenValue complex(kind=rDef), intent(inout), DIMENSION(object%numberOfRadialPoints*4) :: eigenVector integer, intent(in) :: eigenIndex","tags":"","loc":"interface/getmodedata.html"},{"title":"GetMeanFlowData – Fortran Program","text":"public interface GetMeanFlowData Contents Module Procedures GetMeanData Module Procedures private subroutine GetMeanData(object, axialMach, thetaMach, axialMach_dr, thetaMach_dr, SoundSpeed, SoundSpeed_dr, radialData) Arguments Type Intent Optional Attributes Name type( SwirlClassType ), intent(in) :: object real(kind=rDef), intent(out), DIMENSION(object%numberOfRadialPoints) :: axialMach real(kind=rDef), intent(out), DIMENSION(object%numberOfRadialPoints) :: thetaMach real(kind=rDef), intent(out), DIMENSION(object%numberOfRadialPoints) :: axialMach_dr real(kind=rDef), intent(out), DIMENSION(object%numberOfRadialPoints) :: thetaMach_dr real(kind=rDef), intent(out), DIMENSION(object%numberOfRadialPoints) :: SoundSpeed real(kind=rDef), intent(out), DIMENSION(object%numberOfRadialPoints) :: SoundSpeed_dr real(kind=rDef), intent(out), DIMENSION(object%numberOfRadialPoints) :: radialData","tags":"","loc":"interface/getmeanflowdata.html"},{"title":"DestroyObject – Fortran Program","text":"public interface DestroyObject Contents Module Procedures DestroySwirlClassObject Module Procedures private subroutine DestroySwirlClassObject(object) Arguments Type Intent Optional Attributes Name type( SwirlClassType ), intent(inout) :: object","tags":"","loc":"interface/destroyobject.html"},{"title":"derivs – Fortran Program","text":"public interface derivs Contents Module Procedures derivs1 Module Procedures private subroutine derivs1(np, sig, dl1, ed2, ed4) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np real(kind=rDef), intent(in) :: sig real(kind=rDef), intent(inout), DIMENSION(:,:) :: dl1 real(kind=rDef), intent(in) :: ed2 real(kind=rDef), intent(in) :: ed4","tags":"","loc":"interface/derivs.html"},{"title":"fdgrid – Fortran Program","text":"public interface fdgrid Contents Module Procedures fdgrid1 Module Procedures private subroutine fdgrid1(np, sig, x, r) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np real(kind=rDef), intent(in) :: sig real(kind=rDef), intent(out), DIMENSION(:) :: x real(kind=rDef), intent(out), DIMENSION(:) :: r","tags":"","loc":"interface/fdgrid.html"},{"title":"interp – Fortran Program","text":"public interface interp Contents Module Procedures interp1 Module Procedures private subroutine interp1(np, sig, rr, rmx, drm, rmt, drt, snd, dsn, dd, ifdff, ed2, ed4) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np real(kind=rDef), intent(out) :: sig real(kind=rDef), intent(out), DIMENSION(:) :: rr real(kind=rDef), intent(out), DIMENSION(:) :: rmx real(kind=rDef), intent(in), DIMENSION(:) :: drm real(kind=rDef), intent(out), DIMENSION(:) :: rmt real(kind=rDef), intent(in), DIMENSION(:) :: drt real(kind=rDef), intent(out), DIMENSION(:) :: snd real(kind=rDef), intent(in), DIMENSION(:) :: dsn real(kind=rDef), intent(inout), DIMENSION(:,:) :: dd integer, intent(in) :: ifdff real(kind=rDef), intent(in) :: ed2 real(kind=rDef), intent(in) :: ed4","tags":"","loc":"interface/interp.html"},{"title":"sndspd – Fortran Program","text":"public interface sndspd Contents Module Procedures sndspd1 Module Procedures private subroutine sndspd1(np, rr, rmsw, asnd, dsnd, dd, rhob, angom, gam, sig, is) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np real(kind=rDef), intent(in), DIMENSION(:) :: rr real(kind=rDef), intent(in), DIMENSION(:) :: rmsw real(kind=rDef), intent(out), DIMENSION(:) :: asnd real(kind=rDef), intent(out), DIMENSION(:) :: dsnd real(kind=rDef), intent(in), DIMENSION(:,:) :: dd real(kind=rDef), intent(in), DIMENSION(:) :: rhob real(kind=rDef), intent(in) :: angom real(kind=rDef), intent(in) :: gam real(kind=rDef), intent(in) :: sig integer, intent(in) :: is","tags":"","loc":"interface/sndspd.html"},{"title":"smach – Fortran Program","text":"public interface smach Contents Module Procedures smach1 Module Procedures private subroutine smach1(npts, rr, rmsw, rmswp, snd, dsn, dd, angom, gam, rro, is) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npts real(kind=rDef), intent(in), DIMENSION(:) :: rr real(kind=rDef), intent(out), DIMENSION(:) :: rmsw real(kind=rDef), intent(out), DIMENSION(:) :: rmswp real(kind=rDef), intent(in), DIMENSION(:) :: snd real(kind=rDef), intent(in), DIMENSION(:) :: dsn real(kind=rDef), intent(in), DIMENSION(:,:) :: dd real(kind=rDef), intent(in) :: angom real(kind=rDef), intent(in) :: gam real(kind=rDef), intent(in) :: rro integer, intent(in) :: is","tags":"","loc":"interface/smach.html"},{"title":"getMMSSourceTerms – Fortran Program","text":"public interface getMMSSourceTerms Contents Module Procedures SourceCalc Module Procedures private subroutine SourceCalc(r, S_1, S_2, S_3, S_4) Arguments Type Intent Optional Attributes Name real(kind=rDef), intent(in), DIMENSION(:) :: r complex(kind=rDef), intent(inout), DIMENSION(:) :: S_1 complex(kind=rDef), intent(inout), DIMENSION(:) :: S_2 complex(kind=rDef), intent(inout), DIMENSION(:) :: S_3 complex(kind=rDef), intent(inout), DIMENSION(:) :: S_4","tags":"","loc":"interface/getmmssourceterms.html"},{"title":"getSoundSpeed – Fortran Program","text":"public interface getSoundSpeed Contents Module Procedures CalcSoundSpeed Module Procedures private subroutine CalcSoundSpeed(r, SoundSpeedExpected, thetaMachData, axialMachData) Arguments Type Intent Optional Attributes Name real(kind=rDef), intent(in), DIMENSION(:) :: r real(kind=rDef), intent(inout), DIMENSION(:) :: SoundSpeedExpected real(kind=rDef), intent(inout), DIMENSION(:) :: thetaMachData real(kind=rDef), intent(inout), DIMENSION(:) :: axialMachData","tags":"","loc":"interface/getsoundspeed.html"},{"title":"getPerturbationVariables – Fortran Program","text":"public interface getPerturbationVariables Contents Module Procedures CalcPerturbationVariables Module Procedures private subroutine CalcPerturbationVariables(r, vR, vTh, vX, Pr) Arguments Type Intent Optional Attributes Name real(kind=rDef), intent(in), DIMENSION(:) :: r real(kind=rDef), intent(inout), DIMENSION(:) :: vR real(kind=rDef), intent(inout), DIMENSION(:) :: vTh real(kind=rDef), intent(inout), DIMENSION(:) :: vX real(kind=rDef), intent(inout), DIMENSION(:) :: Pr","tags":"","loc":"interface/getperturbationvariables.html"},{"title":"getL2Norm – Fortran Program","text":"public interface getL2Norm Contents Module Procedures L2N L2N_One_Dataset L2N_One_Dataset_Complex L2N_COMPLEX L2N_2D Module Procedures private subroutine L2N(L2, dataSet1, dataSet2) Arguments Type Intent Optional Attributes Name real(kind=rDef), intent(inout) :: L2 real(kind=rDef), intent(in), DIMENSION(:) :: dataSet1 real(kind=rDef), intent(in), DIMENSION(:) :: dataSet2 private subroutine L2N_One_Dataset(L2, dataSet) Arguments Type Intent Optional Attributes Name real(kind=rDef), intent(inout) :: L2 real(kind=rDef), intent(in), DIMENSION(:) :: dataSet private subroutine L2N_One_Dataset_Complex(L2, dataSet) Arguments Type Intent Optional Attributes Name complex(kind=rDef), intent(inout) :: L2 complex(kind=rDef), intent(in), DIMENSION(:) :: dataSet private subroutine L2N_COMPLEX(L2, dataSet1, dataSet2) Arguments Type Intent Optional Attributes Name complex(kind=rDef), intent(inout) :: L2 complex(kind=rDef), intent(in), DIMENSION(:) :: dataSet1 complex(kind=rDef), intent(in), DIMENSION(:) :: dataSet2 private subroutine L2N_2D(L2, dataSet1, dataSet2, numPoints) Arguments Type Intent Optional Attributes Name complex(kind=rDef), intent(inout) :: L2 complex(kind=rDef), intent(in), DIMENSION(:,:) :: dataSet1 complex(kind=rDef), intent(in), DIMENSION(:,:) :: dataSet2 integer, intent(inout) :: numPoints","tags":"","loc":"interface/getl2norm~2.html"},{"title":"grid – Fortran Program","text":"public interface grid Contents Module Procedures grid1 Module Procedures private subroutine grid1(np, sig, x, r) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np real(kind=rDef), intent(in) :: sig real(kind=rDef), intent(out), DIMENSION(:) :: x real(kind=rDef), intent(out), DIMENSION(:) :: r","tags":"","loc":"interface/grid.html"},{"title":"saveEGV – Fortran Program","text":"public interface saveEGV Contents Module Procedures saveEGV2 Module Procedures private subroutine saveEGV2(np, vrm, rr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np complex(kind=rDef), intent(in), DIMENSION(:,:) :: vrm real(kind=rDef), intent(in), DIMENSION(:) :: rr","tags":"","loc":"interface/saveegv.html"},{"title":"getSvector – Fortran Program","text":"public interface getSvector Contents Module Procedures getSv1Dinput Module Procedures private subroutine getSv1Dinput(A, B, x, lambda, np4, S_MMS) Arguments Type Intent Optional Attributes Name complex(kind=REAL64), intent(in), DIMENSION(np4, np4) :: A complex(kind=REAL64), intent(in), DIMENSION(np4, np4) :: B complex(kind=REAL64), intent(inout), DIMENSION(np4) :: x complex(kind=REAL64), intent(in) :: lambda integer, intent(in) :: np4 complex(kind=REAL64), intent(inout), DIMENSION(np4) :: S_MMS","tags":"","loc":"interface/getsvector.html"},{"title":"kappa – Fortran Program","text":"public interface kappa Contents Module Procedures kappa1 Module Procedures private subroutine kappa1(mm, mumax, sig, mu, akap) Arguments Type Intent Optional Attributes Name integer, intent(in) :: mm integer, intent(in) :: mumax real(kind=rDef), intent(in) :: sig integer, intent(inout), DIMENSION(:) :: mu real(kind=rDef), intent(inout), DIMENSION(:) :: akap","tags":"","loc":"interface/kappa.html"},{"title":"machout – Fortran Program","text":"public interface machout Contents Module Procedures machout1 Module Procedures private subroutine machout1(npts, rr, rmch, rmchp, rmsw, rmswp, snd, dsn, rhob) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npts real(kind=rDef), intent(in), DIMENSION(:) :: rr real(kind=rDef), intent(in), DIMENSION(:) :: rmch real(kind=rDef), intent(in), DIMENSION(:) :: rmchp real(kind=rDef), intent(in), DIMENSION(:) :: rmsw real(kind=rDef), intent(in), DIMENSION(:) :: rmswp real(kind=rDef), intent(in), DIMENSION(:) :: snd real(kind=rDef), intent(in), DIMENSION(:) :: dsn real(kind=rDef), intent(out), DIMENSION(:) :: rhob","tags":"","loc":"interface/machout.html"},{"title":"analysisModule – Fortran Program","text":"Uses F90_ZGGEV iso_fortran_env Contents Interfaces analysis Interfaces public interface analysis private subroutine analysis1(np, np4, ak, rr, snd, rmx, rmt, aa, bb, alpha, beta, VL, VR, work, rwork, gam, jobvl, jobvr, mm, ir, is, vphi, akap) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np integer, intent(in) :: np4 complex(kind=rDef), intent(in) :: ak real(kind=rDef), intent(in), DIMENSION(:) :: rr real(kind=rDef), intent(in), DIMENSION(:) :: snd real(kind=rDef), intent(in), DIMENSION(:) :: rmx real(kind=rDef), intent(in), DIMENSION(:) :: rmt complex(kind=rDef), intent(in), DIMENSION(:,:) :: aa complex(kind=rDef), intent(in), DIMENSION(:,:) :: bb complex(kind=rDef), intent(in), DIMENSION(:) :: alpha complex(kind=rDef), intent(in), DIMENSION(:) :: beta complex(kind=rDef), intent(in), DIMENSION(:,:) :: VL complex(kind=rDef), intent(in), DIMENSION(:,:) :: VR complex(kind=rDef), intent(in), DIMENSION(:) :: work real(kind=rDef), intent(in), DIMENSION(:) :: rwork complex(kind=rDef), intent(out), DIMENSION(:) :: gam character, intent(in) :: jobvl character, intent(in) :: jobvr integer, intent(in) :: mm integer, intent(in) :: ir integer, intent(in) :: is complex(kind=rDef), intent(out), DIMENSION(:) :: vphi real(kind=rDef), intent(out), DIMENSION(:) :: akap","tags":"","loc":"module/analysismodule.html"},{"title":"fdrivsModule – Fortran Program","text":"Uses iso_fortran_env Contents Interfaces fdrivs Interfaces public interface fdrivs private subroutine fdrivs1(np, sig, dl1, iorder, ed2, ed4) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np real(kind=rDef), intent(in) :: sig real(kind=rDef), intent(inout), DIMENSION(:,:) :: dl1 integer, intent(in) :: iorder real(kind=rDef), intent(in) :: ed2 real(kind=rDef), intent(in) :: ed4","tags":"","loc":"module/fdrivsmodule.html"},{"title":"indexxModule – Fortran Program","text":"Uses iso_fortran_env Contents Interfaces indexx Interfaces public interface indexx private subroutine INDEXX1(n, arrin, indx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rDef), intent(inout), DIMENSION(:) :: arrin integer, intent(out), DIMENSION(:) :: indx","tags":"","loc":"module/indexxmodule.html"},{"title":"outputModule – Fortran Program","text":"Uses egvModule kapsubModule iso_fortran_env indexxModule Contents Interfaces output Interfaces public interface output private subroutine output1(np, np4, mode, rho, omega, egv, attenh, attend, rmx, drm, rmt, drt, snd, rr, wvn, vrm, vphi, is) Compute average axial Mach number. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: np integer, intent(in) :: np4 integer, intent(in) :: mode real(kind=rDef), intent(in) :: rho complex(kind=rDef), intent(in) :: omega character, intent(in) :: egv complex(kind=rDef), intent(in) :: attenh complex(kind=rDef), intent(in) :: attend real(kind=rDef), intent(in), DIMENSION(:) :: rmx real(kind=rDef), intent(in), DIMENSION(:) :: drm real(kind=rDef), intent(in), DIMENSION(:) :: rmt real(kind=rDef), intent(in), DIMENSION(:) :: drt real(kind=rDef), intent(in), DIMENSION(:) :: snd real(kind=rDef), intent(in), DIMENSION(:) :: rr complex(kind=rDef), intent(in), DIMENSION(:) :: wvn complex(kind=rDef), intent(in), DIMENSION(:,:) :: vrm complex(kind=rDef), intent(in), DIMENSION(:) :: vphi integer, intent(in) :: is","tags":"","loc":"module/outputmodule.html"},{"title":"boundaryModule – Fortran Program","text":"Uses iso_fortran_env Contents Interfaces boundary Interfaces public interface boundary private subroutine boundary1(np, sig, ak, etah, etad, rmx, rmt, dd, aa, bb) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np real(kind=rDef), intent(in) :: sig complex(kind=rDef), intent(in) :: ak complex(kind=rDef), intent(in) :: etah complex(kind=rDef), intent(in) :: etad real(kind=rDef), intent(in), DIMENSION(:) :: rmx real(kind=rDef), intent(in), DIMENSION(:) :: rmt real(kind=rDef), intent(in), DIMENSION(:,:) :: dd complex(kind=rDef), intent(inout), DIMENSION(:,:) :: aa complex(kind=rDef), intent(inout), DIMENSION(:,:) :: bb","tags":"","loc":"module/boundarymodule.html"},{"title":"inputModule – Fortran Program","text":"Uses iso_fortran_env Contents Interfaces input Interfaces public interface input private subroutine input1(mode, np, np4, rho, freq, ixp, nxp, irr, rxmax, slp, iss, ang, gm, vlchar, vrchar, itst, etah, etad, irpt, ifdff, eps2, eps4, icomp) Arguments Type Intent Optional Attributes Name integer, intent(out) :: mode integer, intent(out) :: np integer, intent(out) :: np4 real(kind=rDef), intent(out) :: rho complex(kind=rDef), intent(out) :: freq integer, intent(out) :: ixp integer, intent(out) :: nxp integer, intent(out) :: irr real(kind=rDef), intent(out) :: rxmax real(kind=rDef), intent(out) :: slp integer, intent(out) :: iss real(kind=rDef), intent(out) :: ang real(kind=rDef), intent(out) :: gm character, intent(out) :: vlchar character, intent(out) :: vrchar integer, intent(out) :: itst complex(kind=rDef), intent(out) :: etah complex(kind=rDef), intent(out) :: etad integer, intent(out) :: irpt integer, intent(out) :: ifdff real(kind=rDef), intent(out) :: eps2 real(kind=rDef), intent(out) :: eps4 integer, intent(out) :: icomp","tags":"","loc":"module/inputmodule.html"},{"title":"Akima1D – Fortran Program","text":"Uses iso_fortran_env Contents Interfaces Akima433Interpolation Akima433CurveFit Interfaces public interface Akima433Interpolation private subroutine Akima433InterpolationSP(inputDataLength, xInputData, yInputData, outputDataLength, xOutputData, yOutputData) Arguments Type Intent Optional Attributes Name integer, intent(in) :: inputDataLength real(kind=REAL32), intent(in), DIMENSION(:) :: xInputData real(kind=REAL32), intent(in), DIMENSION(:) :: yInputData integer, intent(in) :: outputDataLength real(kind=REAL32), intent(in), DIMENSION(:) :: xOutputData real(kind=REAL32), intent(out), DIMENSION(:) :: yOutputData private subroutine Akima433InterpolationDP(inputDataLength, xInputData, yInputData, outputDataLength, xOutputData, yOutputData) Arguments Type Intent Optional Attributes Name integer, intent(in) :: inputDataLength real(kind=REAL64), intent(in), DIMENSION(:) :: xInputData real(kind=REAL64), intent(in), DIMENSION(:) :: yInputData integer, intent(in) :: outputDataLength real(kind=REAL64), intent(in), DIMENSION(:) :: xOutputData real(kind=REAL64), intent(out), DIMENSION(:) :: yOutputData public interface Akima433CurveFit private subroutine Akima433CurveFitSP(inputDataLength, functionHasMultipleValues, xInputData, yInputData, numberOfSubintervals, outputDataLength, xOutputData, yOutputData) Arguments Type Intent Optional Attributes Name integer, intent(in) :: inputDataLength logical, intent(in) :: functionHasMultipleValues real(kind=REAL32), intent(in), DIMENSION(:) :: xInputData real(kind=REAL32), intent(in), DIMENSION(:) :: yInputData integer, intent(in) :: numberOfSubintervals integer, intent(in) :: outputDataLength real(kind=REAL32), intent(in), DIMENSION(:) :: xOutputData real(kind=REAL32), intent(out), DIMENSION(:) :: yOutputData private subroutine Akima433CurveFitDP(inputDataLength, functionHasMultipleValues, xInputData, yInputData, numberOfSubintervals, outputDataLength, xOutputData, yOutputData) Arguments Type Intent Optional Attributes Name integer, intent(in) :: inputDataLength logical, intent(in) :: functionHasMultipleValues real(kind=REAL64), intent(in), DIMENSION(:) :: xInputData real(kind=REAL64), intent(in), DIMENSION(:) :: yInputData integer, intent(in) :: numberOfSubintervals integer, intent(in) :: outputDataLength real(kind=REAL64), intent(in), DIMENSION(:) :: xOutputData real(kind=REAL64), intent(out), DIMENSION(:) :: yOutputData","tags":"","loc":"module/akima1d.html"},{"title":"mmsClassObject – Fortran Program","text":"Uses iso_fortran_env Contents Interfaces getL2Norm getRateOfConvergence Derived Types mmsClassType Interfaces public interface getL2Norm private subroutine L2N(object, L2, dataSet1, dataSet2) Arguments Type Intent Optional Attributes Name type( mmsClassType ), intent(inout) :: object real(kind=rDef), intent(inout) :: L2 real(kind=rDef), intent(in), DIMENSION(:) :: dataSet1 real(kind=rDef), intent(in), DIMENSION(:) :: dataSet2 private subroutine L2N_One_Dataset(object, L2, dataSet) Arguments Type Intent Optional Attributes Name type( mmsClassType ), intent(inout) :: object real(kind=rDef), intent(inout) :: L2 real(kind=rDef), intent(in), DIMENSION(:) :: dataSet private subroutine L2N_One_Dataset_Complex(object, L2, dataSet) Arguments Type Intent Optional Attributes Name type( mmsClassType ), intent(inout) :: object complex(kind=rDef), intent(inout) :: L2 complex(kind=rDef), intent(in), DIMENSION(:) :: dataSet private subroutine L2N_COMPLEX(object, L2, dataSet1, dataSet2) Arguments Type Intent Optional Attributes Name type( mmsClassType ), intent(inout) :: object complex(kind=rDef), intent(inout) :: L2 complex(kind=rDef), intent(in), DIMENSION(:) :: dataSet1 complex(kind=rDef), intent(in), DIMENSION(:) :: dataSet2 private subroutine L2N_2D(object, L2, dataSet1, dataSet2, numPoints) Arguments Type Intent Optional Attributes Name type( mmsClassType ), intent(inout) :: object complex(kind=rDef), intent(inout) :: L2 complex(kind=rDef), intent(in), DIMENSION(:,:) :: dataSet1 complex(kind=rDef), intent(in), DIMENSION(:,:) :: dataSet2 integer, intent(inout) :: numPoints public interface getRateOfConvergence private subroutine getROC(object, ExpectedRateOfConvergence, RateOfConvergence, L2Array) Arguments Type Intent Optional Attributes Name type( mmsClassType ), intent(inout) :: object real(kind=rDef), intent(in) :: ExpectedRateOfConvergence real(kind=rDef), intent(out), DIMENSION(:) :: RateOfConvergence real(kind=rDef), intent(in), DIMENSION(:) :: L2Array private subroutine getROC_Complex(object, RateOfConvergence, L2Array) Arguments Type Intent Optional Attributes Name type( mmsClassType ), intent(inout) :: object real(kind=rDef), intent(out), DIMENSION(:) :: RateOfConvergence complex(kind=rDef), intent(in), DIMENSION(:) :: L2Array Derived Types type, public :: mmsClassType","tags":"","loc":"module/mmsclassobject.html"},{"title":"smachAndSndspdModule – Fortran Program","text":"Uses iso_fortran_env Contents Interfaces smachAndSndspd Interfaces public interface smachAndSndspd private subroutine smachAndSndspd1(npts, rr, rmsw, rmswp, snd, dsn, dd) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npts real(kind=rDef), intent(in), DIMENSION(:) :: rr real(kind=rDef), intent(out), DIMENSION(:) :: rmsw real(kind=rDef), intent(out), DIMENSION(:) :: rmswp real(kind=rDef), intent(inout), DIMENSION(:) :: snd real(kind=rDef), intent(out), DIMENSION(:) :: dsn real(kind=rDef), intent(in), DIMENSION(:,:) :: dd","tags":"","loc":"module/smachandsndspdmodule.html"},{"title":"rmachModule – Fortran Program","text":"Uses iso_fortran_env Contents Interfaces rmach Interfaces public interface rmach private subroutine rmach1(npts, rmch, drm, dd) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npts real(kind=rDef), intent(out), DIMENSION(:) :: rmch real(kind=rDef), intent(out), DIMENSION(:) :: drm real(kind=rDef), intent(in), DIMENSION(:,:) :: dd","tags":"","loc":"module/rmachmodule.html"},{"title":"globalModule – Fortran Program","text":"Uses iso_fortran_env Contents Interfaces globalM Interfaces public interface globalM private subroutine globalM1(np, np4, sig, mode, om, snd, dd, rr, rx, dr, rt, dt, aa, bb, S_aa, S_bb, row, col) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np integer, intent(in) :: np4 real(kind=rDef), intent(in) :: sig integer, intent(in) :: mode complex(kind=rDef), intent(in) :: om real(kind=rDef), intent(in), DIMENSION(:) :: snd real(kind=rDef), intent(in), DIMENSION(:,:) :: dd real(kind=rDef), intent(in), DIMENSION(:) :: rr real(kind=rDef), intent(in), DIMENSION(:) :: rx real(kind=rDef), intent(in), DIMENSION(:) :: dr real(kind=rDef), DIMENSION(np) :: rt real(kind=rDef), intent(in), DIMENSION(:) :: dt complex(kind=rDef), intent(out), DIMENSION(:,:) :: aa complex(kind=rDef), intent(out), DIMENSION(:,:) :: bb complex(kind=rDef), intent(out), DIMENSION(:,:) :: S_aa complex(kind=rDef), intent(out), DIMENSION(:,:) :: S_bb integer, intent(in) :: row integer, intent(in) :: col","tags":"","loc":"module/globalmodule.html"},{"title":"swirlClassObject – Fortran Program","text":"Uses analysisModule gridModule globalModule boundaryModule derivsModule rmachModule smachAndSndspdModule SourceTermModule iso_fortran_env fdrivsModule FindResidualVectorModule fdgridModule mmsClassObject outputModule Contents Interfaces CreateObject runSwirlClassMethods CreateMMSObject FindResidualData GetModeData GetMeanFlowData DestroyObject Derived Types SwirlClassType Interfaces public interface CreateObject private subroutine CreateSwirlClassObject(object, azimuthalMode, np, sig, axialMachData, tangentialMachData, ak, etah, etad, ifdff) Arguments Type Intent Optional Attributes Name type( SwirlClassType ), intent(inout) :: object integer, intent(inout) :: azimuthalMode integer, intent(inout) :: np real(kind=REAL64), intent(inout) :: sig real(kind=REAL64), intent(inout), DIMENSION(:) :: axialMachData real(kind=REAL64), intent(inout), DIMENSION(:) :: tangentialMachData complex(kind=REAL64), intent(in) :: ak complex(kind=REAL64), intent(in) :: etah complex(kind=REAL64), intent(in) :: etad integer, intent(inout) :: ifdff public interface runSwirlClassMethods private subroutine runSWIRL(object) Arguments Type Intent Optional Attributes Name type( SwirlClassType ), intent(inout) :: object public interface CreateMMSObject private subroutine CreateSwirlClassObjectMMS() Arguments None public interface FindResidualData private subroutine GetResidualVector(object, eigenVector, eigenValue, S) Arguments Type Intent Optional Attributes Name type( SwirlClassType ), intent(in) :: object complex(kind=rDef), intent(in), DIMENSION(object%numberOfRadialPoints*4) :: eigenVector complex(kind=rDef), intent(in) :: eigenValue complex(kind=rDef), intent(inout), DIMENSION(object%numberOfRadialPoints*4) :: S public interface GetModeData private subroutine GetRadialModeData(object, eigenValue, eigenVector, eigenIndex) Arguments Type Intent Optional Attributes Name type( SwirlClassType ), intent(in) :: object complex(kind=rDef), intent(inout) :: eigenValue complex(kind=rDef), intent(inout), DIMENSION(object%numberOfRadialPoints*4) :: eigenVector integer, intent(in) :: eigenIndex public interface GetMeanFlowData private subroutine GetMeanData(object, axialMach, thetaMach, axialMach_dr, thetaMach_dr, SoundSpeed, SoundSpeed_dr, radialData) Arguments Type Intent Optional Attributes Name type( SwirlClassType ), intent(in) :: object real(kind=rDef), intent(out), DIMENSION(object%numberOfRadialPoints) :: axialMach real(kind=rDef), intent(out), DIMENSION(object%numberOfRadialPoints) :: thetaMach real(kind=rDef), intent(out), DIMENSION(object%numberOfRadialPoints) :: axialMach_dr real(kind=rDef), intent(out), DIMENSION(object%numberOfRadialPoints) :: thetaMach_dr real(kind=rDef), intent(out), DIMENSION(object%numberOfRadialPoints) :: SoundSpeed real(kind=rDef), intent(out), DIMENSION(object%numberOfRadialPoints) :: SoundSpeed_dr real(kind=rDef), intent(out), DIMENSION(object%numberOfRadialPoints) :: radialData public interface DestroyObject private subroutine DestroySwirlClassObject(object) Arguments Type Intent Optional Attributes Name type( SwirlClassType ), intent(inout) :: object Derived Types type, public :: SwirlClassType","tags":"","loc":"module/swirlclassobject.html"},{"title":"derivsModule – Fortran Program","text":"Uses iso_fortran_env Contents Interfaces derivs Interfaces public interface derivs private subroutine derivs1(np, sig, dl1, ed2, ed4) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np real(kind=rDef), intent(in) :: sig real(kind=rDef), intent(inout), DIMENSION(:,:) :: dl1 real(kind=rDef), intent(in) :: ed2 real(kind=rDef), intent(in) :: ed4","tags":"","loc":"module/derivsmodule.html"},{"title":"fdgridModule – Fortran Program","text":"Uses iso_fortran_env Contents Interfaces fdgrid Interfaces public interface fdgrid private subroutine fdgrid1(np, sig, x, r) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np real(kind=rDef), intent(in) :: sig real(kind=rDef), intent(out), DIMENSION(:) :: x real(kind=rDef), intent(out), DIMENSION(:) :: r","tags":"","loc":"module/fdgridmodule.html"},{"title":"interpModule – Fortran Program","text":"Uses gridModule derivsModule fdrivsModule iso_fortran_env fdgridModule Contents Interfaces interp Interfaces public interface interp private subroutine interp1(np, sig, rr, rmx, drm, rmt, drt, snd, dsn, dd, ifdff, ed2, ed4) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np real(kind=rDef), intent(out) :: sig real(kind=rDef), intent(out), DIMENSION(:) :: rr real(kind=rDef), intent(out), DIMENSION(:) :: rmx real(kind=rDef), intent(in), DIMENSION(:) :: drm real(kind=rDef), intent(out), DIMENSION(:) :: rmt real(kind=rDef), intent(in), DIMENSION(:) :: drt real(kind=rDef), intent(out), DIMENSION(:) :: snd real(kind=rDef), intent(in), DIMENSION(:) :: dsn real(kind=rDef), intent(inout), DIMENSION(:,:) :: dd integer, intent(in) :: ifdff real(kind=rDef), intent(in) :: ed2 real(kind=rDef), intent(in) :: ed4","tags":"","loc":"module/interpmodule.html"},{"title":"sndspdModule – Fortran Program","text":"Uses iso_fortran_env Contents Interfaces sndspd Interfaces public interface sndspd private subroutine sndspd1(np, rr, rmsw, asnd, dsnd, dd, rhob, angom, gam, sig, is) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np real(kind=rDef), intent(in), DIMENSION(:) :: rr real(kind=rDef), intent(in), DIMENSION(:) :: rmsw real(kind=rDef), intent(out), DIMENSION(:) :: asnd real(kind=rDef), intent(out), DIMENSION(:) :: dsnd real(kind=rDef), intent(in), DIMENSION(:,:) :: dd real(kind=rDef), intent(in), DIMENSION(:) :: rhob real(kind=rDef), intent(in) :: angom real(kind=rDef), intent(in) :: gam real(kind=rDef), intent(in) :: sig integer, intent(in) :: is","tags":"","loc":"module/sndspdmodule.html"},{"title":"smachModule – Fortran Program","text":"Uses iso_fortran_env Contents Interfaces smach Interfaces public interface smach private subroutine smach1(npts, rr, rmsw, rmswp, snd, dsn, dd, angom, gam, rro, is) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npts real(kind=rDef), intent(in), DIMENSION(:) :: rr real(kind=rDef), intent(out), DIMENSION(:) :: rmsw real(kind=rDef), intent(out), DIMENSION(:) :: rmswp real(kind=rDef), intent(in), DIMENSION(:) :: snd real(kind=rDef), intent(in), DIMENSION(:) :: dsn real(kind=rDef), intent(in), DIMENSION(:,:) :: dd real(kind=rDef), intent(in) :: angom real(kind=rDef), intent(in) :: gam real(kind=rDef), intent(in) :: rro integer, intent(in) :: is","tags":"","loc":"module/smachmodule.html"},{"title":"SourceTermModule – Fortran Program","text":"Uses iso_fortran_env Contents Interfaces getMMSSourceTerms getSoundSpeed getPerturbationVariables Interfaces public interface getMMSSourceTerms private subroutine SourceCalc(r, S_1, S_2, S_3, S_4) Arguments Type Intent Optional Attributes Name real(kind=rDef), intent(in), DIMENSION(:) :: r complex(kind=rDef), intent(inout), DIMENSION(:) :: S_1 complex(kind=rDef), intent(inout), DIMENSION(:) :: S_2 complex(kind=rDef), intent(inout), DIMENSION(:) :: S_3 complex(kind=rDef), intent(inout), DIMENSION(:) :: S_4 public interface getSoundSpeed private subroutine CalcSoundSpeed(r, SoundSpeedExpected, thetaMachData, axialMachData) Arguments Type Intent Optional Attributes Name real(kind=rDef), intent(in), DIMENSION(:) :: r real(kind=rDef), intent(inout), DIMENSION(:) :: SoundSpeedExpected real(kind=rDef), intent(inout), DIMENSION(:) :: thetaMachData real(kind=rDef), intent(inout), DIMENSION(:) :: axialMachData public interface getPerturbationVariables private subroutine CalcPerturbationVariables(r, vR, vTh, vX, Pr) Arguments Type Intent Optional Attributes Name real(kind=rDef), intent(in), DIMENSION(:) :: r real(kind=rDef), intent(inout), DIMENSION(:) :: vR real(kind=rDef), intent(inout), DIMENSION(:) :: vTh real(kind=rDef), intent(inout), DIMENSION(:) :: vX real(kind=rDef), intent(inout), DIMENSION(:) :: Pr","tags":"","loc":"module/sourcetermmodule.html"},{"title":"L2NormModule – Fortran Program","text":"Uses iso_fortran_env Contents Interfaces getL2Norm Interfaces public interface getL2Norm private subroutine L2N(L2, dataSet1, dataSet2) Arguments Type Intent Optional Attributes Name real(kind=rDef), intent(inout) :: L2 real(kind=rDef), intent(in), DIMENSION(:) :: dataSet1 real(kind=rDef), intent(in), DIMENSION(:) :: dataSet2 private subroutine L2N_One_Dataset(L2, dataSet) Arguments Type Intent Optional Attributes Name real(kind=rDef), intent(inout) :: L2 real(kind=rDef), intent(in), DIMENSION(:) :: dataSet private subroutine L2N_One_Dataset_Complex(L2, dataSet) Arguments Type Intent Optional Attributes Name complex(kind=rDef), intent(inout) :: L2 complex(kind=rDef), intent(in), DIMENSION(:) :: dataSet private subroutine L2N_COMPLEX(L2, dataSet1, dataSet2) Arguments Type Intent Optional Attributes Name complex(kind=rDef), intent(inout) :: L2 complex(kind=rDef), intent(in), DIMENSION(:) :: dataSet1 complex(kind=rDef), intent(in), DIMENSION(:) :: dataSet2 private subroutine L2N_2D(L2, dataSet1, dataSet2, numPoints) Arguments Type Intent Optional Attributes Name complex(kind=rDef), intent(inout) :: L2 complex(kind=rDef), intent(in), DIMENSION(:,:) :: dataSet1 complex(kind=rDef), intent(in), DIMENSION(:,:) :: dataSet2 integer, intent(inout) :: numPoints","tags":"","loc":"module/l2normmodule.html"},{"title":"gridModule – Fortran Program","text":"Uses iso_fortran_env Contents Interfaces grid Interfaces public interface grid private subroutine grid1(np, sig, x, r) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np real(kind=rDef), intent(in) :: sig real(kind=rDef), intent(out), DIMENSION(:) :: x real(kind=rDef), intent(out), DIMENSION(:) :: r","tags":"","loc":"module/gridmodule.html"},{"title":"egvModule – Fortran Program","text":"Initialized character to append at the end of the file name INTEGER :: i,j,k,n, mf, mn, mx, nf, delta_egv,ncols the output is currently done such that the real values are stored in basen and imaginary values are stored with basem WRITE(0,*) nfile(n), mfile(n) redefining file name for each eigenvalue rewind nfile(n)\n        rewind mfile(n) 5    format('#',2i4,100e10.2)\n      if (egv .eq. 'V') then Uses iso_fortran_env Contents Interfaces saveEGV Interfaces public interface saveEGV private subroutine saveEGV2(np, vrm, rr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np complex(kind=rDef), intent(in), DIMENSION(:,:) :: vrm real(kind=rDef), intent(in), DIMENSION(:) :: rr","tags":"","loc":"module/egvmodule.html"},{"title":"FindResidualVectorModule – Fortran Program","text":"Uses iso_fortran_env Contents Interfaces getSvector Interfaces public interface getSvector private subroutine getSv1Dinput(A, B, x, lambda, np4, S_MMS) Arguments Type Intent Optional Attributes Name complex(kind=REAL64), intent(in), DIMENSION(np4, np4) :: A complex(kind=REAL64), intent(in), DIMENSION(np4, np4) :: B complex(kind=REAL64), intent(inout), DIMENSION(np4) :: x complex(kind=REAL64), intent(in) :: lambda integer, intent(in) :: np4 complex(kind=REAL64), intent(inout), DIMENSION(np4) :: S_MMS","tags":"","loc":"module/findresidualvectormodule.html"},{"title":"kapsubModule – Fortran Program","text":"Uses iso_fortran_env Contents Interfaces kappa Interfaces public interface kappa private subroutine kappa1(mm, mumax, sig, mu, akap) Arguments Type Intent Optional Attributes Name integer, intent(in) :: mm integer, intent(in) :: mumax real(kind=rDef), intent(in) :: sig integer, intent(inout), DIMENSION(:) :: mu real(kind=rDef), intent(inout), DIMENSION(:) :: akap","tags":"","loc":"module/kapsubmodule.html"},{"title":"machoutModule – Fortran Program","text":"Uses iso_fortran_env Contents Interfaces machout Interfaces public interface machout private subroutine machout1(npts, rr, rmch, rmchp, rmsw, rmswp, snd, dsn, rhob) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npts real(kind=rDef), intent(in), DIMENSION(:) :: rr real(kind=rDef), intent(in), DIMENSION(:) :: rmch real(kind=rDef), intent(in), DIMENSION(:) :: rmchp real(kind=rDef), intent(in), DIMENSION(:) :: rmsw real(kind=rDef), intent(in), DIMENSION(:) :: rmswp real(kind=rDef), intent(in), DIMENSION(:) :: snd real(kind=rDef), intent(in), DIMENSION(:) :: dsn real(kind=rDef), intent(out), DIMENSION(:) :: rhob","tags":"","loc":"module/machoutmodule.html"},{"title":"MAIN – Fortran Program","text":"Uses swirlClassObject mmsClassObject SourceTermModule iso_fortran_env Contents Variables dir_name file_id FORMAT_MEAN_FLOW FORMAT_PERTURB_VARS FORMAT_PERTURB_HEADER FORMAT_MEAN_FLOW_HEADER FORMAT_SOURCE_TERMS FORMAT_SOURCE_TERMS_HEADER FORMAT_L2 FORMAT_L2_HEADER FORMAT_ERROR FORMAT_ERROR_HEADER FORMAT_ROC FORMAT_ROC_HEADER debug rDef numberOfIterations UNIT finiteDiffFlag numericalIntegrationFlag numberOfGridPoints azimuthalModeNumber i fac facCount numberOfGridPointsArray r rOut vR vX vTh Pr speedOfSoundMMS SoundSpeedError axialMachDataMMS thetaMachDataMMS axialMachDataMMSOut thetaMachDataMMSOut axialMach_drMMSOut thetaMach_drMMSOut SoundSpeedOut SoundSpeedL2Array SoundSpeed_drOut axialMachData thetaMachData totalMachData RateOfConvergence1 RateOfConvergence2 S_error gam SoundSpeedErrorL2 ExpectedRateOfConvergenceSoundSpeed ExpectedRateOfConvergenceSourceTerm r_min r_max secondOrderSmoother fourthOrderSmoother dr hubToTipRatio S_L2 eigenValueMMS hubAdmittance ductAdmittance frequency S_1 S_2 S_3 S_4 S_MMS S_actual S_L2Array eigenVectorMMS swirlClassObjMMS SoundSpeedMMS_ClassObj SourceTermMMS_ClassObj Variables Type Attributes Name Initial character(len=50) :: dir_name character(len=50) :: file_id character(len=50) :: FORMAT_MEAN_FLOW character(len=50) :: FORMAT_PERTURB_VARS character(len=50) :: FORMAT_PERTURB_HEADER character(len=50) :: FORMAT_MEAN_FLOW_HEADER character(len=50) :: FORMAT_SOURCE_TERMS character(len=50) :: FORMAT_SOURCE_TERMS_HEADER character(len=50) :: FORMAT_L2 character(len=50) :: FORMAT_L2_HEADER character(len=50) :: FORMAT_ERROR character(len=50) :: FORMAT_ERROR_HEADER character(len=50) :: FORMAT_ROC character(len=50) :: FORMAT_ROC_HEADER logical :: debug = .TRUE. integer, parameter :: rDef = REAL64 integer, parameter :: numberOfIterations = 9 integer :: UNIT integer :: finiteDiffFlag integer :: numericalIntegrationFlag integer :: numberOfGridPoints integer :: azimuthalModeNumber integer :: i integer :: fac integer :: facCount integer, DIMENSION(:), ALLOCATABLE :: numberOfGridPointsArray real(kind=rDef), DIMENSION(:), ALLOCATABLE :: r real(kind=rDef), DIMENSION(:), ALLOCATABLE :: rOut real(kind=rDef), DIMENSION(:), ALLOCATABLE :: vR real(kind=rDef), DIMENSION(:), ALLOCATABLE :: vX real(kind=rDef), DIMENSION(:), ALLOCATABLE :: vTh real(kind=rDef), DIMENSION(:), ALLOCATABLE :: Pr real(kind=rDef), DIMENSION(:), ALLOCATABLE :: speedOfSoundMMS real(kind=rDef), DIMENSION(:), ALLOCATABLE :: SoundSpeedError real(kind=rDef), DIMENSION(:), ALLOCATABLE :: axialMachDataMMS real(kind=rDef), DIMENSION(:), ALLOCATABLE :: thetaMachDataMMS real(kind=rDef), DIMENSION(:), ALLOCATABLE :: axialMachDataMMSOut real(kind=rDef), DIMENSION(:), ALLOCATABLE :: thetaMachDataMMSOut real(kind=rDef), DIMENSION(:), ALLOCATABLE :: axialMach_drMMSOut real(kind=rDef), DIMENSION(:), ALLOCATABLE :: thetaMach_drMMSOut real(kind=rDef), DIMENSION(:), ALLOCATABLE :: SoundSpeedOut real(kind=rDef), DIMENSION(:), ALLOCATABLE :: SoundSpeedL2Array real(kind=rDef), DIMENSION(:), ALLOCATABLE :: SoundSpeed_drOut real(kind=rDef), DIMENSION(:), ALLOCATABLE :: axialMachData real(kind=rDef), DIMENSION(:), ALLOCATABLE :: thetaMachData real(kind=rDef), DIMENSION(:), ALLOCATABLE :: totalMachData real(kind=rDef), DIMENSION(:), ALLOCATABLE :: RateOfConvergence1 real(kind=rDef), DIMENSION(:), ALLOCATABLE :: RateOfConvergence2 real(kind=rDef), DIMENSION(:), ALLOCATABLE :: S_error real(kind=REAL64) :: gam real(kind=REAL64) :: SoundSpeedErrorL2 real(kind=REAL64) :: ExpectedRateOfConvergenceSoundSpeed real(kind=REAL64) :: ExpectedRateOfConvergenceSourceTerm real(kind=REAL64) :: r_min real(kind=REAL64) :: r_max real(kind=REAL64) :: secondOrderSmoother real(kind=REAL64) :: fourthOrderSmoother real(kind=REAL64) :: dr real(kind=REAL64) :: hubToTipRatio complex(kind=rDef) :: S_L2 complex(kind=rDef) :: eigenValueMMS complex(kind=rDef) :: hubAdmittance complex(kind=rDef) :: ductAdmittance complex(kind=rDef) :: frequency complex(kind=rDef), DIMENSION(:), ALLOCATABLE :: S_1 complex(kind=rDef), DIMENSION(:), ALLOCATABLE :: S_2 complex(kind=rDef), DIMENSION(:), ALLOCATABLE :: S_3 complex(kind=rDef), DIMENSION(:), ALLOCATABLE :: S_4 complex(kind=rDef), DIMENSION(:), ALLOCATABLE :: S_MMS complex(kind=rDef), DIMENSION(:), ALLOCATABLE :: S_actual complex(kind=rDef), DIMENSION(:), ALLOCATABLE :: S_L2Array complex(kind=rDef), DIMENSION(:), ALLOCATABLE :: eigenVectorMMS type(SwirlClassType), DIMENSION(numberOfIterations) :: swirlClassObjMMS type(mmsClassType) :: SoundSpeedMMS_ClassObj type(mmsClassType) :: SourceTermMMS_ClassObj","tags":"","loc":"program/main.html"},{"title":"MAIN – Fortran Program","text":"Uses iso_fortran_env Contents Variables rDef UNIT i j numberOfXlocations numberOfPoints x_max x_min delta_x C S_horiz S_vert A B x y R L x_loc y_loc debug Variables Type Attributes Name Initial integer, parameter :: rDef = REAL64 integer :: UNIT integer :: i integer :: j integer :: numberOfXlocations integer :: numberOfPoints real(kind=rDef) :: x_max real(kind=rDef) :: x_min real(kind=rDef) :: delta_x real(kind=rDef) :: C real(kind=rDef) :: S_horiz real(kind=rDef) :: S_vert real(kind=rDef), DIMENSION(:), ALLOCATABLE :: A real(kind=rDef), DIMENSION(:), ALLOCATABLE :: B real(kind=rDef), DIMENSION(:), ALLOCATABLE :: x real(kind=rDef), DIMENSION(:), ALLOCATABLE :: y real(kind=rDef), DIMENSION(:), ALLOCATABLE :: R real(kind=rDef), DIMENSION(:), ALLOCATABLE :: L real(kind=rDef), DIMENSION(:), ALLOCATABLE :: x_loc real(kind=rDef), DIMENSION(:), ALLOCATABLE :: y_loc logical :: debug = .TRUE.","tags":"","loc":"program/main~2.html"}]}